# 3장 커널 로딩

## GRUB (Grand Unified Bootloader)

GRUB은 GNU 프로젝트의 부트로더이다.

> 부트로더 ( Boot Loader )
>
> - 운영체제가 시동되기 이전에 미리 실행되면서 커널이 올바르게 시동되기 위해 필요한 모든 관련 작업을 마무리하고 최종적으로 운영체제를 시동시키기 위한 목적을 가진 프로그램

GRUB은 우리가 운영체제를 부팅할 때, 장치(하드디스크, 플로피 디스크, USB) 에 구애되지 않고 부팅이 가능하도록 도와준다. ( 운영체제 멀티 부팅을 위해 널리 사용되고 있다.)

> GRUB은 이렇게 상용으로 사용되는 운영체제를 로드할 수 있을 뿐 아니라 개인이 자체 제작한 운영체제 커널도 규격에 맞추면 로드할 수 있는 능력을 갖추고 있다.

대표적인 기능

1. 파일시스템 직접 접근 기능
2. 다양한 실행 파일 형식 지원
3. 비 멀티부팅 운영체제 지원
4. 메뉴 인터페이스 (부팅 화면)
   - 그래픽 메뉴 및 배경 그림 사용 가능
   - 콘손 인터페이스 지원
5. 다양한 파일 시스템 지원



GRUB은우리가 제작한 커널 파일이 유효한 커널인지 확인한 후 커널을 메모리로 적재한다. 

또한 하드웨어 제반사항을 초기화 한 후, 커널 엔트리를 호출해서 제어권을 커널 코드로 이양한다.

> 이 과정에서 GRUB은 커널에 하드웨어 초기화 정보를 넘겨준다.

![Image](https://i.imgur.com/zXN4UkW.png)



## 부팅

### **GRUB를 통한 전체 부팅 과정**

1. 바이오스가 부팅 장치를 찾고 MBR( Master Boot Record )을 읽어온다.

   > MBR ( Master Boot Record ) 은 저장매체의 첫 번째 섹터를 의미하며 운영체제 부팅 시 POST(Power On Self-Test) 과정을 마친 후 이 첫 번째 섹터를 바이오스가 메모리로 읽어들인다. 그 후 읽어들인 부트 코드로 제어권이 이양되어 코드가 실행된다.

2. MBR에 GRUB 스테이지 1이 있으며 GRUB 스테이지 1은 스테이지 1.5나 2를 불러온다.

3. 스테이지 1.5는 MBR 직후 30kb 영역에 저장되며 이는 스테이지 2를 불러온다.

4. GRUB 스테이지 2는 부트 메뉴나 명령 프롬프트를 보여준다.

5. 기본값 커널이나 사용자가 선택한 커널을 메모리에 적재시켜서 커널 엔트리를 실행한다.

![Image](https://i.imgur.com/2BHk75P.png)

하드디스크는 논리적으로 여러 개의 하드 디스크(파티션)으로 나눌 수 있다.

최초 컴퓨터가 부팅된 후 MBR에서 부팅 가능한 논리 하드 디스크를 조회하고 부팅가능한 논리 하드 디스크가 있다면 해당 논리디스크의 부트섹터를 찾아서 메모리로 읽어들이고 그 부트섹터 코드를 실행한다.

운영체제가 윈도우라면, 부트섹터는 Ntldr 이라는 커널로더를 메모리에 적재시키며 제어권을 Ntldr에 이양한다.

> Ntldr은 커널의 코어와 파일시스템 관련 시스템 파일을 로드해서 운영체제를 가동시키며 커널 코어와 파일시스템은 시스템 자원을 활용하기 위해 여러 커널 모듈을 동적 또는 정적으로 로드시켜 운영체제를 실행하면서 유저 애플리케이션의 요청에 대응한다.



GRUB의 측면에서 이야기 하자면, GRUB은 부팅 후 Ntldr의 역할까지 수행한다. ( 운영체제가 설치된 환경이 하드 디스크든, 시디롬이든 상관 없다. )

> 우리가 제작하는 커널은 GRUB 덕분에 Ntoskrnl.exe(NT OS Kernel) 프로세스에만 집중하면 된다.
>
> 즉, 커널을 메모리에 적재하는 과정을 구현하지 않아도 된다.



GRUB이 커널을 로드하는 과정 

![Image](https://i.imgur.com/ug4cddf.png)

바이오스는 부트섹터에 기록된 boot.img 512byte를 메모리에 적재한 뒤 제어권을 넘긴다( Stage1 ).

boot.img 파일은 Stage2에 해당하는 core.img를 메모리에 적재시켜 해당 코드를 실행하는데 여기서는 menu.lst 파일이나 grub.cfg 설정 파일을 참고해서 커널 리스트를 가져온다.

그리고 커널을 선택해서 실행하면 GRUB은 커널을 메모리에 적재시킨 뒤 커널의 엔트리 포인트에 제어권을 넘기고 종료된다.



## 설치

준비물

- WinImage
- Bootice[다운로드 링크](https://bootice.ko.softonic.com/download)
- 가상 디스크에 복사할 파일[다운로드 링크]()



### 가상 플로피 디스크 제작

- 먼저 WinImage를 실행하고 메뉴에서 File->New 항목을 선택한다.

  ![Image](https://i.imgur.com/oNCjU1e.png)

- OK 버튼을 클릭한 후 특정 폴더에 저장 한다.

  ( 저장시 확장자를 IMA 포맷으로 변경해야 한다. )

- 이제 이렇게 생성한 가상 디스크 부트섹터에 GRUB의 부트섹터 코드를 복사해야 한다.

  ( 부트 섹터 작업을 하기 위해 Bootice를 활용한다. )

  > Bootice는 부트섹터를 관리하는 도구다. 부트섹터 관련 작업은 일반적으로 쉽지 않으므로 이 프로그램을 이용하면 부트섹터에 데이터를 편하게 복사할 수 있다.
  >
  > 즉, GRUB의 부트섹터 데이터를 특정매체의 부트섹터에 복사하기 위해 Bootice를 사용한다.

  Bootice 프로그램을 실행한 후 Disk Image 탭을 선택한 뒤에 WinImage를 통해 생성한 IMA 이미지를 선택한다.

  ![Image](https://i.imgur.com/B7bfq1V.png)

  IMA 이미지를 선택하면 Process PBR이 활성화 되는데, 이를 클릭하면

  ![Image](https://i.imgur.com/8uTrnxK.png)

  화면이 뜨게 되고, Grub4Dos 0.4.5b(FAT/FAT32/NTFS/Ext2) 를 선택한 후 Install/ Config 버튼을 클릭하면 부트섹터 코드가 플로피 디스크의 부트섹터에 카피된다.

  > Install/ Config 클릭 후 과정
  >
  > ![Image](https://i.imgur.com/qYwCx8t.png)
  >
  > ![Image](https://i.imgur.com/I3nMyd6.png)
  >
  > ![Image](https://i.imgur.com/baETbLQ.png)

- 준비물에서 다운받았던 파일들을 가상 플로피 디스크에 WinImage를 사용해서 복사한다.

  (GRLDR, BOOT 폴더)

  위 단계에서 bootice를 사용해 복사했던 부트섹터 코드는 grldr이라는 파일을 찾는다. 

  ![Image](https://i.imgur.com/1MiFf4E.png)

  > 여기까지 잘 수행했다면 커널을 로드할 수 있는 환경이 구성된 것이다.<br>지금 작성한 IMA파일은 1장에서 했던 IMA파일과 동일하다.
  >
  
- 마지막으로 빌드한 SKYOS32.EXE 커널을 가상 디스크에 복사한다.

  (1장에서 빌드했던 .exe파일과 .map 파일)
  
  >  가상 디스크의 최종 구성
  >
  > ![Image](https://i.imgur.com/HZMMk2N.png)



>  grldr, 그랜드 로더는 boot 폴더에 있는 menu.lst를 읽어 부팅가능한 커널들을 리스팅 해준다.

boot폴더의 menu.lst

```
timeout 20

title Sky OS
kernel /SKYOS32.EXE
```

메뉴의 타임아웃 시간이 20초이고 SkyOS라는 운영체제와 해당 운영체제의 파일 위치를 지정하고 있다.

> 위와 같은 형식으로 커널들을 여러 개 나열해 주면 부팅 시 멀티 부팅이 가능하다.<br>플로피 디스크는 공간이 부족해서 여러 개의 운영체제를 담을 수는 없지만, CD나 USB에 GRUB을 설치하면 여러 운영체제의 멀티 부팅이 가능해진다.
>



## 실행

지금까지 부팅 가능한 디스크를 제작 했다면, 이제 QEMU 에뮬레이터에서 이 부팅디스크가 제대로 동작하는지 확인한다.



QEMU의 설치 폴더에 가보면 ``qemu-system-x86_64.exe`` 파일이 존재한다.

해당 파일에 커멘드를 보내기 위해 배치 파일을 하나 만들자.

```
// chapter3.bat

REM Start qemu on windows.
@ECHO OFF
SET SDL_VIDEODRIVER=windib
SET SDL_AUDIODRIVER=dsound
SET QEMU_AUDIO_DRV=dsound
SET QEMU_AUDIO_LOG_TO_MONITOR=0

cd C:\Program Files\qemu 	// 관리자 권한으로 실행할 때, 경로가 처음으로 되있는 경우를 위해서 설정
qemu-system-x86_64.exe -L . -m 128 -fda chapter3.ima -soundhw sb16,es1370 -localtime -M pc

SET /P P = Press any Key continue: // 배치파일 오류시 바로 꺼지는걸 방지하기 위해 설정
```

> 여러가지 내용이 있지만 주목해야 할 부분은 qemu-system-x86_64.exe~ 부분이다. 
>
> 여러가지 옵션이 qemu에 전달되는데 각 옵션의 의미는 다음과 같다.
>
> - m : 메모리 128MB 설정
> - fda : 플로피 디스크 이미지 지정
> - soundhw : 사운드 하드웨어, 사운드블래스터16 또는 es1370 에뮬레이션
> - localtime : 로컬타임을 사용
> - M : 플랫폼 지정, 여기서는 pc



배치 파일을 만들고 가상 디스크 파일(.IMA) 파일과 함께 QEMU 폴더에 복사 후 배치 파일을 실행

![Image](https://i.imgur.com/6wEXppd.png)

> 1장에서 처럼 "Hello World!" 문자열이 콘솔에 출력되었다면 제대로 SkyOS커널을 로드한 것이다.<br>이로써 "Hello World!"를 출력하기 위해 필요한 번잡한 과정(하위 호환을 위해 16bit 리얼모드 작업)을 건너 뛸 수 있다.

> 운영체제를 개발할 때 어려운 부분은 "Hello World!"를 출력하기 전에 너무 많은 작업을 본인이 다 해야 한다는 데에 있다. <br>하위 호환을 위해 16비트 리얼모드 작업부터 시작해 32bit 커널 작업을 위해 수많은 작업을 수행해야 한다.
>
> > 리얼모드<br>리얼 주소 모드 또는 호환 모드라고 한다. 80286 이후의 x86 호환 CPU의 운영 방식이다. 리얼모드는 20bit 세그먼트 방식을 사용해서 최대 1MB의 메모리 주소에 접근할 수 있다. 80286 계열 이후의 모든 CPU는 전원이 켜질 때 리얼모드에서 시작한다.
>>
> 
> 리얼모드가 16비트상에서 시작하고 메모리에 접근할 수 있는 범위가 1MB에 불과해 CPU가 32bit나 64bit 어셈블리를 해석할 수 있도록 하거나, 1MB 이상의 메모리 범위에 접근하기 위해서는 하드웨어에 종속적인 초기화 작업을 수행해야 한다.
> 
>이런 초기화 작업을 구현하는 것이 만만치 않기 때문에 "Hello World" 문자열을 화면에 출력하는 것은 결코 쉬운 일이 아니다.





