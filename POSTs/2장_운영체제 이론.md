

# 2장 운영체제 이론

1. [프로세스](##프로세스)

2. [스레드](##스레드)
3. [스택](##스택)
4. [호출 규약](##호출-규약)

## 프로세스

프로세스는 컴퓨터에서 실행되는 프로그램을 의미한다.

> 일반적으로 프로그램은 하드 디스크에 저장되어 있는데,<br>프로그램을 실행하면 운영체제 로더에 의해 메모리에 적재된다.<br>엄밀히 말하면 메모리에 적재되어 실행되는 프로그램을 "**프로세스**" 라고 한다.
>

![Image](https://i.imgur.com/fdhR2zY.png)

- 프로세스 컨텍스트 (Process Context)

  프로세스 문맥이라고도 하며, 운영체제가 관리하는 프로세스 정보이다.

  - CPU 상태
    - CPU 레지스터, 현재 프로세스가 수행되고 있는 위치 등 (IP : Instruction Pointer)
  - PCB (Process Control Block)
    - 커널이 관리하는 프로세스 정보 구조체
  - 가상주소공간 데이터
    - 코드, 데이터, 스택, 힙

- PCB (Process Control Block : 프로세스 제어 블록)

  운영체제 커널의 자료구조로써 프로세스를 표현하기 위해 사용된다.

  커널은 이 자료구조를 사용해 프로세스를 관리한다.

  PCB는 프로세스가 생성될 때 같이 생성되며 프로세스 고유의 정보를 포함한다.

  > WIN32 프로세스에서의 PCB 구조
  >
  > ![Image](https://i.imgur.com/v8M6gej.png)

  PCB는 체인으로 다른 PCB에 연결되어 있다.

  - OS가 관리상 사용하는 정보 : 
    - 프로세스 상태
    - 프로세스 ID
    - 스케줄링 정보
    - 우선순위
  - CPU 수행 관련 하드웨어 값 :
    - 프로그램 카운터, 레지스터
  - 메모리 정보
    - 코드
    - 데이터
    - 스택의 위치 정보
  - 파일정보
    - 열어둔 파일 정보 (Handle)

- 프로세스 상태

  컨텍스트 스위칭 (Context Switching)에 의해 프로세스는 실행 상태에 놓일 수도 있고, 정지상태에 놓일 수도 있다.

  > 프로세스 상태 다이어그램
  >
  > ![Image](https://i.imgur.com/pXvqKN3.png)
  >
  > | 프로세스 상태    | 내용                                                         |
  > | ---------------- | ------------------------------------------------------------ |
  > | 실행             | 프로세스가 CPU를 점유하고 있는 상태                          |
  > | 대기             | 프로세스가 CPU를 점유하기 위해 기다리고 있는 상태<br />(메모리에는 이미 올라와 있으며 CPU동작을 위한 모든 조건 또한 만족한 상태) |
  > | 블록(wait,sleep) | 당장은 작업이 수행될 수 없는 상태<br />sleep 함수를 사용하거나 동기화를 위해 대기해야 할 경우 프로세스가 블록된다. |
  > | 정지 상태        | 스케줄러나 인터럽트 때문에 비활성화된 상태<br /> 외부에서 다시 재개시켜야 활성화 상태로 변경된다. |

- 컨텍스트 스위칭

  CPU가 한 프로세스에서 다른 프로세스의 PCB 정보로 스위칭 되는 과정을 의미한다.![Image](https://i.imgur.com/dM4sIt3.png)
  
  컨텍스트 스위칭은 시스템 콜이나 외부 인터럽트에 의해 발생된다.
  
  두 프로세스는 컨텍스트 스위칭 발생 시, 위 과정을  반복하면서 실행과 중지를 반복한다.



## 스레드

프로세스가 프로그램의 주체라면, 스레드는 프로세스의 실제 실행 단위이다.

> 프로세스는 여러 개의 스레드를 담고 있으며 커널은 프로세스가 담고 있는 스레드를 관리해 프로세스의 동작을 조정한다.

스레드는 가상 주소 공간을 공유한다.

![Image](https://i.imgur.com/kwlsAPh.png)

그림과 같이 스레드는 프로세스의 자원을 공유한다.

코드 영역을 동시에 접근하는 것은 문제가 되지 않지만, **쓰기 가능한 데이터 영역에 동시에 접근할 경우** 데이터 무결성에 문제가 생길 수 있다.

> 무결성 : 데이터의 정확성과 일관성을 유지하고 보증하는 것

스택의 경우 스레드 고유의 자원이며 일반적인 경우에는 다른 스레드로부터 전혀 간섭을 받지 않기 때문에 동기화 걱정 없이 마음대로 사용할 수 있다.

- 스레드 경합

  자료구조나 데이터에 **복수의 스레드가 접근**하면 문제가 발생할 수 있다.

  > 이런 상태를 **경쟁 상태** 또는 **경합 상태(Race Condition)**라고 한다.

  ```c++
  <경합상태 예제 코드>
  -------------------------------------------------------------------------------------
  int counter = 0;
  // 스레드 메인 엔트리
  void compute()
  {
  	counter++;
      printf("Counter value : %d\n", counter);
  }
  
  int main()
  {
      pthread_t thread1, thread2;
      // 스레드를 두개 생성한다.
      pthread_create(&thread1, NULL, compute, NULL);
      pthread_create(&thread2, NULL, compute, NULL);
      
      //스레드가 종료할 때 까지 대기한다.
      pthread_join(thread1, NULL);
      pthread_join(thread2, NULL);
      return 0;
  }
  ```

  ```
  #1.
  Count Value : 1
  Count Value : 1
  --------------------------------------------------------------------------------
  #2.
  Count Value : 1
  Count Value : 2
  ```

  위 프로그램의 실행 결과를 정확히 예측하는 것은 불가능하다.

  > counter++; 라인이 **단위 연산이 아니기 때문**이다. 

  이런 문제를 해결하기 위해 동기화를 적용해야 한다.

  

  동기화를 적용하기 위해서는 **동기화 객체**를 사용하면 되는데 그 종류는 다음과 같다.

  - 크리티컬 섹션

    - 임계 영역
    - 스레드가 이 공유자원을 획득하면 이후 코드 실행의 독점을 보장 받는다.

    > 프로세스 내 스레드간 동기화를 위해 필요한 것으로 크리티컬 섹션의 획득을 위해서 커널 요청을 하지는 않는다. (즉, 유저 모드 단에서 동기화 할 때 사용한다.)

  - 뮤텍스

    - 프로세스간 공유자원을 다른다.
    - 한 프로세스가 뮤텍스를 획득하면 이 뮤텍스를 해제할 때 까지 상호 배제가 보장된다.

    > 프로세스간 공유하는 자원에 접근하므로 뮤텍스 객체의 획득을 위해서 커널에 요청한다.

  - 세마포어

    - 뮤텍스처럼 프로세스간 공유 객체를 다룰 수 있으나, **상호배제적이지는 않다.**
    - 참조 카운트를 설정할 수 있어서 그 만큼 프로세스가 세마포어를 획득 할 수 있다.

  - Interlocked 계열의 함수

    - 함수 자체에서 스레드 세이프를 보장한다.
      - 컨텍스트 스위칭이 발생 하지 않기 때문에 다른 스레드의 간섭을 받지 않는다.

    > Atomic Operation 또는 단위 연산으로 불린다.

  - 스핀 락

    - 임계 구역에 진입이 불가능 할 때 진입이 가능할 때 까지 루프를 돌면서 재시도 하는 방식으로 구현된 락이다.

    - 운영체제의 스케줄링 지원을 받지 않는다.

      - 해당 스레드에 대한 문맥 교환이 일어나지 않는다.

      - 임계 구역에 짧은 시간 안에 진입할 수 있는 경우에 문맥 교환을 제거할 수 있어 효율적이다.

        > 스핀 락에 오랜 시간을 소요한다면 다른 스레드를 실행하지 못하고 대기하게 되며 비효율을 가져온다.

- TCB

  프로세스에 PCB( Process Control Block )이 존재 하듯이 **스레드 정보를 관리 하기 위해** TCB( Thread Control Block : 스레드 제어 블록)가 존재한다.

  > TCB는 커널에서 스레드를 관리하기 위해 필요로 하는 정보를 담고 있는 구조체이다.
  >
  > PCB와 TCB의 관계
  >
  > ![Image](https://i.imgur.com/FiQjm39.png)

  TCB는 다음 정보를 유지한다.

  - **스레드 식별자**

    고유 아이디는 스레드마다 새롭게 할당된다.

  - **스택 포인터**

    스레드의 스택을 가리킨다.

  - **스레드 상태**

    실행, 준비, 대기, 시작, 완료

  - 레지스터 값들

  - 스레드를 담고 있는 프로세스의 PCB 포인터

  

## 스택

스택은 FILO(First In Last Out) 자료구조로, 마지막에 입력된 자료가 먼저 나오는 형태다.

> 이와 반대되는 FIFO(First In First Out) 자료구조에는 큐가 있으며 자료가 먼저 출력되는 구조를 지닌다.

![Image](https://i.imgur.com/3tNOH2J.png)

- 콜스택

  특정 함수가 호출될 때, 지역변수나 함수 파라미터가 특정공간에 저장되는데 이 공간을 **콜스택(*Call Stack)*** 이라고 한다.

  > x86 아키텍처에서는 스택에 변수나 파라미터가 저장될 때 **주소공간이 줄어드는 방향으로** 데이터가 저장된다.
  >
  > ```c++
  > void CreateGenesisBlock(DWORD genesisTime, DWORD nounce)
  > {
  >     Timestamp timestamp;
  >     ...
  > }
  > ```
  >
  > 위와 같은 함수를 호출할 때 콜스택의 상황은 다음과 같다.
  >
  > ![Image](https://i.imgur.com/M2LNQZc.png)
  >
  > CreateGenesisBlock 함수의 수행이 끝나면 이 함수를 호출한 실행 코드의 위치로 돌아갈 필요가 있다.
  >
  > 이 때 필요한 값은 **해당 함수의 복귀 주소와 EBP 값**이다.
  >
  > 이런 값들은 함수호출 시마다 자동으로 생성되는데 이러한 값들의 모음을 **스택 프레임(*Stack Frame)***이라 한다.
  >
  > - ESP 레지스터 :
  >
  >   - 스택의 밑바닥을 가리키는 포인터
  >
  >     최초 함수가 호출될 때 EBP(Extended Stack Pointer)와 ESP(Extended Base Pointer)의 값은 같으며, 로컬변수가 선언되면 ESP는 낮은 값으로 증가한다.(x86 아키텍처의 경우).
  >
  >     ESP는 다음 데이터를 Push할 위치가 아니라 Pop 했을 때 뽑아낼 데이터의 위치를 가리킨다.
  >
  > - EBP 레지스터 : 
  >
  >   - 스택 프레임의 시작 주소를 카리킨다.
  >
  >     새로운 함수가 호출되면 파라미터와 스택 프레임 값이 스택에 채워지는데 EBP 레지스터값은 바로 그 다음 주소를 가리킨다.
  >
  >     > 즉 호출된 함수가 로컬 변수를 선언하기 직전의 시작점이 되며 EBP 값은 함수 실행 동안 변하지 않으므로( 다른함수를 호출하지 않는 한) 파라미터나 로컬변수를 참조할 수 있는 기준점이 된다.
  >
  >     EBP 레지스터는 현재 실행 중인 함수가 종료되고 리턴되면 이 함수를 호출한 함수의 EBP 값으로 변경된다. ( 스택 프레임에 저장된 EBP 값) 



## 호출 규약

호출자( *caller* )가 스택을 정리할 것인지, 아니면 호출자( *caller* )가 스택을 정리할 것인지에 따라 호출 규약이 정해진다.

> 즉, 스택을 정리하는 방법과 파라미터를 입력하는 방식을 통틀어 ***호출 규약(Calling Convention)***이라 부른다.

| 호출 규약 | 인자 전달 순서 | 스택 정리 책임   | 네임 맹글링 | 기타                                                |
| :-------- | :------------- | :--------------- | :---------- | :-------------------------------------------------- |
| _cdecl    | 오른쪽 -> 왼쪽 | 호출자           | _FOO        | _stdcall에 비해 프로그램이 커짐                     |
| _stdcall  | 오른쪽->왼쪽   | 피호출자         | _FOO12      | 모든 시스템에서 사용                                |
| _fastcall | 오른쪽->왼쪽   | 피호출자         | @FOO@12     | 매개변수를 최대한 레지스터에 저장                   |
| _thiscall | 오른쪽->왼쪽   | 상황에 따라 변경 |             | this 매개변수가 ECX 레지스터에 전달                 |
| _pascall  | 왼쪽->오른쪽   | 호출자           |             |                                                     |
| naked     | 오른쪽->왼쪽   | 호출자           |             | 사용자 지정 프롤로그와 <br />에필로그를필요로 할 때 |

> ***_cdecl ( C Declaration )***, ***_stdcall ( Standard Call )***,  
>
> 일반적인 함수 선언 시 호출 규약은 ***cdecl***이나 ***stdcall***을 따른다. 
>
> ***thiscall***은 클래스 객체의 메소드를 호출할 때 객체 자신을 가리키는 포인터를 파라미터로 전달하기 위해 쓰인다. 함수 호출 규약 방식을 변경하기 위해서는 컴파일 옵션을 변경하면 된다.
>
> **컴파일 옵션 : ** /Gz(stdcall), /Gr(fastcall), /Gd(cdecl)
>
> ***stdcall***은 호출되는 함수가 스택을 정리하기 때문에 얼마나 많은 인자가 들어오는지를 알 수 없다.
>
> 반면, **cdecl**은 호출자가 스택을 정리하기 때문에 가변 매개 변수를 취급할 수 있다. 하지만, 호출자가 스택을 정리하므로 함수 호출 시마다 스택을 정리하는코드가 삽입되므로 코드가 길어진다.
>
> ***pascall***은 이제 거의 쓰이지 않으며 인자를 스택에 넣을 때 왼쪽에서 오른쪽 순으로 인자를 집어 넣는다. 
>
> 모든 호출 규약이 중요하지만 반드시 기억해야 할 호출 규약 키워드는 ***naked***이다.  이 키워드를 활용해서 함수를 호출할 경우에는 스택 프레임을 형성하지 않으므로 함수 종료 시 우리가 스택을 정리하는 작업을 수행해야 한다. ( 운영체제 제작을 위해서는 이러한 형태의 함수 호출이 반드시 필요한 만큼 익숙해질 필요가 있다.)

> 추가) 
>
> 64bit 에서는 더 이상 32bit의 호출 규약 방식을 따르지 않는다. 함수 파라미터의 경우 변수가 몇 개 되지 않으면 스택에 값을 저장하지 않고 레지스터에서 값을 유지시킨다. 또한 인라인 어셈블리 언어를 직접 사용할 수 없기 때문에 naked 구문을 사용할 수 없다.



## 네임 맹글링

네임 맹글링 ( name mangling )은 소스코드가 컴파일되고 오브젝트 파일을 생성한 후, **링킹( Linking ) 과정에서 함수나 전역 변수의 이름이 일정한 규칙을 가진채 변경되는 과정**을 의미한다. (Name Decoration 이라고도 한다.)

> 이런 작업이 일어나는 이유는 링커가 다른 범위에 있는 같은 이름의 함수와 변수들을 구별하기 위해서다.

네임 맹글링시 고려되는 사항

- 함수 이름
- 파라미터 타입
- 호출 규약

> C++ 컴파일러는 제조사마다 네임 맹글링 방식이 다를 수 있으며, <br>C 언어로 작성된 dll 파일 등을 C++로 작성된 프로그램에 링크할 때 링크되지 않는 문제가 발생할 수 있다.<br>( 이 경우, **``extern "C"``** 키워드를 활용하면 네임 맹글링 문제를 해결해서 링커가 함수를 찾지 못하는 문제를 해결할 수 있다. )
>



