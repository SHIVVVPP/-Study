![Image](https://i.imgur.com/oCtWyvK.png)

# 5장 메모리 가상화

현대 운영체제 아키텍처의 가장 큰 핵심은 **가상화**이다.<br>수많은 프**로세스가 동시에 하드 디스크에 접근할 경우**,<br>운영체제는 이런 **물리자원을 프로세스가 독점적으로 사용하는 것처럼 지원**해야 한다. <br>또한 **메모리 공간도 프로세스에게 독점적으로 제공**해야 한다.

> 32bit 애플리케이션은 실행 시 4GB의 메모리 공간을 마치 독점적으로 사용하는 것 처럼 보이게 한다.

이 모든 것이 가능한 이유는 **메모리를 가상화했기 때문이다.**

> 이를 위해 필요한 기술인 **페이징**에 대하여 배운다.
>
> 

프로세스의 경우 메모리를 사용할 경우 메모리 전체를 **독점적으로 사용해야 한다.**

> 메모리를 사용할 때 다른 프로세스의 영향을 고려해야 한다면 프로그래밍 복잡도가 증가할 것이다.

이를 구현하기 위해 반드시 이해해야 할 내용이 **가상주소**와 **페이징**이다.



## 가상 주소 공간(*Virtual Address Space*)

가상주소공간(Virtual Address Space)은 프로세스가 참조할 수 있는 주소의 범위로<br>하나의 프로세스마다 하나의 가상 주소 공간이 주어진다.

프로세스는 스레드를 담는 컨테이너 역할을 하므로, <br>실제 코드 실행은 스레드에서 수행되는데, 하나의 프로세스에는 복수의 스레드가 존재하며<br>이런 스레드들은 **가상주소공간을 공유한다.**

**![image](https://user-images.githubusercontent.com/34773827/60247174-19e28680-98fb-11e9-9fd7-17a425d7eabc.png)**

32비트 윈도우 운영체제에서 응용프로그램에는 4GB의 가상주소공간이 주어진다.

> 이중 2GB까지는 응용프로그램이 사용할 수 있는 공간이며 나머지 2GB는 커널의 가상주소 공간이다.
>
> 응용프로그램은 상위 2GB 주소로의 직접적인 접근이 불가능 하며,<br> 시스템 API를 호출해서 간접적으로 커널 코드를 수행한다.
>
> ![image](https://user-images.githubusercontent.com/34773827/60247568-de948780-98fb-11e9-8aa0-e7f44a7c821e.png)
>
> 그림과 같이 프로세스 A와 프로세스 B는 독립적인 4GB 주소공간을 가진다.
>
> > 커널은 하나만 존재하므로 여러 프로세스에서 커널을 공유한다.



## 페이징

보호 모드로의 전환에 의해 32bit 주소 접근이 가능하더라도, <br>실제 물리 메모리가 4GB 이하라면 4GB 주소 전체에 접근하는 것은 불가능하다.

> 우리는 QEMU 설정에서 메모리 크기를 128MB로 정했는데,<br>이것으로 보면 프로세스에 4GB 주소공간을 할당하는 것이 불가능한 것 처럼 보인다.

하지만, 32bit 운영체제는 분명 프로세스에 4GB 주소공간을 할당한다.

이걸 가능하게 하기 위해서는 **페이징 기능**을 사용해서 **가상주소**를 사용해야한다.

> 페이징이란 메모리 공간을 페이지 단위로 나눠서 사용하는 방법을 의미한다.
>
> 예를들어 한 프로세스가 4GB의 주소 공간을 사용하고 페이지 크기가 4KB라면 페이지는<br>1024 X 1024개 존재한다. 4KB = (4 * 2^20 = 4(GB)* 2^10(1024) * 2^10(1024))
>
> 이 1024 X 1024개의 페이지 정보를 관리할 수 있다면 4GB의 가상주소를 다룰 수 있다.



## 주소 변환 과정

![image](https://user-images.githubusercontent.com/34773827/60248415-8f4f5680-98fd-11e9-98f3-c132f49247dc.png)

**GDT 세그먼트 디스크립터 오른쪽 화살표는 세그먼트 디스크립터가 아니라 기준주소(BASE ADDRESS)**

프로세스가 가상주소를 사용한다고 가정하고 가상주소에 접근하는 과정을 살펴보자.

- WIN32에서 프로세스를 실행하면 4GB의 주소 공간을 가지게 된다.

  - 이 프로세스는 자신의 코드와 데이터가 메모리에 적재될 때 물리 메모리의 어느 곳에 적재 되는지에 대해서는 알 필요가 없다.

  - 메모리에 로드 될 때 운영체제가 해당 프로세스를 위한 페이지 디렉토리와 페이지 테이블을 만들어서 물리 메모리와 매핑한다. 

    >  이 과정에서 세그멘테이션과 페이징 과정을 거친다.

> 그림에서 세그멘테이션 과정은 GDT에서 언급했던 것 처럼<BR>윈도우 운영체제에서는 논리주소(가상주소)가 Offset과 같아 Offset이 그대로 선형주소가 되기 때문에<br>세그멘테이션 기능이 유명무실하다.
>
> 페이징을 위해서는 이 선형 주소 값을 이용하면 된다.



## 세그멘테이션

세그멘테이션은 **프로세서의 가상주소를 선형주소로 변환하는 과정**을 의미한다.

> 하지만 윈도우 운영체제에서는 이 세그멘테이션이 의미가 없는데,
>
> 유저 프로세스에 대한 GDT의 디스크립터는 베이스 주소가 0이기 때문에 가상주소(논리주소) 자체가 바로 선형주소가 되기 때문이다.
>
> 즉, 프로세스의 가상주소 = 선형주소이므로 세그멘테이션에 대해서는 크게 신경 쓸 필요가 없다.
>
> 우리가 제작하는 운영체제도 GDT디스크립터의 베이스 주소를 0으로 사용한다.

> 쉽게 예를 들면, 코드상에서 '0x12345678번지의 4바이트 값을 읽어라'는 명령을 실행한다고 할때,<br>이 값이 가상주소이자 Offset이 되며, 선형주소이기도 하다.(base + offset)



## 페이징

![image](https://user-images.githubusercontent.com/34773827/60249997-d12dcc00-9900-11e9-97df-d209ee9e5690.png)

페이지 디렉토리 엔트리는 4바이트 크기를 가지며, 여러가지 플래그와 페이지 테이블의 위치 정보를 가지고 있다.



<선형주소를 물리주소로 변환하기>

![image](https://user-images.githubusercontent.com/34773827/60250343-692bb580-9901-11e9-9d65-fad27865e6b5.png)

![image](https://user-images.githubusercontent.com/34773827/60251022-b9efde00-9902-11e9-9f82-206a2edc17c6.png)

위 두 그림에서 페이지 기준 주소값이 실제 물리주소를 나타내는데,<br>정확히 이 값에 **4KB**를 곱한 값이 우리가 원하는 물리주소이다.

이 PTE는 페이지 테이블에서 PTE 인덱스 위치에 해당하는 PTE를 얻어내면 된다.

여기에 선형주소에서 얻은 Offset 값을 더하면 최종 물리주소를 얻을 수 있다.



#### 0xC0000000(2GB)를 가지고 실제 물리 주소를 찾아가는 과정은 다음과 같다.

가상주소 0xC0000000은 논리 주소이자 Offset이며 선형주소에 해당한다.

선형주소를 통해 다음과 같은 세 가지 값을 얻어낼 수 있는데,

- 페이지 디렉토리 엔트리 인덱스

- 페이지 테이블 엔트리 인덱스

- Offset

그림에서 처럼 선형주소는 [페이지 디렉토리 엔트리 인덱스 : 페이지 테이블 엔트리 인덱스 : Offset]<br>이렇게 세 가지 값으로 구성되며 이진수로 표현한다면,<br>11000 00000 : 00000 00000 : 00000 00000 00 형태가 된다.

| 요소      | 의미                                      |
| --------- | ----------------------------------------- |
| PDE Index | 페이지 디렉토리부터 인덱스 768 PDE를 의미 |
| PT Index  | 페이지 테이블에서 0번째 PTE를 의미        |
| Offset    | Offset은 0이다.                           |

페이지 디렉토리는 **PDBR 레지스터**가 가리키고 있으니 PDT를 찾아가는 것은 문제가 되지 않는다.

PDT에는 4바이트 PDE가 1024개 존재하는데 0xC0000000의 경우에는 인덱스 768 PDE를 가리키고 있으므로, 인덱스 768 PDE의 정보를 취한다.

PDE에서는 페이지 테이블의 주소를 얻을 수 있으므로 페이지 테이블에 접근할 수 있다.<BR>페이지 테이블 엔트리는 페이지 디렉토리 엔트리와 구조가 동일하며, 4바이트 크기이다. 



#### 다시 요약

- 가상주소는 선형주소로 변환된다. 가상주소와 선형주소는 동일하므로 우리가 만드는 OS에서 세그멘테이션은 의미가 없다.

- 선형주소는 PDE 인덱스, PTE 인덱스, Offset 세 가지 값으로 구성된다.

- PDBR(페이지 디렉토리 베이스 레지스터)를 통해 페이지 디렉토리에 접근할 수 있다. 이 값과 PDE 인덱스를 이용해서 페이지 디렉토리 엔트리를 얻어낸다.

- 페이지 디렉토리 엔트리는 하나의 페이지 테이블을 가리킨다.

- 페이지 테이블과 PTE 인덱스를 사용해서 페이지 테이블 엔트리(PTE)를 얻어낸다.

  > 페이지 테이블 엔트리(PTE)는 페이지를 기술하고 있으며 페이지 기준 주소 필드가 실제 물리주소를 가리킨다. 이 값에 4KB를 곱하고 선형주소에서 얻은 Offset 값을 더하면 가상주소가 접근하는 실제 물리 메모리 주소를 얻어낼 수 있다.

결국 페이징 기능을 활성화하면 프로세스는 특정 물리 메모리 주소에 접근하고 싶어도 접근할 수 없다.

> 프로세스마다 PDBR 레지스터 값이 다를 것이고(물론 커널에서는 동일하게 사용할 수 있다.)<BR>이 PDBR이 가리키는 페이지 시스템은 다른 프로세스와 메모리 충돌이 발생하지 않도록 적절히 물리 메모리를 매핑하고 있을 것이기 때문이다.
>
> 따라서 페이징을 활성화 하면 **특정 프로세스의 메모리 침범으로 인해 다른 프로세스가 망가지는 것을 막을 수 있다.**
>
> 즉, 문제가 있는 프로세스는 자신외에는 다른 프로세스에 영향을 미칠 수 없다.



## 정리

기억해야 할 내용은 다음과 같다.

- 가상주소는 세그멘테이션과 페이징 과정을 거쳐 실제 물리주소로 변환된다.
- WIN32와 우리가 만드는 OS에서는 세그멘테이션이 의미가 없으며 가상주소가 곧 선형주소가 된다.
- 선형주소는 PDE(페이지 디렉토리 엔트리),PTE(페이지 테이블 엔트리),Offset 값으로 나뉜다.(10,10,12bit)
- 선형주소 값을 통해 페이지 디렉토리, 페이지 테이블을 거쳐 물리메모리에 접근한다.

페이지 디렉토리 하나는 4GB 가상주소 전체를 다룰 수 있기 때문에 프로세스 하나당 페이지 디렉토리 하나면 충분하다.

![image](https://user-images.githubusercontent.com/34773827/60252816-e2c5a280-9905-11e9-921d-28bd7b18cf6f.png)

페이지 디렉토리 테이블에는 1024개의 PDE(Page Directory Entry)가 존재하고,

하나의 PDE는 페이지 테이블 하나를 가리키는데 페이지 테이블 하나는 1024개의 PTE(Page Table Entry)를 가진다.

PTE 하나는 물리 메모리 4KB를 표현하므로 페이지 디렉토리가 표현할 수 있는 메모리 범위는<BR>1024 X 1024 X 4KB = 4GB 가 될 수 있다.

그런데 이 4GB에 접근하기 위해 모든 페이지 테이블이 메모리에 생성된다면 굉장한 메모리 낭비가 된다.

> 페이지 테이블의 크기는 1024 X 4 = 4KB 이며 1024개를 생성한다면 4MB를 필요로 한다.
>
> 또한 이 값은 프로세스 하나당 필요로 하는 값이며 프로세스 생성수가 많아지면 메모리 사용량은 더 증가한다.

일반적으로는 프로세스가 4GB 전 공간에 접근한다 하더라도 실제 접근하는 주소는 한정되어 있기 때문에 모든 페이지 테이블을 생성하지 않고 몇 개만 생성한다.<BR>그리고 특정 주소에 접근 시 페이지 테이블이 존재하지 않으면 그 때 동적으로 페이지 테이블을 생성하는 형태를 취한다.

> 하나의 페이지 테이블이 4MB영역을 다룰 수 있으므로 프로세스 초반 실행 시에는 페이지 테이블 2 ~ 3개면 충분하다.

> 메모리에 사용할 수 있는 공간이 없어 페이지(프레임)을 할당할 수 없는 경우 기존에 사용되고 있는 페이지를 하드디스크에 옮겨서 저장하고 빈 공간을 만든 뒤, 요청한 프로세스에 할당하는 과정을 페이지 스왑이라고 한다.



## 중요!



![image](https://user-images.githubusercontent.com/34773827/60248415-8f4f5680-98fd-11e9-98f3-c132f49247dc.png)

![image](https://user-images.githubusercontent.com/34773827/60250343-692bb580-9901-11e9-9d65-fad27865e6b5.png)



