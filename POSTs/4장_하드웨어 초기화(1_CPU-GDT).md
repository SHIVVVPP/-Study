# 4장 하드웨어 초기화

![Image](https://i.imgur.com/oCtWyvK.png)

> 3장 '커널 로딩'은 OS에 종속되는 내용이 아니며 4장부터 본격적으로 커널 제작에 들어간다.

커널의 목표는 유저에게 서비스를 제공 하는 것이다.

> 컴퓨터 과학에서 **커널(*kernel*)**은 컴퓨터의 운영체제의 핵심이 되는 컴퓨터 프로그램의 하나로, <br>시스템의 모든 것을 완전히 통제하며, 운영 체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러 가지 서비스를 제공한다. [(위키 백과 - 커널)](https://ko.wikipedia.org/wiki/커널_(컴퓨팅))

현 단계에서는 유저에게 제공할 수 있는 서비스가 존재하지 않는다.

유저에게 하드 디스크를 읽거나 마우스 입력 등의 서비스를 제공하려면<br>해당 디바이스 장치를 인식할 수 있는 코드를 구현해야 하는데, <br>이를 위해서 **전체 하드웨어 시스템을 초기화 시킬 필요가 있다.**

초기화할 하드웨어 시스템 대상은 다음과 같다.

- CPU (Central Processing Unit)
- PIC (Programmable Interrupt Controller)
- 타이머
- FPU (Floating point unit)
- Interrupt Handler



<hr>

## CPU (Central Processing Unit)

하드웨어 초기화의 첫 번째 단계는 CPU를 다룰 수 있다록 환경 설정을 하는 것이다.

> CPU를 제어하기 위해서는 단순히 명령을 CPU를 보내는 것이 아닌 **GDT**와 **IDT**설정이 필요하다.<br>GDT와 IDT를 설정하기 앞서 현재까지 진행된 **메모리 레이아웃**을 살펴보자.



<hr>

### 메모리 레이아웃

GRUB은 우리가 제작한 OS 커널을 1MB 영역에 로드한다.<br>또한 GRUB은 보호모드를 활성화 시키는데, 보호모드에서는 32bit 주소 접근이 가능하므로 4GB 메모리 영역에 접근이 가능하다. 

현재까지 진행된 메모리 점유 상황은 다음과 같다.

![image](https://user-images.githubusercontent.com/34773827/59972775-2e0f4680-95d0-11e9-93b1-29047f33d43a.png)

1MB 바이트 영역( *0x00000000 ~ 0xFFFFFFFF* )은 이제는 사용되지 않는 영역이다. 

> 하지만 우리가 16bit 모드로 돌아가야 할 필요가 있다면 V86 모드를 사용해야 하는데 이 경우 이 영역을 사용하게 된다.
>
> **V86 모드** :<br>가상 8086모드라고도 불리며 32bit 환경에서 16bit 환경을 에뮬레이션 하기 위해 제공된다.

다만 GRUB이 이 1MB 영역을 어떻게 덮어씌웠는지는 알 수 없기 때문에 확인이 필요하다.

덮어 씌워진 1MB 영역의 레이아웃은 다음과 같다.

![image](https://user-images.githubusercontent.com/34773827/59972933-bbec3100-95d2-11e9-83a6-c5e285160c07.png)

> 일반적으로 1MB 이하 메모리는 위와 같은 메모리 형태를 가진다.<BR>16bit 모드를 GRUB의 도움으로 건너 뛰었기 때문에 굳이 알 필요는 없으나<BR>0x7C00 메모리 주소에 부트섹터가 로드된다는 내용은 변하지 않는 사항이다.

처음부터 운영체제를 개발한다면 보호 모드로 진입하기 전에 활용할 수 있는 공간은 1MB 밖에 되지 않는다.

> 위 그림과 같이 메모리 매핑이 되어 있는 상태에서 커널의 크기는 제한적일 수 밖에 없다.<br>*0x7E00 ~ 0x9FC00( 자유공간 638kb )* 영역에 커널을 로드하는 수밖에 없는데 대부분의 운영체제 프로젝트는 이 크기를 넘지 않지만 우리 OS의 최종 크기는 400kb 이상의 공간이라 공간이 부족할 수 있다.
>
> GRUB은 여러가지 작업을 통해서 보호모드 상태에서 커널을 로드해 주기 때문에 문제가 되지 않지만, 처음부터 운영체제를 개발할 때에는 문제가 되므로 주의해야 한다.
>
> 이 문제를 해결하기 위해 다음과 같은 방법을 사용한다.
>
> - 보호 모드로 진입한 1차 커널이 2차 커널을 1MB 이상의 영역에 로드
>
> GRUB을 사용하지 않고 운영체제 제작을 고려한다면 이 부분을 명심해야 한다.

1MB 영역에는 커널이 로드된다. 스택은 *0x4000*에 설정되었는데, 이 영역은 사용되지 않는 영역으로 임시 스택으로 사용한다. (그림에서 보면 *0x500 ~ 0x7c00*은 사용되지 않는 공간임을 알 수 있다.)

커널 영역 이후부터는 자유공간이다. 

> 이후 메모리 관리자를 생성하면 메모리 관리자가 이 자유공간을 관리해서 메모리를 할당하거나 해제해 준다.



<hr>

### GDT

GDT (*Global Descriptor Table*)는 CPU의 보호 모드 기능을 사용하기 위해 운영체제 개발자가 작성해야 하는 테이블이다.

> 일단 운영체제가 보호 모드에 진입하면 물리 메모리 주소에 직접 접근해서 데이터를 읽거나 쓰는 행위가 불가능 해진다.<BR>또한, 실행 코드도 메모리 주소를 직접 접근해서 가져오는 것이 아니라 GDT를 거쳐서 조건에 맞으면 가져와 실행하고 그렇지 않으면 예외를 일으킨다.( 컴퓨터가 멈출 수도 있다. )



ex) 리얼 모드에서 *0x12345* 메모리 주소에 FF 값을 직접 쓰는 작업

![image](https://user-images.githubusercontent.com/34773827/59973848-b77a4500-95df-11e9-85a8-6cd578b6228a.png)

> 리얼모드에서는 프로그램이 직접 메모리에 접근하는 것이 가능하기 때문에 잘못된 데이터가 쓰여지는 것을 막을 방법이 없다.

ex) 보호모드에서 메모리에 데이터를 쓰는 작업

![image](https://user-images.githubusercontent.com/34773827/59973913-6cacfd00-95e0-11e9-8c2f-e98d077ac756.png)

> 보호모드 에서는 프로그램이 메모리의 특정 번지에 쓰기 요청을 할 때 일단 쓰기 요청이 유효한지 검증한다.<br>이때 **GDT** 가 사용되는데 다음과 같은 부분을 검증할 수 있다.
>
> - 접근하려는 주소가 유효한 주소 범위 내에 있는지 확인
> - 현재 실행되는 스레드의 특권 레벨이 GDT에 기술된 특권 레벨과 같거나 높은지 확인
>
> 이런 검사를 머신에서 지원해 주므로, 우리가 개발한 운영체제는 안정적으로 동작할 수 있는 기반을 가질 수 있다.



### GDT의 구조

![image](https://user-images.githubusercontent.com/34773827/59974002-bb0ecb80-95e1-11e9-992b-01ccb903e7f9.png)

GDT는 이런 디스크립터를 여러 개 담고 있으며 디스크립터는 8Byte 구조체로 구성된다.

디스크립터의 필드 중 중요한 요소는 다음과 같다.

| 디스크립터 요소 | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| Base Address    | 세그먼트의 베이스 주소를 나타낸다. 4Byte로 구성된다.         |
| Segment Limit   | 세그먼트의 크기를 나타낸다. 총 20bit이다.                    |
| DPL             | 특권 레벨을 나타낸다.<br>해당 디스크립터를 이용하려는 스레드의 특권레벨이 이 DPL 값보다 낮으면<br>CPU는 예외를 발생시킨다. |

여기서 **DPL 세그먼트**는

![image](https://user-images.githubusercontent.com/34773827/59974088-c6162b80-95e2-11e9-902a-000ac0ccfc78.png)

> 특권 레벨은 다른 말로 **링 레벨** 이라고 부르며, **커널은 링 레벨이 0**이다. <br>만약 링 레벨이 3인 유저 애플리케잇현이 링 레벨 0인 커널 코드를 실행하려면 CPU는 예외를 발생시킨다.<BR>이때 이런 **특권 레벨을 나타내는 것이 DPL 필드**이다.
>
> (커널 영역의 디스크럽터는 권한이 0인 스레드만 접근 가능하도록 설정했기 때문이다.)



세그먼트란 쉽게 말해서 하나의 블록이라고 생각하면 된다.

![image](https://user-images.githubusercontent.com/34773827/59974146-7a17b680-95e3-11e9-9a70-ecac16639b29.png)

> 그림은 4GB 메모리 공간을 나타낸 것이다.
>
> 여기서 *0x10000000 ~ 0x20000000* 영역이 하나의 세그먼트라고 할 수 있는데,<br>이 세그먼트의 베이스 주소는 *0x10000000*이며<br> **Segment Limit**, 즉 크기는 0x10000000( *0x20000000 - 0x10000000* )이다.
>
> GDT 디스크립터는 이런 블록을 기술하는데 위에서 언급한 블록이 커널이 사용하는 공간이라고 하고,<br>해당 디스크립터에 대한 접근은 커널 스레드만 접근 가능 하다고 가정하면,<br>이런 세그먼트에 응용 애플리케이션이 접근하려고 하면 오류가 발생한다.<br>( 권한이 3인 유저모드에서 권한이 0인 커널의 영역에 접근하면 **일반 보호 오류**를 일으키기 때문이다. )
>
> 이런 개념으로 운영체제의 영역은 잘못된 접근으로부터 보호될 수 있다.



> ![image](https://user-images.githubusercontent.com/34773827/59974320-c237d880-95e5-11e9-8784-09d270aeedf4.png)
>
> 위의 그림에서 유저 프로세스는 자신에게 할당된 세그먼트 내의 메모리에만 접근해야 한다.<br>자신이 접근할 수 있는 세그먼트 외의 메모리에 접근하면 CPU는 바로 오류를 감지한다.
>
> 하지만, 위 그림은 4GB 메모리 공간을 일반 응용프로그램이나 운영체제가 공유하고 있기 때문에 여러 프로세스를 운영하기에는 부족하다.
>
> 보통 하나의 프로세스를 생성하면 그 프로세스는 **독립된 4GB 가상 주소를 가지는데** 이를 구현하기 위해서는 세그멘테이션 만으로는 부족하며 **페이징 기능**을 도입해야 한다.
>
> ![image](https://user-images.githubusercontent.com/34773827/59974309-a7fdfa80-95e5-11e9-910b-4a83dd45bf6a.png)
>
> > **페이징 (*paging*)**
> >
> > 컴퓨터가 메인 메모리에서 사용하기 위해 2차 기억장치로부터 데이터를 저장하고 검색하는 메모리 관리 기법. <br>즉, 가상기억장치를 모두 같은 크기의 블록으로 편성하여 운용하는 기법



### GDT 설정 관련 구조체

지금까지 GDT의 역할에 대해서 설명 했다면,<br>이제 코드상에서 CPU가 참조할 수 있도록 구현해보자.

먼저, GDT를 표현하는 구조체를 정의한다.

```C++
< 디스크립터 구조체 정의 >
/* GDT.h */
typedef struct tag_gdtDescriptor
{
    USHORT	segmentLimit;
    USHORT	baseLow;
    BYTE	baseMiddle;
    BYTE	flags;
    BYTE	grand;
    BYTE	baseHigh;
}gdtDescriptor;
```

> GDT 디스크립터의 구조체 크기는 8Byte이다.
>
> **baseLow**, **baseMiddle**, **baseHigh** 필드를 통해서 베이스 주소를 얻어내며,<br>세그먼트의 크기는 **segmentLimit** 2Byte 필드와 **grand** 필드의 4bit 를 통해서 얻어낼 수 있다.
>
> > 여기서 세그먼트의 크기는 20bit 로 기술 되는데, 만약 베이스 주소가 0이라고 가정한다면 20bit로는 4GB의 메모리 주소를 커버할 수 없다.
> >
> > 하지만, 세그먼트 크기의 단위는 4K이다.<br>4K는 12bit를 나타내므로 20bit의 크기를 12bit 왼쪽으로 쉬프트하면 32bit의 세그먼트 크기를 나타낼 수 있고 이 크기는 4GB를 표현할 수 있다.<br>( G 플래그 설정과 관련이 있다. )

이렇게 디스크립터의 나열, 즉 GDT를 만들었으면 GDT가 어디에 위치하는지 CPU에 알려주어야 한다.

GDTR 레지스터를 표현하는 구조체는 다음과 같이 정의한다.

```C++
< 6Byte GDTR 구조체 >
/* GDT.cpp */
typedef struct tag_gdtr
{
    USHORT	m_limit; 	// GDT 크기
    UINT	m_base		// GDT의 시작 주소
}gdtr;
```

>CPU는 GDTR 레지스터를 참조해서 GDT에 접근하므로 GDTR 레지스터에 적절한 값을 설정해야 한다.
>
>어셈블리 명령어 중 lgdt 명령어가 GDTR 레지스터에 값을 설정한다.



### GDT 설정

다음 코드는 GDT를 설정하고 GDTR 레지스터에 로드하는 초기화 함수이다.

```c++
< GDT 초기화 및 GDTR 레지스터에 GDT 로드 >
/*  GDT.cpp */
    
int GDTInitialize()
{
    // GDT 레지스터에 로드될 _gdtr의 값 초기화
    // _gdtr의 주소는 실제 물리주소에 해당한다.
    // 디스크립터의 수를 나타내는 MAX_DESCRIPTORS의 값은 5이다.
    // NULL 디스크립터, 커널 코드 디스크립터, 커널 데이터 디스크립터, 유저 코드 디스크립터
    // 유저 데이터 디스크립터 이렇게 총 5개이다.
    // 디스크립터당 8Byte 이므로 GDT의 크기는 총 40Byte이다.
    _gdtr.m_limit = ( sizeof (struct gdt_descriptor ) * MAX_DESCRIPTORS ) - 1;
    _gdtr.m_base = ( uint32_t ) & _gdt[0];
    
    // NULL 디스크립터의 설정
    gdt_set_descriptor(0,0,0,0,0);
    
    // 커널 코드 디스크립터의 설정
    gdt_set_descriptor(
    1, 0, 0xffffffff,
    I86_GDT_DESC_READWRITE | I86_GDT_DESC_EXEC_CODE | 
    I86_GDT_DESC_CODEDATA|I86_GDT_DESC_MEMORY,
    I86_GDT_GRAND_4K | I86_GDT_GRAND_32BIT | I86_GDT_GRAND_LIMITHI_MASK);
    
    // 커널 데이터 디스크립터의 설정
    gdt_set_descriptor( 
    2, 0, 0xffffffff,
    I86_GDT_DESC_READWRITE|I86_GDT_DESC_CODEDATA|I86_GDT_DESC_MEMORY,
    I86_GDT_GRAND_4K|I86_GDT_GRAND_32BIT|I86_GIDT_GRAND_LIMITHI_MASK);
    
    // 유저모드 코드 디스크립터의 설정
    gdt_set_descriptor(
    3,0,0xffffffff,
    I86_GDT_DESC_READWRITE|I86_GDT_DESC_EXEC_CODE|
    I86_GDT_DESC_CODEDATA|I86_GDT_DESC_MEMORY|I86_GDT_DESC_DPL,
    I86_GDT_GRAND_4K|I86_GDT_GRAND_32BIT|I86_GDT_GRAND_LIMITHI_MASK);
    
    // 유저모드 데이터 디스크립터의 설정
    gdt_set_descriptor(
    4,0,0xffffffff,
    I86_GDT_DESC_READWRITE|I86_GDT_DESC_CODEDATA|
    I86_GDT_DESC_MEMORY|I86_GDT_DESC_DPL,
    I86_GDT_GRAND_4K|I86_GDT_GRAND_32BIT|I86_GDT_GRAND_LIMITHI_MASK);
    
    // GDTR 레지스터에 GDT 로드
    gdt_install();
    
    return 0;
}
```

> 5개의 디스크립터는 다음과 같다.
>
> | 디스크립터 유형        | 내용                                                         |
> | ---------------------- | ------------------------------------------------------------ |
> | NULL 디스크립터        | 디스크립터 테이블 내의 첫 번째 디스크립터는 항상 NULL로 설정한다. |
> | 커널 코드 디스크립터   | 커널 코드 실행 시 접근 권한을 기술한 디스크립터              |
> | 커널 데이터 디스크립터 | 커널 데이터 영역에 데이터를 쓰거나 읽을 때 접근 권한을 기술한 디스크립터 |
> | 유저 코드 디스크립터   | 유저 코드 실행 시 접근 권한을 기술한 디스크립터              |
> | 유저 데이터 디스크립터 | 유저 데이터 영역에 접근할 시 접근 권한을 기술한 디스크립터   |
>
> GDT를 선언한 후 이 GDT를 가리키는 GDTR 구조체를 선언한다.<BR>그 후 GDTR 레지스터가 이 구조체를 참조할 수 있도록 어셈블리 명령어 lgdt를 실행한다.
>
> GDTR 레지스터에는 _gdtr 변수의 물리주소값이 들어간다.<br>페이징 기능이 활성화 되면 가상주소가 활성화 되어 물리주소와 가상주소가 달라질 수 있기 때문에 일반적으로 GDTR 레지스터 값 설정은 페이징 활성화 전에 설정된다.
>
> > 아이덴터티 매핑을 통해서 페이징 후에도 물리주소와 가상주소가 같다면 GDT 로드는 페이징 후에도 가능하다.

> 디스크립터를 선언할 때 다양한 플래그 값을 설정하는데,<br>그 플래그 값의 의미는 다음 표와 같다.
>
> | 디스크립터 플래그<br>(I86_GDT_DESC_~,<BR>8-15bit) | 의미                                                         |
> | ------------------------------------------------- | ------------------------------------------------------------ |
> | ACCESS(0000 0001)                                 | 액세스 비트로 어떤 스레드가 이 세그먼트에 접근했을 때,<br/>1로 설정된다.<br>한번 설정된 이후에는 클리어 되지 않는다. |
> | READWRITE(0000 0010)                              | 설정되었을 경우 디스크립터는 읽고 쓰기가 가능하다.           |
> | EXPANSION(0000 0100)                              | 확장 비트 설정                                               |
> | EXEC_CODE(0000 1000)                              | 기본은 데이터 세그먼트이며,<br>설정했을 경우 코드 세그먼트를 의미하게 된다. |
> | CODEDATA(0001 0000)                               | 시스템에 의해 정의된 세그먼트일 경우 0,<BR>코드 또는 데이터 세그먼트일 경우 1 |
> | DPL(0110 0000)                                    | 2bit 플래그, DPL 특권 레벨을 나타낸다.                       |
> | MEMORY(1000 0000)                                 | 해당 세그먼트는 물리 메모리에 올라와 있어 접근 가능함을 의미<BR>0일 경우 해당 세그먼트 디스크립터가 가리키는 메모리는<BR>접근할 수 없다. |
>
> | 디스크립터 플래그<br>(I86_GDT_GRAND_~,<br>16~32bit) | 의미                                                         |
> | --------------------------------------------------- | ------------------------------------------------------------ |
> | LIMITHI_MASK(0000 1111)                             | 이 4bit 값과 Segment Limit 값 16bit를 합쳐서 20bit를 나타낸다.<br>G비트가 설정되어 있으며 20bit로 4GB 주소공간 표현이 가능하다. |
> | OS(0001 0000)                                       | 세그먼트가 64bit 네이티브 코드를 포함하고 있는지를 의미하며,<br>이 비트가 설정되면 D/B 필드는 0으로 설정되어야 한다. |
> | 32BIT(0100 0000)                                    | 32bit 모드일 때 지정된다.                                    |
> | 4K(1000 0000)                                       | 이 플래그가 1이면 세그먼트 단위는 4K가 된다.                 |
>
> 많은 플래그가 있지만 디스크립터 설정은 거의 공통적이다.
>
>  
>
> 디스크립터는 모두 코드나 데이터 세그먼트이며(I86_GDT_DESC_CODEDATA)<BR>메모리상에 세그먼트가 존재하며(I86_GDT_DESC_MEMORY),<BR>세그먼트 크기는 20bit 이지만 4GB 주소 접근이 가능하며(I86_GDT_GRAND_4K,G 플래그 활성화),<BR>세그먼트는 32bit 코드를 담고 있다는 플래그(I86_GDT_GRAND_32BIT)는 공통 속성이다. <BR>코드 세그먼트일 경우에만 코드 수행이 가능하도록 I86_GDT_DESC_EXEC_CODE 플래그를 설정했다.
>
> 디스크립터 값을 설정하는 부분을 보면 <BR>**모든 디스크립터의 세그먼트 베이스 주소는 0, 세그먼트 크기는 4GB로 설정했다.**



### GDT를 통한 주소 변환

앞에서 구현한 GDT를 통해서 프로세스가 물리주소에 어떻게 접근하는지 살펴보자.

먼저 메모리에 설치된 GDT의 레이아웃은 다음과 같다.

![image](https://user-images.githubusercontent.com/34773827/59975316-0b8e2500-95f2-11e9-8cda-2d1489467fa1.png)

GDT를 통해 주소를 변환하는 과정을 세그멘테이션이라고 한다.

> 세그멘테이션 과정에서는 논리주소를 선형주소로 변환하는데<br>우리가 만드는 OS( 윈도우 운영체제에서도 ) 논리주소와 선형주소가 동일하다.

논리주소가 선형주소로 변형되는 과정은, 다음과 같다.

![image](https://user-images.githubusercontent.com/34773827/59975524-ae936e80-95f3-11e9-9c8c-563066467651.png)

> 세그먼트 셀렉터를 통해서 GDT로부터 세그먼트 디스크립터를 얻어내고<BR>여기서 얻은 베이스 주소와 가상주소(Offset)를 더해서 선형주소(Effective Address)를 얻어낸다.<br>이 세그먼트 셀렉터에는 CS 레지스터, DS 레지스터 등이 있다.<br>(이름에서 알 수 있듯이 각각 코드 세그먼트 레지스터, 데이터 세그먼트 레지스터를 의미한다.)
>
> 이러한 레지스터들은 리얼모드상에서는 물리메모리상의 주소와 관계가 있었는데,<br>보호 모드에서는 세그먼트 셀렉터의 개념으로 바뀐다. 정리하면,
>
> - 커널 코드를 실행할 때 CS 레지스터는 *0x08* 값을 지닌다.<br>CPU는 CS 값이 8임을 확인하고 GDT의 두 번째 디스크립터의 값을 통해서 베이스 주소를 얻는다.
> - 베이스 주소와 Offset을 더하여 선형주소(Effective Address)를 만들어 낸다.
>
> 이렇게 생성된 선형주소는 논리주소값(Offset)과 동일한데,<br>우리가 디스크립터에 베이스 주소를 0으로 설정했기 때문이다.
>
> 따라서, 우리의 OS에서는 세그멘테이션에 의한 주소변환 기능은 크게 의미가 없다.<br>( 윈도우 운영체제에서도 마찬가지이다. )



### 세그먼트 레지스터에 대한 부연설명



