# A20 게이트 적용

이전 장에서 시스템 컨트롤 포트와 BIOS 서비스를 사용하여 
A20 게이트를 활성화 하는 방법에 대해서 살펴 보았다.

이제 OS에 A20 게이트 활성화를 적용하여 정상적으로 동작하는지 확인하고,

메모리 부족으로 발생할 수 있는 문제를 피하기 위해 검사하는 기능을 추가해본다.

<hr>

## A20 게이트 활성화 코드 적용

시스템 컨트롤 포트와 BIOS 서비스를 사용하여 A20 게이트를 활성화 하는 방법 중,
두 가지 방법 모두 어느 한 가지 방법만 사용해도 A20 게이트를 활성화 할 수 있지만,
BIOS마다 구현의 차이가 있을 수 있으므로 두 가지 방법 모두 사용해보자

> 순서는 가장 믿을만한 BIOS 서비스를 실행하고,
> BIOS 서비스가 실패할 경우 시스템 컨트롤 포트를 사용하는 순으로 한다.

BIOS 서비스를 사용하려면 리얼 모드여야 하므로 A20 게이트 활성화 코드는
부트 로더 또는 보호 모드 커널 엔트리 포인트에 추가해야 한다.

> 의미상 보호 모드 커널과 관계가 있으므로 보호 모드 엔트리 포인트에 추가한다.

<hr>

< 01.Kernel32/Source/EntryPoint.s 수정 >

```assembly
[ORG 0x00]          ; 코드의 시작 어드레스를 0x00으로 설정
[BITS 16]           ; 이하의 코드는 16비트 코드로 설정

SECTION .text       ; text 섹션(세그먼트)을 정의

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   코드 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START:
    mov ax, 0x1000  ; 보호 모드 엔트리 포인트의 시작 어드레스(0x10000)를 
                    ; 세그먼트 레지스터 값으로 변환
    mov ds, ax      ; DS 세그먼트 레지스터에 설정
    mov es, ax      ; ES 세그먼트 레지스터에 설정
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; A20 게이트를 활성화
    ; BIOS를 이용한 전환이 실패했을 때 시스템 컨트롤 포트로 전환 시도
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; BIOS 서비스를 사용해서 A20 게이트를 활성화
    mov ax, 0x2401          ; A20 게이트 활성화 서비스 설정
    int 0x15                ; BIOS 인터럽트 서비스 호출

    jc .A20GATEERROR        ; A20 게이트 활성화가 성공했는지 확인
    jmp .A20GATESUCCESS

.A20GATEERROR:
    ; 에러 발생 시, 시스템 컨트롤 포트로 전환 시도
    in al, 0x92   ; 시스템 컨트롤 포트(0x92)에서 1 바이트를 읽어 AL 레지스터에 저장
    or al, 0x02   ; 읽은 값에 A20 게이트 비트(비트 1)를 1로 설정
    and al, 0xFE  ; 시스템 리셋 방지를 위해 0xFE와 AND 연산하여 비트 0를 0으로 설정
    out 0x92, al  ; 시스템 컨트롤 포트(0x92)에 변경된 값을 1 바이트 설정
    
.A20GATESUCCESS:
    cli             ; 인터럽트가 발생하지 못하도록 설정
    lgdt [ GDTR ]   ; GDTR 자료구조를 프로세서에 설정하여 GDT 테이블을 로드

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 보호모드로 진입
    ; Disable Paging, Disable Cache, Internal FPU, Disable Align Check, 
    ; Enable ProtectedMode
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov eax, 0x4000003B ; PG=0, CD=1, NW=0, AM=0, WP=0, NE=1, ET=1, TS=1, 
    					; EM=0, MP=1, PE=1
    mov cr0, eax        ; CR0 컨트롤 레지스터에 위에서 저장한 플래그를 설정하여 
                        ; 보호 모드로 전환

; 	커널 코드 세그먼트를 0x00을 기준으로 하는 것으로 교체하고 
;	EIP의 값을 0x00을 기준으로 재설정
    ; CS 세그먼트 셀렉터 : EIP
    jmp dword 0x08: ( PROTECTEDMODE - $$ + 0x10000 )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; 보호 모드로 진입
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[BITS 32]               ; 이하의 코드는 32비트 코드로 설정
PROTECTEDMODE:
...생략...
```

### TEST

![image](https://user-images.githubusercontent.com/34773827/60885095-ab51e100-a289-11e9-8147-69584f6a2ea8.png)

이제 1MB 이상의 메모리에 완벽하게 접근할 수 있게 되었다.
(4GB 메모리를 자유롭게 사용할 수 있다.)

앞으로 이 공간을 여러 구역으로 나누어

- 멀티 태스킹
- 파일 시스템
- 동적 메모리 관리
- 애플리케이션 메모리

등의 용도로 사용 할 수 있다.

하지만, 이 전에 먼저 사용 가능한 메모리의 총량을 검사하는 작업을 해야 한다.

