# 메모리 단편화와 버디 블록 알고리즘

## 외부 단편화

동적 메모리 할당과 관련해서 가장 간단한 알고리즘은<br>가용한 메모리 공간 전체를 풀 형태로 만든 뒤 순차적으로 할당하는 방법이다.

하지만 잦은 할당과 해제의 반복에 의해<br>위 방법은 **메모리가 충분히 남아 있음에도 메모리를 할당하지 못하는 상태를 일으킬 수 있다.**

<hr>

### 메모리가 충분히 남아있는데 할당하지 못하는 상황

![image](https://user-images.githubusercontent.com/34773827/61934440-430e3980-afc3-11e9-8a17-6a053967fbf7.png)

이처럼 **메모리가 작은 영역으로 조각난 상태를 메모리 단편화(*Memory Fragmentation*)** 이라고 한다.

그림과 같이 여유 공간이 연속적이지 않아 메모리를 할당 할 수 없는 상태를 특별히 외부 단편화라고도 한다.

<hr>

외부 단편화는 시스템에 심각한 영향을 미칠 수 있기 때문에 아주 중요한 요소이다.

외부단편화로 인해 메모리를 할당 받을 수 없어 작업이 지연되거나 수행되지 못할 수 있으며,<br>조각난 메모리를 합쳐 원하는 크기의 메모리를 만들려면 진행중인 작업을 모두 종료해야 하는 상황이 발생할 수도 있다.

<hr>

## 버디 블록 알고리즘의 원리와 내부 단편화

메모리 단편화 문제는 그 어떤 OS도 피해갈 수 없기에 많은 연구가 이루어졌다.

그 중에 우리는 **버디 블록 알고리즘(*Buddy Block Algorithm*)** 을 통해 해결한다.

버디 블록 알고리즘은 메모리 할당과 해제가 반복될 때마다 인접한 블록(Buddy Block) 그룹을 합하여<br>상위 블록으로 만들거나 상위 블록을 절반으로 나누어 하위 블록 그룹으로 분리한다.

버디 블록 알고리즘은 요청한 크기와 근접한 블록을 우선으로 검색하고,<br>메모리가 해제된 뒤에는 인접한 블록을 합하여 더 큰 블록으로 결합하기 때문에<br>단편화 문제를 효율적으로 처리할 수 있다.

버디 블록 알고리즘은 메모리를 할당하고 해제하는 속도가 빠르고, 외부 단편화에 강하지만,<br>알고리즘의 특성상 내부 단편화에 상대적으로 취약하다.

<hr>

### 버디 블록 알고리즘의 기본 흐름

1. 상위 메모리 블록은 1/2 크기의 하위 메모리 블록 2개로 분할될 수 있다.
2. 연속된 어드레스의 하위 메모리 블록 2개는 상위 메모리 블록 1개로 결합될 수 있다.
3. 메모리 할당을 요청 할 때 요청된 크기와 근접한 크기의 메모리 블록 검색
   1. 근접한 크기의 메모리 블록이 존재하지 않을 경우 상위 메모리 블록에서 할당
   2. 상위 메모리 블록은 하위 메모리 블록 2개로 구성되므로 블록 하나는 할당하고 나머지 하나는 하위 블록 리스트에 삽입
   3. 상위 블록에서도 찾을 수 없는 경우, 한 단계 더 위로 이동하여 상위 메모리의 블록 리스트에서 검색한다.
   4. 만족하는 블록을 찾을 때 까지 위 1,2,3을 반복한다.

4. 메모리 해제시 해제한 블록과 연속된 어드레스를 갖는 블록을 검색하여 결합한 후 상위 블록 리스트에 삽입
   1. 결합된 상위 블록 주변에 연속된 어드레스를 갖는 블록이 있으면 결합하여 다시 상위 블록 리스트에 삽입
   2. 더 이상 만족하는 블록이 없을 때 까지 위 1의 과정 반복

> 메모리 단편화가 발행하는 이유는 메모리 할당과 해제를 반복했을 때 메모리가 작은 덩어리로 조각나기 때문이다.
>
> 버디 블록 알고리즘은 메모리를 블록 단위로 나누고 블록을 최대한 큰 덩어리로 결합함으로써,<br>단편화 문제를 해결한다.
>
> 또한 메모리를 일정한 크기의 블록으로 나누고 메모리 할당 시에 가장 근접한 크기의 블록을 할당해<br>할당된 공간의 낭비를 줄이고 블록을 검색하는 시간을 줄였다.

<hr>

### 버디 블록 알고리즘 동작 방식

![image](https://user-images.githubusercontent.com/34773827/61936271-53281800-afc7-11e9-8cba-5b0ca6f2d18b.png)

만약 전체 메모리의 크기가 8KB이고 최소 블록이 1KB라면,<br>최초에 블록은 위 그림과 같이 8KB 블록 하나만 존재한다.

> 그림에서 색칠되어있는 블록은 실제로 존재하는 블록을 의미하며,<br>점선으로 표시된 블록은 블록을 결합하거나 분할했을 때 생성될 수 있는 블록을 나타낸다.

#### 1KB 메모리 할당 요청이 들어왔을 때의 처리 과정

![image](https://user-images.githubusercontent.com/34773827/61936557-f4af6980-afc7-11e9-8b19-b7e059fb739a.png)

할당 요청이 들어오면 먼저 1KB 블록 리스트에 블록이 존재하는지 확인한다.

하지만 1KB 블록 리스트는 모두 비어있으므로 2KB 블록 -> 4KB 블록 -> 8KB 블록 까지 차례로 검색한다.

초기에 8KB 블록이 하나 있었으므로 1KB 블록이 생성될 때 까지 분할하는 작업을 반복하고 할당해 준다.

#### 1KB 메모리 해제 요청이 들어왔을 때의 처리 과정

![image](https://user-images.githubusercontent.com/34773827/61936696-37714180-afc8-11e9-803d-88bce3f0dbf6.png)

<hr>

위 그림들을 보면 마치 메모리를 할당한 순서대로 반환해야 블록이 합쳐지는 것처럼 보이지만,<br>블록이 모두 반환되가만 한다면 순서는 중요하지 않다.

버디 블록 알고리즘은 메모리를 해제하는 시점에 항상 결합할 수 있는지 검사하므로,<br>할당된 순서대로 해제되지 않아도 블록을 결합할 수 있다.

#### 임의의 순서로 1KB 블록 2개와 2KB 블록 1개를 할당하고 해제하는 경우

![image](https://user-images.githubusercontent.com/34773827/61958218-e1b68c80-affb-11e9-9f02-79bbbf3ad680.png)

<hr>

### 버디 블록 알고리즘의 문제점

버디 블록 알고리즘은 블록의 크기가 최소 크기 블록의 2배, 4배, 8배 ... 2의n승 배로 고정되어 있다.

1KB, 2KB 처럼 블록 단위가 맞아 떨어지는 크기가 아닌 1.1KB나 4.3KB를 요청하면,<br>버디 블록 알고리즘은 해당 크기를 포함하는 가장 가까운 크기의 블록을 찾으므로 2KB와 8KB 블록을 할당한다.

![image](https://user-images.githubusercontent.com/34773827/61958576-8e910980-affc-11e9-8f28-98cecb0398b2.png)

이 문제가 심각한 이유는<br>할당을 요청한 블록의 크기가 크면 클수록 빈 영역이 커지기 때문이다.

> 1바이트 차이로 실제 요청한 메모리의 두 배를 할당 받을 수 있으며,<br>이러한 영역이 많아질수록 낭비되는 메모리가 늘어난다.

이와 같이 실제로 요청한 블록보다 큰 블록이 할당되어 낭비되는 영역이 생기는 것을<br>**내부 단편화(Internal Fragmentation)** 라고 한다.

<hr>

### 내부 단편화를 줄일 수 있는 방법

메모리를 요청하는 것은 결국 프로세스나 스레드와 같은 태스크이므로,<br>우리가 코드를 작성할 때 버디 블록 크기에 맞추어 할당 하면 해결된다.

또한 필요한 메모리를 풀 형태로 구성하여 최대한 버디 블록 단위로 할당 받은 뒤 나누어 사용하는 것도 좋은 해결책이 될 수 있다.

