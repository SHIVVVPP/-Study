

# 페이지 테이블 구성과 공간 할당

페이징 기능을 사용하려면,<br>메모리 영역의 정보를 담고 있는 페이지 테이블을 생성하여 프로세서에 설정해야 한다.

<hr>

## 64GB의 물리 메모리 관리를 위한 메모리 계산

우리는 2MB 크기의 페이지를 사용하여 최대 64GB의 물리 메모리를 매핑한다.<br>64GB의 메모리를 관리하려면 최소한 몇 개의 페이지 테이블이 필요할까?

<hr>

#### 페이지 디렉터리의 수

페이지 디렉터리는 8바이트 크기인 엔트리 512 개로 구성되며,<br>각 엔트리는 2MB 페이지에 대한 정보를 담고있다.

따라서, 페이지 디렉터리 하나로 관리할 수 이쓴 메모리 영역은 (2MB * 512개)로 1GB이며,<br>페이지 디렉터리 하나가 차지하는 메모리 크기는 (8바이트 * 512개)가 되어 4KB가 된다.

우리는 64GB 영역을 매핑해야 하므로,<br>필요한 페이지 디렉터리의 수는 64개이며 총 256KB(4KB * 64개)가 된다.

<hr>

#### 페이지 디렉터리 포인터 테이블의 수

페이지 디렉터리 포인터 테이블 역시 페이지 디렉터리와 마찬가지로 <br>8바이트 크기인 엔트리 512개로 구성된다.

페이지 디렉터리 포인터의 엔트리는 하위 레벨인 페이지 디렉터리에 대한 정보를 포함하며<br>페이지 디렉터리 64개를 관리하려면 엔트리가 총 64개 필요하다.

따라서 페이지 디렉터리 포인터 테이블 한 개로 관리할 수 있는 페이지 디렉터리 수는 512개이므로<br>1개의 페이지 디렉터리 포인터 테이블로 충분하다.

> 64GB를 매핑하기 위해 필요한 페이지 디렉터리 수는 64개이다.

페이지 디렉터리 포인터 테이블을 위해서는 총 4KB(4KB * 1개)의 메모리가 필요하다.

<hr>

#### 페이지 맵 레벨 4 테이블 (PML4 Table)의 수

PML4 Table도 다른 테이블처럼 8바이트 크기인 PML4 테이블 엔트리 512개로 구성된다.

각 엔트리는 하위 레벨인 페이지 디렉터리 포인터 테이블의 정보를 담고 있으며,<br>페이지 디렉터리 포인터 테이블 1개를 관리하려면 엔트리 1개만 있으면 된다.

PML4 테이블 한 개는 페이지 디렉터리 포인터 테이블을 최대 512개까지 관리 할 수 있으므로<br>1개의 PML4 Table로 충분하다.

> 64GB를 매핑하기 위해 필요한 페이지 디렉터리 포인터 테이블은 1개면 충분했다.

PML4 Table을 위해 필요한 메모리는 총 4KB(4KB * 1개)의 메모리가 필요하다.

<hr>

#### 총 테이블의 수

64GB 물리 메모리를 매핑하는데 필요한 테이블의 개수는 총 66개가 이며,<br>필요한 메모리는 총 264KB이다. ( 4KB * 66개 )

> 64개의 페이지 디렉터리 + 1개의 페이지 디렉터리 포인터 테이블 + 1개의 PML4 테이블

<hr>

> 만약 2MB 페이지를 사용하는 페이징에서 PML4 테이블 하나를 전부 매핑한다고 한다면
>
> 가장 하위 레벨인 페이지  디렉터리 한 개로 1GB를 매핑할 수 있으며,<br>그 상위인 페이지 디렉터리 포인터 테이블 하나는 최대 512개의 페이지 디렉터리에 대한<br>정보를 가질 수 있으므로, 페이지 디렉터리 포인터 테이블 하나는 512GB를 매핑할 수 있다.
> 
> 같은 원리로 최상위 레벨인 PML4 테이블 역시 최대 512개의 페이지 디렉터리 포인터 테이블에 대한 정보를 가질 수 있으므로, 최대 256TB를 매핑할 수 있다.

<hr>



## 페이지 테이블을 위한 공간 할당

264KB나 되는 영역을 OS 이미지나 IA-32e 모드 커널 어드레스 공간(0x200000 ~ 0x600000)에 두는 것은 좋은 방법이 아니므로 별도의 공간을 할당할 필요가 있다.

IA-32e 모드용 커널 이미지를 0x200000(2MB)에서 시작하는 이유는<br>0x100000(1MB) ~ 0x200000(2MB) 영역을 IA-32e 모드용 커널 자료구조 영역으로 사용하기 때문에,<br>이 공간의 가장 앞 부분에 페이지 테이블이 위치하기 때문이다.

페이지 테이블의 순서는 <br>최상위 레벨인 PML4 테이블 부터 페이지 디렉터리 포인터 테이블, 페이지 디렉터리의 순이며,<br>
0x100000(1MB) ~ 0x142000(1MB + 264KB)의 어드레스에 위치한다.

< 페이지 테이블이 있는 영역의 메모리 맵 >

![image](https://user-images.githubusercontent.com/34773827/60938494-1e516b00-a30f-11e9-931b-14116510e08d.png)

<hr>



## 공통 속성 필드 설정

PML4 테이블 엔트리, 페이지 디렉터리 포인터 테이블 엔트리, 페이지 디렉터리 엔트리는<br>**A, PCD PWT, U/S, R/W, P** 의 공통적인 속성 필드를 가지고 있다.

- **PCD 필드와 PWT 필드**

  캐시 정첵에는 Write-Through 방식과 Write-Back 방식이 있는데<br>두 가지 방법 중 Write-Back 방식이 효율이 더 좋다.
  
따라서 Write-Back 방식의 캐시를 사용하도록 PCD와 PWT 비트 값을 설정한다. (각 0, 0)
  
- **U/S 필드와 R/W 필드**

  이후 애플리케이션을 구현한 후 유저/커널 레벨의 구분이 생긴 뒤에 권한 설정을 할 예정이므로,<br>지금은 유저 레벨과 커널 레벨을 구분할 필요가 없다.
  
따라서 지금은 모든 페이지를 커널 레벨 영역으로 지정하고 읽기 쓰기가 가능하게 설정한다.(각 0, 1)
  
> 속성을 따로 부여하면 코드와 데이터를 페이지 단위(2MB)로 정렬해야 한다.
  
- **EXB, A, P, Avail 필드**

  우리 OS는 페이징의 기본 기능 외에 다른 기능은 사용하지 않는다.

  따라서 EXB 필드와 같이 해당 페이지 내에서 코드 실행을 막는 기능은 사용하지 않으므로 0으로 설정한다.

  그리고 코드 실행 도중에 특정 페이지에 접근 했는지 여부도 참조하지 않으므로 임의의 값(0)을  설정하며,<br>Avail 필드 역시 사용하지 않으므로 임의의 값(0)으로 설정한다.
  
P 필드는 해당 엔트리가 유효하다는 것을 나타내는 필드이므로 반드시 1로 설정하여<br>해당 엔트리에 접근하였을 때, 페이지 폴트 예외가 발생하지 않도록 한다.

<hr>



## 페이지 디렉터리 엔트리용 속성 필드 설정

페이지 디렉터리 엔트리는 위에서 설명한 공통 필드 외에 PAT, G, D 필드가 더 있다.

- **PAT, G, D 필드**

  우리 OS는 페이지의 기본 기능 외에 다른 기능은 거의 사용하지 않는다.<br>따라서 PAT 처럼 페이지 별로 특수한 옵션을 지정하는 필드는 사용하지 않으므로 0으로 설정한다.
  
또한, 태스크 별로 페이지 매핑을 따로 구성하지 않으므로 페이지 테이블이 고정되어 있으니,<br>페이지 테이블 교체와 관련된 G 필드 역시 0으로 설정한다.
  
  마지막으로 D 필드는 A 필드와 마찬가지로 우리 OS에서 참조하지 않으니 0으로 설정한다.

<hr>



이것으로 우리 OS를 실행하는 데 필요한 엔트리의 속성 값을 알아보았고,<br>다음절 부터 엔트리 속성 값을 바탕으로 실제 0x100000 영역에 페이지 테이블을 생성하고<br>페이징 기능을 활성화 하는 방법에 대해 알아보겠다.