# 고수준 파일 시스템 함수 통합과 빌드

```c
////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
```



## 파일 시스템 파일 수정

#### 02.Kernel64/Source/FileSystem.h

```c
#ifndef __FILESYSTEM_H__
#define __FILESYSTEM_H__

#include "Types.h"
#include "Synchronization.h"
#include "HardDisk.h"

////////////////////////////////////////////////////////////////////////////////
//
// 매크로와 함수 포인터
//
////////////////////////////////////////////////////////////////////////////////
// MINT 파일 시스템 시그너처(Signature)
#define FILESYSTEM_SIGNATURE                0x7E38CF10
// 클러스터의 크기(섹터 수), 4Kbyte
#define FILESYSTEM_SECTORSPERCLUSTER        8
// 파일 클러스터의 마지막 표시
#define FILESYSTEM_LASTCLUSTER              0xFFFFFFFF
// 빈 클러스터 표시
#define FILESYSTEM_FREECLUSTER              0x00
// 루트 디렉터리에 있는 최대 디렉터리 엔트리의 수
#define FILESYSTEM_MAXDIRECTORYENTRYCOUNT   ( ( FILESYSTEM_SECTORSPERCLUSTER * 512 ) / \
        sizeof( DIRECTORYENTRY ) )
// 클러스터의 크기(바이트 수)
#define FILESYSTEM_CLUSTERSIZE              ( FILESYSTEM_SECTORSPERCLUSTER * 512 )

////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
// 핸들의 최대 개수, 최대 태스크 수의 3배로 생성
#define FILESYSTEM_HANDLE_MAXCOUNT          ( TASK_MAXCOUNT * 3 )
////////////////////////////////////////////////////////////////////////////////

// 파일 이름의 최대 길이
#define FILESYSTEM_MAXFILENAMELENGTH        24

////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
// 핸들의 타입을 정의
#define FILESYSTEM_TYPE_FREE                0
#define FILESYSTEM_TYPE_FILE                1
#define FILESYSTEM_TYPE_DIRECTORY           2

// SEEK 옵션 정의
#define FILESYSTEM_SEEK_SET                 0
#define FILESYSTEM_SEEK_CUR                 1
#define FILESYSTEM_SEEK_END                 2
////////////////////////////////////////////////////////////////////////////////


// 하드 디스크 제어에 관련된 함수 포인터 타입 정의
typedef BOOL (* fReadHDDInformation ) ( BOOL bPrimary, BOOL bMaster, 
        HDDINFORMATION* pstHDDInformation );
typedef int (* fReadHDDSector ) ( BOOL bPrimary, BOOL bMaster, DWORD dwLBA, 
        int iSectorCount, char* pcBuffer );
typedef int (* fWriteHDDSector ) ( BOOL bPrimary, BOOL bMaster, DWORD dwLBA, 
        int iSectorCount, char* pcBuffer );

////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
// MINT 파일 시스템 함수를 표준 입출력 함수 이름으로 재정의
#define fopen       kOpenFile
#define fread       kReadFile
#define fwrite      kWriteFile
#define fseek       kSeekFile
#define fclose      kCloseFile
#define remove      kRemoveFile
#define opendir     kOpenDirectory
#define readdir     kReadDirectory
#define rewinddir   kRewindDirectory
#define closedir    kCloseDirectory

// MINT 파일 시스템 매크로를 표준 입출력의 매크로를 재정의
#define SEEK_SET    FILESYSTEM_SEEK_SET
#define SEEK_CUR    FILESYSTEM_SEEK_CUR
#define SEEK_END    FILESYSTEM_SEEK_END

// MINT 파일 시스템 타입과 필드를 표준 입출력의 타입으로 재정의
#define size_t      DWORD       
#define dirent      kDirectoryEntryStruct
#define d_name      vcFileName
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 구조체
//
////////////////////////////////////////////////////////////////////////////////
// 1바이트로 정렬
#pragma pack( push, 1 )

// 파티션 자료구조
typedef struct kPartitionStruct
{
    // 부팅 가능 플래그. 0x80이면 부팅 가능을 나타내며 0x00은 부팅 불가
    BYTE bBootableFlag;
    // 파티션의 시작 어드레스. 현재는 거의 사용하지 않으며 아래의 LBA 어드레스를 대신 사용
    BYTE vbStartingCHSAddress[ 3 ];
    // 파티션 타입
    BYTE bPartitionType;
    // 파티션의 마지막 어드레스. 현재는 거의 사용 안 함
    BYTE vbEndingCHSAddress[ 3 ];
    // 파티션의 시작 어드레스. LBA 어드레스로 나타낸 값
    DWORD dwStartingLBAAddress;
    // 파티션에 포함된 섹터 수
    DWORD dwSizeInSector;
} PARTITION;

// MBR 자료구조
typedef struct kMBRStruct
{
    // 부트 로더 코드가 위치하는 영역
    BYTE vbBootCode[ 430 ];

    // 파일 시스템 시그너처, 0x7E38CF10
    DWORD dwSignature;
    // 예약된 영역의 섹터 수
    DWORD dwReservedSectorCount;
    // 클러스터 링크 테이블 영역의 섹터 수
    DWORD dwClusterLinkSectorCount;
    // 클러스터의 전체 개수
    DWORD dwTotalClusterCount;
    
    // 파티션 테이블
    PARTITION vstPartition[ 4 ];
    
    // 부트 로더 시그너처, 0x55, 0xAA
    BYTE vbBootLoaderSignature[ 2 ];
} MBR;


// 디렉터리 엔트리 자료구조
typedef struct kDirectoryEntryStruct
{
    // 파일 이름
    char vcFileName[ FILESYSTEM_MAXFILENAMELENGTH ];
    // 파일의 실제 크기
    DWORD dwFileSize;
    // 파일이 시작하는 클러스터 인덱스
    DWORD dwStartClusterIndex;
} DIRECTORYENTRY;

#pragma pack( pop )

////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
// 파일을 관리하는 파일 핸들 자료구조
typedef struct kFileHandleStruct
{
    // 파일이 존재하는 디렉터리 엔트리의 오프셋
    int iDirectoryEntryOffset;
    // 파일 크기
    DWORD dwFileSize;
    // 파일의 시작 클러스터 인덱스
    DWORD dwStartClusterIndex;
    // 현재 I/O가 수행중인 클러스터의 인덱스
    DWORD dwCurrentClusterIndex;
    // 현재 클러스터의 바로 이전 클러스터의 인덱스
    DWORD dwPreviousClusterIndex;
    // 파일 포인터의 현재 위치
    DWORD dwCurrentOffset;
} FILEHANDLE;

// 디렉터리를 관리하는 디렉터리 핸들 자료구조
typedef struct kDirectoryHandleStruct
{
    // 루트 디렉터리를 저장해둔 버퍼
    DIRECTORYENTRY* pstDirectoryBuffer;
    
    // 디렉터리 포인터의 현재 위치
    int iCurrentOffset;
} DIRECTORYHANDLE;

// 파일과 디렉터리에 대한 정보가 들어있는 자료구조
typedef struct kFileDirectoryHandleStruct
{
    // 자료구조의 타입 설정. 파일 핸들이나 디렉터리 핸들, 또는 빈 핸들 타입 지정 가능
    BYTE bType;

    // bType의 값에 따라 파일 또는 디렉터리로 사용
    union
    {
        // 파일 핸들
        FILEHANDLE stFileHandle;
        // 디렉터리 핸들
        DIRECTORYHANDLE stDirectoryHandle;
    };    
} FILE, DIR;
////////////////////////////////////////////////////////////////////////////////



// 파일 시스템을 관리하는 구조체
typedef struct kFileSystemManagerStruct
{
    // 파일 시스템이 정상적으로 인식되었는지 여부
    BOOL bMounted;
    
    // 각 영역의 섹터 수와 시작 LBA 어드레스
    DWORD dwReservedSectorCount;
    DWORD dwClusterLinkAreaStartAddress;
    DWORD dwClusterLinkAreaSize;
    DWORD dwDataAreaStartAddress;   
    // 데이터 영역의 클러스터의 총 개수
    DWORD dwTotalClusterCount;
    
    // 마지막으로 클러스터를 할당한 클러스터 링크 테이블의 섹터 오프셋을 저장
    DWORD dwLastAllocatedClusterLinkSectorOffset;
    
    // 파일 시스템 동기화 객체
    MUTEX stMutex;    

    ////////////////////////////////////////////////////////////////////////////////
    //
    // C 표준 입출력 함수 추가
    //
    ////////////////////////////////////////////////////////////////////////////////
    // 핸들 풀(Handle Pool)의 어드레스
    FILE* pstHandlePool;
    ////////////////////////////////////////////////////////////////////////////////
} FILESYSTEMMANAGER;


////////////////////////////////////////////////////////////////////////////////
//
// 함수
//
////////////////////////////////////////////////////////////////////////////////
BOOL kInitializeFileSystem( void );
BOOL kFormat( void );
BOOL kMount( void );
BOOL kGetHDDInformation( HDDINFORMATION* pstInformation);

////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
// 저수준 함수
static BOOL kReadClusterLinkTable( DWORD dwOffset, BYTE* pbBuffer );
static BOOL kWriteClusterLinkTable( DWORD dwOffset, BYTE* pbBuffer );
static BOOL kReadCluster( DWORD dwOffset, BYTE* pbBuffer );
static BOOL kWriteCluster( DWORD dwOffset, BYTE* pbBuffer );
static DWORD kFindFreeCluster( void );
static BOOL kSetClusterLinkData( DWORD dwClusterIndex, DWORD dwData );
static BOOL kGetClusterLinkData( DWORD dwClusterIndex, DWORD* pdwData );
static int kFindFreeDirectoryEntry( void );
static BOOL kSetDirectoryEntryData( int iIndex, DIRECTORYENTRY* pstEntry );
static BOOL kGetDirectoryEntryData( int iIndex, DIRECTORYENTRY* pstEntry );
static int kFindDirectoryEntry( const char* pcFileName, DIRECTORYENTRY* pstEntry );
void kGetFileSystemInformation( FILESYSTEMMANAGER* pstManager );
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
// 고수준 함수
FILE* kOpenFile( const char* pcFileName, const char* pcMode );
DWORD kReadFile( void* pvBuffer, DWORD dwSize, DWORD dwCount, FILE* pstFile );
DWORD kWriteFile( const void* pvBuffer, DWORD dwSize, DWORD dwCount, FILE* pstFile );
int kSeekFile( FILE* pstFile, int iOffset, int iOrigin );
int kCloseFile( FILE* pstFile );
int kRemoveFile( const char* pcFileName );
DIR* kOpenDirectory( const char* pcDirectoryName );
struct kDirectoryEntryStruct* kReadDirectory( DIR* pstDirectory );
void kRewindDirectory( DIR* pstDirectory );
int kCloseDirectory( DIR* pstDirectory );
BOOL kWriteZero( FILE* pstFile, DWORD dwCount );
BOOL kIsFileOpened( const DIRECTORYENTRY* pstEntry );

static void* kAllocateFileDirectoryHandle( void );
static void kFreeFileDirectoryHandle( FILE* pstFile );
static BOOL kCreateFile( const char* pcFileName, DIRECTORYENTRY* pstEntry, 
        int* piDirectoryEntryIndex );
static BOOL kFreeClusterUntilEnd( DWORD dwClusterIndex );
static BOOL kUpdateDirectoryEntry( FILEHANDLE* pstFileHandle );
////////////////////////////////////////////////////////////////////////////////

#endif /*__FILESYSTEM_H__*/

```

#### 02.Kernel64/Source/FileSystem.c

```c
#include "FileSystem.h"
#include "HardDisk.h"
#include "DynamicMemory.h"
////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
#include "Task.h"
#include "Utility.h"
////////////////////////////////////////////////////////////////////////////////

// 파일 시스템 자료구조
static FILESYSTEMMANAGER   gs_stFileSystemManager;
// 파일 시스템 임시 버퍼
static BYTE gs_vbTempBuffer[ FILESYSTEM_SECTORSPERCLUSTER * 512 ];

// 하드 디스크 제어에 관련된 함수 포인터 선언
fReadHDDInformation gs_pfReadHDDInformation = NULL;
fReadHDDSector gs_pfReadHDDSector = NULL;
fWriteHDDSector gs_pfWriteHDDSector = NULL;

/**
 *  파일 시스템을 초기화
 */
BOOL kInitializeFileSystem( void )
{
    // 자료구조 초기화와 동기화 객체 초기화
    kMemSet( &gs_stFileSystemManager, 0, sizeof( gs_stFileSystemManager ) );
    kInitializeMutex( &( gs_stFileSystemManager.stMutex ) );
    
    // 하드 디스크를 초기화
    if( kInitializeHDD() == TRUE )
    {
        // 초기화가 성공하면 함수 포인터를 하드 디스크용 함수로 설정
        gs_pfReadHDDInformation = kReadHDDInformation;
        gs_pfReadHDDSector = kReadHDDSector;
        gs_pfWriteHDDSector = kWriteHDDSector;
    }
    else
    {
        return FALSE;
    }
    
    // 파일 시스템 연결
    if( kMount() == FALSE )
    {
        return FALSE;
    }
    
////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
    // 핸들을 위한 공간을 할당
    gs_stFileSystemManager.pstHandlePool = ( FILE* ) kAllocateMemory( 
        FILESYSTEM_HANDLE_MAXCOUNT * sizeof( FILE ) );
    
    // 메모리 할당이 실패하면 하드 디스크가 인식되지 않은 것으로 설정
    if( gs_stFileSystemManager.pstHandlePool == NULL )
    {
        gs_stFileSystemManager.bMounted = FALSE;
        return FALSE;
    }
    
    // 핸들 풀을 모두 0으로 설정하여 초기화
    kMemSet( gs_stFileSystemManager.pstHandlePool, 0, 
            FILESYSTEM_HANDLE_MAXCOUNT * sizeof( FILE ) );   
////////////////////////////////////////////////////////////////////////////////
    return TRUE;
}

//==============================================================================
//  저수준 함수(Low Level Function)
//==============================================================================
/**
 *  하드 디스크의 MBR을 읽어서 MINT 파일 시스템인지 확인
 *      MINT 파일 시스템이라면 파일 시스템에 관련된 각종 정보를 읽어서
 *      자료구조에 삽입
 */
BOOL kMount( void )
{
    MBR* pstMBR;
    
    // 동기화 처리
    kLock( &( gs_stFileSystemManager.stMutex ) );

    // MBR을 읽음
    if( gs_pfReadHDDSector( TRUE, TRUE, 0, 1, gs_vbTempBuffer ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }
    
    // 시그너처를 확인하여 같다면 자료구조에 각 영역에 대한 정보 삽입
    pstMBR = ( MBR* ) gs_vbTempBuffer;
    if( pstMBR->dwSignature != FILESYSTEM_SIGNATURE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }
    
    // 파일 시스템 인식 성공
    gs_stFileSystemManager.bMounted = TRUE;
    
    // 각 영역의 시작 LBA 어드레스와 섹터 수를 계산
    gs_stFileSystemManager.dwReservedSectorCount = pstMBR->dwReservedSectorCount;
    gs_stFileSystemManager.dwClusterLinkAreaStartAddress =
        pstMBR->dwReservedSectorCount + 1;
    gs_stFileSystemManager.dwClusterLinkAreaSize = pstMBR->dwClusterLinkSectorCount;
    gs_stFileSystemManager.dwDataAreaStartAddress = 
        pstMBR->dwReservedSectorCount + pstMBR->dwClusterLinkSectorCount + 1;
    gs_stFileSystemManager.dwTotalClusterCount = pstMBR->dwTotalClusterCount;

    // 동기화 처리
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return TRUE;
}

/**
 *  하드 디스크에 파일 시스템을 생성
 */
BOOL kFormat( void )
{
    HDDINFORMATION* pstHDD;
    MBR* pstMBR;
    DWORD dwTotalSectorCount, dwRemainSectorCount;
    DWORD dwMaxClusterCount, dwClsuterCount;
    DWORD dwClusterLinkSectorCount;
    DWORD i;
    
    // 동기화 처리
    kLock( &( gs_stFileSystemManager.stMutex ) );

    //==========================================================================
    //  하드 디스크 정보를 읽어서 메타 영역의 크기와 클러스터의 개수를 계산
    //==========================================================================
    // 하드 디스크의 정보를 얻어서 하드 디스크의 총 섹터 수를 구함
    pstHDD = ( HDDINFORMATION* ) gs_vbTempBuffer;
    if( gs_pfReadHDDInformation( TRUE, TRUE, pstHDD ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }    
    dwTotalSectorCount = pstHDD->dwTotalSectors;
    
    // 전체 섹터 수를 4Kbyte, 즉 클러스터 크기로 나누어 최대 클러스터 수를 계산
    dwMaxClusterCount = dwTotalSectorCount / FILESYSTEM_SECTORSPERCLUSTER;
    
    // 최대 클러스터의 수에 맞추어 클러스터 링크 테이블의 섹터 수를 계산
    // 링크 데이터는 4바이트이므로, 한 섹터에는 128개가 들어감. 따라서 총 개수를
    // 128로 나눈 후 올림하여 클러스터 링크의 섹터 수를 구함
    dwClusterLinkSectorCount = ( dwMaxClusterCount + 127 ) / 128;
    
    // 예약된 영역은 현재 사용하지 않으므로, 디스크 전체 영역에서 MBR 영역과 클러스터
    // 링크 테이블 영역의 크기를 뺀 나머지가 실제 데이터 영역이 됨
    // 해당 영역을 클러스터 크기로 나누어 실제 클러스터의 개수를 구함
    dwRemainSectorCount = dwTotalSectorCount - dwClusterLinkSectorCount - 1;
    dwClsuterCount = dwRemainSectorCount / FILESYSTEM_SECTORSPERCLUSTER;
    
    // 실제 사용 가능한 클러스터 수에 맞추어 다시 한번 계산
    dwClusterLinkSectorCount = ( dwClsuterCount + 127 ) / 128;

    //==========================================================================
    // 계산된 정보를 MBR에 덮어 쓰고, 루트 디렉터리 영역까지 모두 0으로 초기화하여
    // 파일 시스템을 생성
    //==========================================================================
    // MBR 영역 읽기
    if( gs_pfReadHDDSector( TRUE, TRUE, 0, 1, gs_vbTempBuffer ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }        
    
    // 파티션 정보와 파일 시스템 정보 설정    
    pstMBR = ( MBR* ) gs_vbTempBuffer;
    kMemSet( pstMBR->vstPartition, 0, sizeof( pstMBR->vstPartition ) );
    pstMBR->dwSignature = FILESYSTEM_SIGNATURE;
    pstMBR->dwReservedSectorCount = 0;
    pstMBR->dwClusterLinkSectorCount = dwClusterLinkSectorCount;
    pstMBR->dwTotalClusterCount = dwClsuterCount;
    
    // MBR 영역에 1 섹터를 씀
    if( gs_pfWriteHDDSector( TRUE, TRUE, 0, 1, gs_vbTempBuffer ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }
    
    // MBR 이후부터 루트 디렉터리까지 모두 0으로 초기화
    kMemSet( gs_vbTempBuffer, 0, 512 );
    for( i = 0 ; i < ( dwClusterLinkSectorCount + FILESYSTEM_SECTORSPERCLUSTER );
         i++ )
    {
        // 루트 디렉터리(클러스터 0)는 이미 파일 시스템이 사용하고 있으므로,
        // 할당된 것으로 표시
        if( i == 0 )
        {
            ( ( DWORD* ) ( gs_vbTempBuffer ) )[ 0 ] = FILESYSTEM_LASTCLUSTER;
        }
        else
        {
            ( ( DWORD* ) ( gs_vbTempBuffer ) )[ 0 ] = FILESYSTEM_FREECLUSTER;
        }
        
        // 1 섹터씩 씀
        if( gs_pfWriteHDDSector( TRUE, TRUE, i + 1, 1, gs_vbTempBuffer ) == FALSE )
        {
            // 동기화 처리
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return FALSE;
        }
    }    
    
    // 동기화 처리
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return TRUE;
}

/**
 *  파일 시스템에 연결된 하드 디스크의 정보를 반환
 */
BOOL kGetHDDInformation( HDDINFORMATION* pstInformation)
{
    BOOL bResult;
    
    // 동기화 처리
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    bResult = gs_pfReadHDDInformation( TRUE, TRUE, pstInformation );
    
    // 동기화 처리
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    
    return bResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
// static 함수로

/**
 *  클러스터 링크 테이블 내의 오프셋에서 한 섹터를 읽음
 */
static BOOL kReadClusterLinkTable( DWORD dwOffset, BYTE* pbBuffer )
{
    // 클러스터 링크 테이블 영역의 시작 어드레스를 더함
    return gs_pfReadHDDSector( TRUE, TRUE, dwOffset + 
              gs_stFileSystemManager.dwClusterLinkAreaStartAddress, 1, pbBuffer );
}

/**
 *  클러스터 링크 테이블 내의 오프셋에 한 섹터를 씀
 */
static BOOL kWriteClusterLinkTable( DWORD dwOffset, BYTE* pbBuffer )
{
    // 클러스터 링크 테이블 영역의 시작 어드레스를 더함
    return gs_pfWriteHDDSector( TRUE, TRUE, dwOffset + 
               gs_stFileSystemManager.dwClusterLinkAreaStartAddress, 1, pbBuffer );
}

/**
 *  데이터 영역의 오프셋에서 한 클러스터를 읽음
 */
static BOOL kReadCluster( DWORD dwOffset, BYTE* pbBuffer )
{
    // 데이터 영역의 시작 어드레스를 더함
    return gs_pfReadHDDSector( TRUE, TRUE, ( dwOffset * FILESYSTEM_SECTORSPERCLUSTER ) + 
              gs_stFileSystemManager.dwDataAreaStartAddress, 
              FILESYSTEM_SECTORSPERCLUSTER, pbBuffer );
}

/**
 *  데이터 영역의 오프셋에 한 클러스터를 씀
 */
static BOOL kWriteCluster( DWORD dwOffset, BYTE* pbBuffer )
{
    // 데이터 영역의 시작 어드레스를 더함
    return gs_pfWriteHDDSector( TRUE, TRUE, ( dwOffset * FILESYSTEM_SECTORSPERCLUSTER ) + 
              gs_stFileSystemManager.dwDataAreaStartAddress, 
              FILESYSTEM_SECTORSPERCLUSTER, pbBuffer );
}

/**
 *  클러스터 링크 테이블 영역에서 빈 클러스터를 검색함
 */
static DWORD kFindFreeCluster( void )
{
    DWORD dwLinkCountInSector;
    DWORD dwLastSectorOffset, dwCurrentSectorOffset;
    DWORD i, j;
    
    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return FILESYSTEM_LASTCLUSTER;
    }
    
    // 마지막으로 클러스터를 할당한 클러스터 링크 테이블의 섹터 오프셋을 가져옴
    dwLastSectorOffset = gs_stFileSystemManager.dwLastAllocatedClusterLinkSectorOffset;

    // 마지막으로 할당한 위치부터 루프를 돌면서 빈 클러스터를 검색
    for( i = 0 ; i < gs_stFileSystemManager.dwClusterLinkAreaSize ; i++ )
    {
        // 클러스터 링크 테이블의 마지막 섹터이면 전체 섹터만큼 도는 것이 아니라
        // 남은 클러스터의 수만큼 루프를 돌아야 함
        if( ( dwLastSectorOffset + i ) == 
            ( gs_stFileSystemManager.dwClusterLinkAreaSize - 1 ) )
        {
            dwLinkCountInSector = gs_stFileSystemManager.dwTotalClusterCount % 128; 
        }
        else
        {
            dwLinkCountInSector = 128;
        }
        
        // 이번에 읽어야 할 클러스터 링크 테이블의 섹터 오프셋을 구해서 읽음
        dwCurrentSectorOffset = ( dwLastSectorOffset + i ) % 
            gs_stFileSystemManager.dwClusterLinkAreaSize;
        if( kReadClusterLinkTable( dwCurrentSectorOffset, gs_vbTempBuffer ) == FALSE )
        {
            return FILESYSTEM_LASTCLUSTER;
        }
        
        // 섹터 내에서 루프를 돌면서 빈 클러스터를 검색
        for( j = 0 ; j < dwLinkCountInSector ; j++ )
        {
            if( ( ( DWORD* ) gs_vbTempBuffer )[ j ] == FILESYSTEM_FREECLUSTER )
            {
                break;
            }
        }
            
        // 찾았다면 클러스터 인덱스를 반환
        if( j != dwLinkCountInSector )
        {
            // 마지막으로 클러스터를 할당한 클러스터 링크 내의 섹터 오프셋을 저장
            gs_stFileSystemManager.dwLastAllocatedClusterLinkSectorOffset = 
                dwCurrentSectorOffset;
            
            // 현재 클러스터 링크 테이블의 오프셋을 감안하여 클러스터 인덱스를 계산
            return ( dwCurrentSectorOffset * 128 ) + j;
        }
    }
    
    return FILESYSTEM_LASTCLUSTER;
}

/**
 *  클러스터 링크 테이블에 값을 설정
 */
static BOOL kSetClusterLinkData( DWORD dwClusterIndex, DWORD dwData )
{
    DWORD dwSectorOffset;
    
    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return FALSE;
    }
    
    // 한 섹터에 128개의 클러스터 링크가 들어가므로 128로 나누면 섹터 오프셋을 
    // 구할 수 있음
    dwSectorOffset = dwClusterIndex / 128;

    // 해당 섹터를 읽어서 링크 정보를 설정한 후, 다시 저장
    if( kReadClusterLinkTable( dwSectorOffset, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    
    ( ( DWORD* ) gs_vbTempBuffer )[ dwClusterIndex % 128 ] = dwData;

    if( kWriteClusterLinkTable( dwSectorOffset, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }

    return TRUE;
}

/**
 *  클러스터 링크 테이블의 값을 반환
 */
static BOOL kGetClusterLinkData( DWORD dwClusterIndex, DWORD* pdwData )
{
    DWORD dwSectorOffset;
    
    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return FALSE;
    }
    
    // 한 섹터에 128개의 클러스터 링크가 들어가므로 128로 나누면 섹터 오프셋을 
    // 구할 수 있음
    dwSectorOffset = dwClusterIndex / 128;
    
    if( dwSectorOffset > gs_stFileSystemManager.dwClusterLinkAreaSize )
    {
        return FALSE;
    }
    
    
    // 해당 섹터를 읽어서 링크 정보를 반환
    if( kReadClusterLinkTable( dwSectorOffset, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    

    *pdwData = ( ( DWORD* ) gs_vbTempBuffer )[ dwClusterIndex % 128 ];
    return TRUE;
}


/**
 *  루트 디렉터리에서 빈 디렉터리 엔트리를 반환
 */
static int kFindFreeDirectoryEntry( void )
{
    DIRECTORYENTRY* pstEntry;
    int i;

    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return -1;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return -1;
    }
    
    // 루트 디렉터리 안에서 루프를 돌면서 빈 엔트리, 즉 시작 클러스터 번호가 0인
    // 엔트리를 검색
    pstEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    for( i = 0 ; i < FILESYSTEM_MAXDIRECTORYENTRYCOUNT ; i++ )
    {
        if( pstEntry[ i ].dwStartClusterIndex == 0 )
        {
            return i;
        }
    }
    return -1;
}

/**
 *  루트 디렉터리의 해당 인덱스에 디렉터리 엔트리를 설정
 */
static BOOL kSetDirectoryEntryData( int iIndex, DIRECTORYENTRY* pstEntry )
{
    DIRECTORYENTRY* pstRootEntry;
    
    // 파일 시스템을 인식하지 못했거나 인덱스가 올바르지 않으면 실패
    if( ( gs_stFileSystemManager.bMounted == FALSE ) ||
        ( iIndex < 0 ) || ( iIndex >= FILESYSTEM_MAXDIRECTORYENTRYCOUNT ) )
    {
        return FALSE;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    
    // 루트 디렉터리에 있는 해당 데이터를 갱신
    pstRootEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    kMemCpy( pstRootEntry + iIndex, pstEntry, sizeof( DIRECTORYENTRY ) );

    // 루트 디렉터리에 씀
    if( kWriteCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    return TRUE;
}

/**
 *  루트 디렉터리의 해당 인덱스에 위치하는 디렉터리 엔트리를 반환
 */
static BOOL kGetDirectoryEntryData( int iIndex, DIRECTORYENTRY* pstEntry )
{
    DIRECTORYENTRY* pstRootEntry;
    
    // 파일 시스템을 인식하지 못했거나 인덱스가 올바르지 않으면 실패
    if( ( gs_stFileSystemManager.bMounted == FALSE ) ||
        ( iIndex < 0 ) || ( iIndex >= FILESYSTEM_MAXDIRECTORYENTRYCOUNT ) )
    {
        return FALSE;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    
    // 루트 디렉터리에 있는 해당 데이터를 갱신
    pstRootEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    kMemCpy( pstEntry, pstRootEntry + iIndex, sizeof( DIRECTORYENTRY ) );
    return TRUE;
}

/**
 *  루트 디렉터리에서 파일 이름이 일치하는 엔트리를 찾아서 인덱스를 반환
 */
static int kFindDirectoryEntry( const char* pcFileName, DIRECTORYENTRY* pstEntry )
{
    DIRECTORYENTRY* pstRootEntry;
    int i;
    int iLength;

    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return -1;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return -1;
    }
    
    iLength = kStrLen( pcFileName );
    // 루트 디렉터리 안에서 루프를 돌면서 파일 이름이 일치하는 엔트리를 반환
    pstRootEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    for( i = 0 ; i < FILESYSTEM_MAXDIRECTORYENTRYCOUNT ; i++ )
    {
        if( kMemCmp( pstRootEntry[ i ].vcFileName, pcFileName, iLength ) == 0 )
        {
            kMemCpy( pstEntry, pstRootEntry + i, sizeof( DIRECTORYENTRY ) );
            return i;
        }
    }
    return -1;
}
////////////////////////////////////////////////////////////////////////////////

/**
 *  파일 시스템의 정보를 반환
 */
void kGetFileSystemInformation( FILESYSTEMMANAGER* pstManager )
{
    kMemCpy( pstManager, &gs_stFileSystemManager, sizeof( gs_stFileSystemManager ) );
}

////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
//  고수준 함수(High Level Function)
//==============================================================================
/**
 *  비어있는 핸들을 할당
 */
static void* kAllocateFileDirectoryHandle( void )
{
    int i;
    FILE* pstFile;
    
    // 핸들 풀(Handle Pool)을 모두 검색하여 비어있는 핸들을 반환
    pstFile = gs_stFileSystemManager.pstHandlePool;
    for( i = 0 ; i < FILESYSTEM_HANDLE_MAXCOUNT ; i++ )
    {
        // 비어있다면 반환
        if( pstFile->bType == FILESYSTEM_TYPE_FREE )
        {
            pstFile->bType = FILESYSTEM_TYPE_FILE;
            return pstFile;
        }
        
        // 다음으로 이동
        pstFile++;
    }
    
    return NULL;
}

/**
 *  사용한 핸들을 반환
 */
static void kFreeFileDirectoryHandle( FILE* pstFile )
{
    // 전체 영역을 초기화
    kMemSet( pstFile, 0, sizeof( FILE ) );
    
    // 비어있는 타입으로 설정
    pstFile->bType = FILESYSTEM_TYPE_FREE;
}

/**
 *  파일을 생성
 */
static BOOL kCreateFile( const char* pcFileName, DIRECTORYENTRY* pstEntry, 
        int* piDirectoryEntryIndex )
{
    DWORD dwCluster;
    
    // 빈 클러스터를 찾아서 할당된 것으로 설정
    dwCluster = kFindFreeCluster();
    if( ( dwCluster == FILESYSTEM_LASTCLUSTER ) ||
        ( kSetClusterLinkData( dwCluster, FILESYSTEM_LASTCLUSTER ) == FALSE ) )
    {
        return FALSE;
    }

    // 빈 디렉터리 엔트리를 검색
    *piDirectoryEntryIndex = kFindFreeDirectoryEntry();
    if( *piDirectoryEntryIndex == -1 )
    {
        // 실패할 경우 할당 받은 클러스터를 반환해야 함
        kSetClusterLinkData( dwCluster, FILESYSTEM_FREECLUSTER );
        return FALSE;
    }
    
    // 디렉터리 엔트리를 설정
    kMemCpy( pstEntry->vcFileName, pcFileName, kStrLen( pcFileName ) + 1 );
    pstEntry->dwStartClusterIndex = dwCluster;
    pstEntry->dwFileSize = 0;
    
    // 디렉터리 엔트리를 등록
    if( kSetDirectoryEntryData( *piDirectoryEntryIndex, pstEntry ) == FALSE )
    {
        // 실패할 경우 할당 받은 클러스터를 반환해야 함
        kSetClusterLinkData( dwCluster, FILESYSTEM_FREECLUSTER );
        return FALSE;
    }
    return TRUE;
}

/**
 *  파라미터로 넘어온 클러스터부터 파일의 끝까지 연결된 클러스터를 모두 반환
 */
static BOOL kFreeClusterUntilEnd( DWORD dwClusterIndex )
{
    DWORD dwCurrentClusterIndex;
    DWORD dwNextClusterIndex;
    
    // 클러스터 인덱스를 초기화
    dwCurrentClusterIndex = dwClusterIndex;
    
    while( dwCurrentClusterIndex != FILESYSTEM_LASTCLUSTER )
    {
        // 다음 클러스터의 인덱스를 가져옴
        if( kGetClusterLinkData( dwCurrentClusterIndex, &dwNextClusterIndex )
                == FALSE )
        {
            return FALSE;
        }
        
        // 현재 클러스터를 빈 것으로 설정하여 해제
        if( kSetClusterLinkData( dwCurrentClusterIndex, FILESYSTEM_FREECLUSTER )
                == FALSE )
        {
            return FALSE;
        }
        
        // 현재 클러스터 인덱스를 다음 클러스터의 인덱스로 바꿈
        dwCurrentClusterIndex = dwNextClusterIndex;
    }
    
    return TRUE;
}

/**
 *  파일을 열거나 생성 
 */
FILE* kOpenFile( const char* pcFileName, const char* pcMode )
{
    DIRECTORYENTRY stEntry;
    int iDirectoryEntryOffset;
    int iFileNameLength;
    DWORD dwSecondCluster;
    FILE* pstFile;

    // 파일 이름 검사
    iFileNameLength = kStrLen( pcFileName );
    if( ( iFileNameLength > ( sizeof( stEntry.vcFileName ) - 1 ) ) || 
        ( iFileNameLength == 0 ) )
    {
        return NULL;
    }
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    //==========================================================================
    // 파일이 먼저 존재하는가 확인하고, 없다면 옵션을 보고 파일을 생성
    //==========================================================================
    iDirectoryEntryOffset = kFindDirectoryEntry( pcFileName, &stEntry );
    if( iDirectoryEntryOffset == -1 )
    {
        // 파일이 없다면 읽기(r, r+) 옵션은 실패
        if( pcMode[ 0 ] == 'r' )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
        
        // 나머지 옵션들은 파일을 생성
        if( kCreateFile( pcFileName, &stEntry, &iDirectoryEntryOffset ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
    }    
    //==========================================================================
    // 파일의 내용을 비워야 하는 옵션이면 파일에 연결된 클러스터를 모두 제거하고
    // 파일 크기를 0으로 설정
    //==========================================================================
    else if( pcMode[ 0 ] == 'w' )
    {
        // 시작 클러스터의 다음 클러스터를 찾음
        if( kGetClusterLinkData( stEntry.dwStartClusterIndex, &dwSecondCluster )
                == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
        
        // 시작 클러스터를 마지막 클러스터로 만듦
        if( kSetClusterLinkData( stEntry.dwStartClusterIndex, 
               FILESYSTEM_LASTCLUSTER ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
        
        // 다음 클러스터부터 마지막 클러스터까지 모두 해제
        if( kFreeClusterUntilEnd( dwSecondCluster ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
       
        // 파일의 내용이 모두 비워졌으므로, 크기를 0으로 설정
        stEntry.dwFileSize = 0;
        if( kSetDirectoryEntryData( iDirectoryEntryOffset, &stEntry ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
    }
    
    //==========================================================================
    // 파일 핸들을 할당 받아 데이터를 설정한 후 반환
    //==========================================================================
    // 파일 핸들을 할당 받아 데이터 설정
    pstFile = kAllocateFileDirectoryHandle();
    if( pstFile == NULL )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
    }
    
    // 파일 핸들에 파일 정보를 설정
    pstFile->bType = FILESYSTEM_TYPE_FILE;
    pstFile->stFileHandle.iDirectoryEntryOffset = iDirectoryEntryOffset;
    pstFile->stFileHandle.dwFileSize = stEntry.dwFileSize;
    pstFile->stFileHandle.dwStartClusterIndex = stEntry.dwStartClusterIndex;
    pstFile->stFileHandle.dwCurrentClusterIndex = stEntry.dwStartClusterIndex;
    pstFile->stFileHandle.dwPreviousClusterIndex = stEntry.dwStartClusterIndex;
    pstFile->stFileHandle.dwCurrentOffset = 0;
       
    // 만약 추가 옵션(a)이 설정되어 있으면, 파일의 끝으로 이동
    if( pcMode[ 0 ] == 'a' )
    {
        kSeekFile( pstFile, 0, FILESYSTEM_SEEK_END );
    }

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return pstFile;
}

/**
 *  파일을 읽어 버퍼로 복사
 */
DWORD kReadFile( void* pvBuffer, DWORD dwSize, DWORD dwCount, FILE* pstFile )
{
    DWORD dwTotalCount;
    DWORD dwReadCount;
    DWORD dwOffsetInCluster;
    DWORD dwCopySize;
    FILEHANDLE* pstFileHandle;
    DWORD dwNextClusterIndex;    

    // 핸들이 파일 타입이 아니면 실패
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return 0;
    }
    pstFileHandle = &( pstFile->stFileHandle );
    
    // 파일의 끝이거나 마지막 클러스터이면 종료
    if( ( pstFileHandle->dwCurrentOffset == pstFileHandle->dwFileSize ) ||
        ( pstFileHandle->dwCurrentClusterIndex == FILESYSTEM_LASTCLUSTER ) )
    {
        return 0;
    }

    // 파일 끝과 비교해서 실제로 읽을 수 있는 값을 계산
    dwTotalCount = MIN( dwSize * dwCount, pstFileHandle->dwFileSize - 
                        pstFileHandle->dwCurrentOffset );
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 계산된 값만큼 다 읽을 때까지 반복
    dwReadCount = 0;
    while( dwReadCount != dwTotalCount )
    {
        //======================================================================
        // 클러스터를 읽어서 버퍼에 복사
        //======================================================================
        // 현재 클러스터를 읽음
        if( kReadCluster( pstFileHandle->dwCurrentClusterIndex, gs_vbTempBuffer )
                == FALSE )
        {
            break;
        }

        // 클러스터 내에서 파일 포인터가 존재하는 오프셋을 계산
        dwOffsetInCluster = pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE;
        
        // 여러 클러스터에 걸쳐져 있다면 현재 클러스터에서 남은 만큼 읽고 다음 
        // 클러스터로 이동
        dwCopySize = MIN( FILESYSTEM_CLUSTERSIZE - dwOffsetInCluster, 
                          dwTotalCount - dwReadCount );
        kMemCpy( ( char* ) pvBuffer + dwReadCount, 
                gs_vbTempBuffer + dwOffsetInCluster, dwCopySize );

        // 읽은 바이트 수와 파일 포인터의 위치를 갱신
        dwReadCount += dwCopySize;
        pstFileHandle->dwCurrentOffset += dwCopySize;

        //======================================================================
        // 현재 클러스터를 끝까지 다 읽었으면 다음 클러스터로 이동
        //======================================================================
        if( ( pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE ) == 0 )
        {
            // 현재 클러스터의 링크 데이터를 찾아 다음 클러스터를 얻음
            if( kGetClusterLinkData( pstFileHandle->dwCurrentClusterIndex, 
                                     &dwNextClusterIndex ) == FALSE )
            {
                break;
            }
            
            // 클러스터 정보를 갱신
            pstFileHandle->dwPreviousClusterIndex = 
                pstFileHandle->dwCurrentClusterIndex;
            pstFileHandle->dwCurrentClusterIndex = dwNextClusterIndex;
        }
    }
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    
    // 읽은 레코드 수를 반환
    return ( dwReadCount / dwSize );
}

/**
 *  루트 디렉터리에서 디렉터리 엔트리 값을 갱신
 */
static BOOL kUpdateDirectoryEntry( FILEHANDLE* pstFileHandle )
{
    DIRECTORYENTRY stEntry;
    
    // 디렉터리 엔트리 검색
    if( ( pstFileHandle == NULL ) ||
        ( kGetDirectoryEntryData( pstFileHandle->iDirectoryEntryOffset, &stEntry)
            == FALSE ) )
    {
        return FALSE;
    }
    
    // 파일 크기와 시작 클러스터를 변경
    stEntry.dwFileSize = pstFileHandle->dwFileSize;
    stEntry.dwStartClusterIndex = pstFileHandle->dwStartClusterIndex;

    // 변경된 디렉터리 엔트리를 설정
    if( kSetDirectoryEntryData( pstFileHandle->iDirectoryEntryOffset, &stEntry )
            == FALSE )
    {
        return FALSE;
    }
    return TRUE;
}

/**
 *  버퍼의 데이터를 파일에 씀
 */
DWORD kWriteFile( const void* pvBuffer, DWORD dwSize, DWORD dwCount, FILE* pstFile )
{
    DWORD dwWriteCount;
    DWORD dwTotalCount;
    DWORD dwOffsetInCluster;
    DWORD dwCopySize;
    DWORD dwAllocatedClusterIndex;
    DWORD dwNextClusterIndex;
    FILEHANDLE* pstFileHandle;

    // 핸들이 파일 타입이 아니면 실패
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return 0;
    }
    pstFileHandle = &( pstFile->stFileHandle );

    // 총 바이트 수
    dwTotalCount = dwSize * dwCount;
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );

    // 다 쓸 때까지 반복
    dwWriteCount = 0;
    while( dwWriteCount != dwTotalCount )
    {
        //======================================================================
        // 현재 클러스터가 파일의 끝이면 클러스터를 할당하여 연결
        //======================================================================
        if( pstFileHandle->dwCurrentClusterIndex == FILESYSTEM_LASTCLUSTER )
        {
            // 빈 클러스터 검색
            dwAllocatedClusterIndex = kFindFreeCluster();
            if( dwAllocatedClusterIndex == FILESYSTEM_LASTCLUSTER )
            {
                break;
            }
            
            // 검색된 클러스터를 마지막 클러스터로 설정
            if( kSetClusterLinkData( dwAllocatedClusterIndex, FILESYSTEM_LASTCLUSTER )
                    == FALSE )
            {
                break;
            }
            
            // 파일의 마지막 클러스터에 할당된 클러스터를 연결
            if( kSetClusterLinkData( pstFileHandle->dwPreviousClusterIndex, 
                                     dwAllocatedClusterIndex ) == FALSE )
            {
                // 실패할 경우 할당된 클러스터를 해제
                kSetClusterLinkData( dwAllocatedClusterIndex, FILESYSTEM_FREECLUSTER );
                break;
            }
            
            // 현재 클러스터를 할당된 것으로 변경
            pstFileHandle->dwCurrentClusterIndex = dwAllocatedClusterIndex;
            
            // 새로 할당받았으니 임시 클러스터 버퍼를 0으로 채움
            kMemSet( gs_vbTempBuffer, 0, FILESYSTEM_LASTCLUSTER );
        }        
        //======================================================================
        // 한 클러스터를 채우지 못하면 클러스터를 읽어서 임시 클러스터 버퍼로 복사
        //======================================================================
        else if( ( ( pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE ) != 0 ) ||
                 ( ( dwTotalCount - dwWriteCount ) < FILESYSTEM_CLUSTERSIZE ) )
        {
            // 전체 클러스터를 덮어쓰는 경우가 아니면 부분만 덮어써야 하므로 
            // 현재 클러스터를 읽음
            if( kReadCluster( pstFileHandle->dwCurrentClusterIndex, 
                              gs_vbTempBuffer ) == FALSE )
            {
                break;
            }
        }

        // 클러스터 내에서 파일 포인터가 존재하는 오프셋을 계산
        dwOffsetInCluster = pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE;
        
        // 여러 클러스터에 걸쳐져 있다면 현재 클러스터에서 남은 만큼 쓰고 다음 
        // 클러스터로 이동
        dwCopySize = MIN( FILESYSTEM_CLUSTERSIZE - dwOffsetInCluster, 
                          dwTotalCount - dwWriteCount );
        kMemCpy( gs_vbTempBuffer + dwOffsetInCluster, ( char* ) pvBuffer + 
                 dwWriteCount, dwCopySize );
        
        // 임시 버퍼에 삽입된 값을 디스크에 씀
        if( kWriteCluster( pstFileHandle->dwCurrentClusterIndex, gs_vbTempBuffer ) 
                == FALSE )
        {
            break;
        }
        
        // 쓴 바이트 수와 파일 포인터의 위치를 갱신
        dwWriteCount += dwCopySize;
        pstFileHandle->dwCurrentOffset += dwCopySize;

        //======================================================================
        // 현재 클러스터의 끝까지 다 썼으면 다음 클러스터로 이동
        //======================================================================
        if( ( pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE ) == 0 )
        {
            // 현재 클러스터의 링크 데이터로 다음 클러스터를 얻음
            if( kGetClusterLinkData( pstFileHandle->dwCurrentClusterIndex, 
                                     &dwNextClusterIndex ) == FALSE )
            {
                break;
            }
            
            // 클러스터 정보를 갱신
            pstFileHandle->dwPreviousClusterIndex = 
                pstFileHandle->dwCurrentClusterIndex;
            pstFileHandle->dwCurrentClusterIndex = dwNextClusterIndex;
        }
    }

    //==========================================================================
    // 파일 크기가 변했다면 루트 디렉터리에 있는 디렉터리 엔트리 정보를 갱신
    //==========================================================================
    if( pstFileHandle->dwFileSize < pstFileHandle->dwCurrentOffset )
    {
        pstFileHandle->dwFileSize = pstFileHandle->dwCurrentOffset;
        kUpdateDirectoryEntry( pstFileHandle );
    }
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    
    // 쓴 레코드 수를 반환
    return ( dwWriteCount / dwSize );
}

/**
 *  파일을 Count만큼 0으로 채움
 */
BOOL kWriteZero( FILE* pstFile, DWORD dwCount )
{
    BYTE* pbBuffer;
    DWORD dwRemainCount;
    DWORD dwWriteCount;
    
    // 핸들이 NULL이면 실패
    if( pstFile == NULL )
    {
        return FALSE;
    }
    
    // 속도 향상을 위해 메모리를 할당 받아 클러스터 단위로 쓰기 수행
    // 메모리를 할당
    pbBuffer = ( BYTE* ) kAllocateMemory( FILESYSTEM_CLUSTERSIZE );
    if( pbBuffer == NULL )
    {
        return FALSE;
    }
    
    // 0으로 채움
    kMemSet( pbBuffer, 0, FILESYSTEM_CLUSTERSIZE );
    dwRemainCount = dwCount;
    
    // 클러스터 단위로 반복해서 쓰기 수행
    while( dwRemainCount != 0 )
    {
        dwWriteCount = MIN( dwRemainCount , FILESYSTEM_CLUSTERSIZE );
        if( kWriteFile( pbBuffer, 1, dwWriteCount, pstFile ) != dwWriteCount )
        {
            kFreeMemory( pbBuffer );
            return FALSE;
        }
        dwRemainCount -= dwWriteCount;
    }
    kFreeMemory( pbBuffer );
    return TRUE;
}

/**
 *  파일 포인터의 위치를 이동
 */
int kSeekFile( FILE* pstFile, int iOffset, int iOrigin )
{
    DWORD dwRealOffset;
    DWORD dwClusterOffsetToMove;
    DWORD dwCurrentClusterOffset;
    DWORD dwLastClusterOffset;
    DWORD dwMoveCount;
    DWORD i;
    DWORD dwStartClusterIndex;
    DWORD dwPreviousClusterIndex;
    DWORD dwCurrentClusterIndex;
    FILEHANDLE* pstFileHandle;

    // 핸들이 파일 타입이 아니면 나감
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return 0;
    }
    pstFileHandle = &( pstFile->stFileHandle );
    
    //==========================================================================
    // Origin과 Offset을 조합하여 파일 시작을 기준으로 파일 포인터를 옮겨야 할 위치를 
    // 계산
    //==========================================================================
    // 옵션에 따라서 실제 위치를 계산
    // 음수이면 파일의 시작 방향으로 이동하며 양수이면 파일의 끝 방향으로 이동
    switch( iOrigin )
    {
    // 파일의 시작을 기준으로 이동
    case FILESYSTEM_SEEK_SET:
        // 파일의 처음이므로 이동할 오프셋이 음수이면 0으로 설정
        if( iOffset <= 0 )
        {
            dwRealOffset = 0;
        }
        else
        {
            dwRealOffset = iOffset;
        }
        break;

    // 현재 위치를 기준으로 이동
    case FILESYSTEM_SEEK_CUR:
        // 이동할 오프셋이 음수이고 현재 파일 포인터의 값보다 크다면
        // 더 이상 갈 수 없으므로 파일의 처음으로 이동
        if( ( iOffset < 0 ) && 
            ( pstFileHandle->dwCurrentOffset <= ( DWORD ) -iOffset ) )
        {
            dwRealOffset = 0;
        }
        else
        {
            dwRealOffset = pstFileHandle->dwCurrentOffset + iOffset;
        }
        break;

    // 파일의 끝부분을 기준으로 이동
    case FILESYSTEM_SEEK_END:
        // 이동할 오프셋이 음수이고 현재 파일 포인터의 값보다 크다면 
        // 더 이상 갈 수 없으므로 파일의 처음으로 이동
        if( ( iOffset < 0 ) && 
            ( pstFileHandle->dwFileSize <= ( DWORD ) -iOffset ) )
        {
            dwRealOffset = 0;
        }
        else
        {
            dwRealOffset = pstFileHandle->dwFileSize + iOffset;
        }
        break;
    }

    //==========================================================================
    // 파일을 구성하는 클러스터의 개수와 현재 파일 포인터의 위치를 고려하여
    // 옮겨질 파일 포인터가 위치하는 클러스터까지 클러스터 링크를 탐색
    //==========================================================================
    // 파일의 마지막 클러스터의 오프셋
    dwLastClusterOffset = pstFileHandle->dwFileSize / FILESYSTEM_CLUSTERSIZE;
    // 파일 포인터가 옮겨질 위치의 클러스터 오프셋
    dwClusterOffsetToMove = dwRealOffset / FILESYSTEM_CLUSTERSIZE;
    // 현재 파일 포인터가 있는 클러스터의 오프셋
    dwCurrentClusterOffset = pstFileHandle->dwCurrentOffset / FILESYSTEM_CLUSTERSIZE;

    // 이동하는 클러스터의 위치가 파일의 마지막 클러스터의 오프셋을 넘어서면
    // 현재 클러스터에서 마지막까지 이동한 후, Write 함수를 이용해서 공백으로 나머지를
    // 채움
    if( dwLastClusterOffset < dwClusterOffsetToMove )
    {
        dwMoveCount = dwLastClusterOffset - dwCurrentClusterOffset;
        dwStartClusterIndex = pstFileHandle->dwCurrentClusterIndex;
    }
    // 이동하는 클러스터의 위치가 현재 클러스터와 같거나 다음에 위치해
    // 있다면 현재 클러스터를 기준으로 차이만큼만 이동하면 된다.
    else if( dwCurrentClusterOffset <= dwClusterOffsetToMove )
    {
        dwMoveCount = dwClusterOffsetToMove - dwCurrentClusterOffset;
        dwStartClusterIndex = pstFileHandle->dwCurrentClusterIndex;
    }
    // 이동하는 클러스터의 위치가 현재 클러스터 이전에 있다면, 첫 번째 클러스터부터
    // 이동하면서 검색
    else
    {
        dwMoveCount = dwClusterOffsetToMove;
        dwStartClusterIndex = pstFileHandle->dwStartClusterIndex;
    }

    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );

    // 클러스터를 이동
    dwCurrentClusterIndex = dwStartClusterIndex;
    for( i = 0 ; i < dwMoveCount ; i++ )
    {
        // 값을 보관
        dwPreviousClusterIndex = dwCurrentClusterIndex;
        
        // 다음 클러스터의 인덱스를 읽음
        if( kGetClusterLinkData( dwPreviousClusterIndex, &dwCurrentClusterIndex ) ==
            FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return -1;
        }
    }

    // 클러스터를 이동했으면 클러스터 정보를 갱신
    if( dwMoveCount > 0 )
    {
        pstFileHandle->dwPreviousClusterIndex = dwPreviousClusterIndex;
        pstFileHandle->dwCurrentClusterIndex = dwCurrentClusterIndex;
    }
    // 첫 번째 클러스터로 이동하는 경우는 핸들의 클러스터 값을 시작 클러스터로 설정
    else if( dwStartClusterIndex == pstFileHandle->dwStartClusterIndex )
    {
        pstFileHandle->dwPreviousClusterIndex = pstFileHandle->dwStartClusterIndex;
        pstFileHandle->dwCurrentClusterIndex = pstFileHandle->dwStartClusterIndex;
    }
    
    //==========================================================================
    // 파일 포인터를 갱신하고 파일 오프셋이 파일의 크기를 넘었다면 나머지 부분을
    // 0으로 채워서 파일의 크기를 늘림
    //==========================================================================
    // 실제 파일의 크기를 넘어서 파일 포인터가 이동했다면, 파일 끝에서부터 
    // 남은 크기만큼 0으로 채워줌
    if( dwLastClusterOffset < dwClusterOffsetToMove )
    {
        pstFileHandle->dwCurrentOffset = pstFileHandle->dwFileSize;
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );

        // 남은 크기만큼 0으로 채움
        if( kWriteZero( pstFile, dwRealOffset - pstFileHandle->dwFileSize )
                == FALSE )
        {
            return 0;
        }
    }

    pstFileHandle->dwCurrentOffset = dwRealOffset;

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );

    return 0;    
}

/**
 *  파일을 닫음
 */
int kCloseFile( FILE* pstFile )
{
    // 핸들 타입이 파일이 아니면 실패
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return -1;
    }
    
    // 핸들을 반환
    kFreeFileDirectoryHandle( pstFile );
    return 0;
}

/**
 *  핸들 풀을 검사하여 파일이 열려있는지를 확인
 */
BOOL kIsFileOpened( const DIRECTORYENTRY* pstEntry )
{
    int i;
    FILE* pstFile;
    
    // 핸들 풀의 시작 어드레스부터 끝까지 열린 파일만 검색
    pstFile = gs_stFileSystemManager.pstHandlePool;
    for( i = 0 ; i < FILESYSTEM_HANDLE_MAXCOUNT ; i++ )
    {
        // 파일 타입 중에서 시작 클러스터가 일치하면 반환
        if( ( pstFile[ i ].bType == FILESYSTEM_TYPE_FILE ) &&
            ( pstFile[ i ].stFileHandle.dwStartClusterIndex == 
              pstEntry->dwStartClusterIndex ) )
        {
            return TRUE;
        }
    }
    return FALSE;
}

/**
 *  파일을 삭제
 */
int kRemoveFile( const char* pcFileName )
{
    DIRECTORYENTRY stEntry;
    int iDirectoryEntryOffset;
    int iFileNameLength;

    // 파일 이름 검사
    iFileNameLength = kStrLen( pcFileName );
    if( ( iFileNameLength > ( sizeof( stEntry.vcFileName ) - 1 ) ) || 
        ( iFileNameLength == 0 ) )
    {
        return NULL;
    }
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 파일이 존재하는가 확인
    iDirectoryEntryOffset = kFindDirectoryEntry( pcFileName, &stEntry );
    if( iDirectoryEntryOffset == -1 ) 
    { 
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }
    
    // 다른 태스크에서 해당 파일을 열고 있는지 핸들 풀을 검색하여 확인
    // 파일이 열려 있으면 삭제할 수 없음
    if( kIsFileOpened( &stEntry ) == TRUE )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }
    
    // 파일을 구성하는 클러스터를 모두 해제
    if( kFreeClusterUntilEnd( stEntry.dwStartClusterIndex ) == FALSE )
    { 
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }

    // 디렉터리 엔트리를 빈 것으로 설정
    kMemSet( &stEntry, 0, sizeof( stEntry ) );
    if( kSetDirectoryEntryData( iDirectoryEntryOffset, &stEntry ) == FALSE )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return 0;
}

/**
 *  디렉터리를 엶
 */
DIR* kOpenDirectory( const char* pcDirectoryName )
{
    DIR* pstDirectory;
    DIRECTORYENTRY* pstDirectoryBuffer;
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 루트 디렉터리 밖에 없으므로 디렉터리 이름은 무시하고 핸들만 할당받아서 반환
    pstDirectory = kAllocateFileDirectoryHandle();
    if( pstDirectory == NULL )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
    }
    
    // 루트 디렉터리를 저장할 버퍼를 할당
    pstDirectoryBuffer = ( DIRECTORYENTRY* ) kAllocateMemory( FILESYSTEM_CLUSTERSIZE );
    if( pstDirectory == NULL )
    {
        // 실패하면 핸들을 반환해야 함
        kFreeFileDirectoryHandle( pstDirectory );
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
    }
    
    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, ( BYTE* ) pstDirectoryBuffer ) == FALSE )
    {
        // 실패하면 핸들과 메모리를 모두 반환해야 함
        kFreeFileDirectoryHandle( pstDirectory );
        kFreeMemory( pstDirectoryBuffer );
        
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
        
    }
    
    // 디렉터리 타입으로 설정하고 현재 디렉터리 엔트리의 오프셋을 초기화
    pstDirectory->bType = FILESYSTEM_TYPE_DIRECTORY;
    pstDirectory->stDirectoryHandle.iCurrentOffset = 0;
    pstDirectory->stDirectoryHandle.pstDirectoryBuffer = pstDirectoryBuffer;

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return pstDirectory;
}

/**
 *  디렉터리 엔트리를 반환하고 다음으로 이동
 */
struct kDirectoryEntryStruct* kReadDirectory( DIR* pstDirectory )
{
    DIRECTORYHANDLE* pstDirectoryHandle;
    DIRECTORYENTRY* pstEntry;
    
    // 핸들 타입이 디렉터리가 아니면 실패
    if( ( pstDirectory == NULL ) ||
        ( pstDirectory->bType != FILESYSTEM_TYPE_DIRECTORY ) )
    {
        return NULL;
    }
    pstDirectoryHandle = &( pstDirectory->stDirectoryHandle );
    
    // 오프셋의 범위가 클러스터에 존재하는 최댓값을 넘어서면 실패
    if( ( pstDirectoryHandle->iCurrentOffset < 0 ) ||
        ( pstDirectoryHandle->iCurrentOffset >= FILESYSTEM_MAXDIRECTORYENTRYCOUNT ) )
    {
        return NULL;
    }

    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 루트 디렉터리에 있는 최대 디렉터리 엔트리의 개수만큼 검색
    pstEntry = pstDirectoryHandle->pstDirectoryBuffer;
    while( pstDirectoryHandle->iCurrentOffset < FILESYSTEM_MAXDIRECTORYENTRYCOUNT )
    {
        // 파일이 존재하면 해당 디렉터리 엔트리를 반환
        if( pstEntry[ pstDirectoryHandle->iCurrentOffset ].dwStartClusterIndex
                != 0 )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return &( pstEntry[ pstDirectoryHandle->iCurrentOffset++ ] );
        }
        
        pstDirectoryHandle->iCurrentOffset++;
    }

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return NULL;
}

/**
 *  디렉터리 포인터를 디렉터리의 처음으로 이동
 */
void kRewindDirectory( DIR* pstDirectory )
{
    DIRECTORYHANDLE* pstDirectoryHandle;
    
    // 핸들 타입이 디렉터리가 아니면 실패
    if( ( pstDirectory == NULL ) ||
        ( pstDirectory->bType != FILESYSTEM_TYPE_DIRECTORY ) )
    {
        return ;
    }
    pstDirectoryHandle = &( pstDirectory->stDirectoryHandle );
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 디렉터리 엔트리의 포인터만 0으로 바꿔줌
    pstDirectoryHandle->iCurrentOffset = 0;
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
}


/**
 *  열린 디렉터리를 닫음
 */
int kCloseDirectory( DIR* pstDirectory )
{
    DIRECTORYHANDLE* pstDirectoryHandle;
    
    // 핸들 타입이 디렉터리가 아니면 실패
    if( ( pstDirectory == NULL ) ||
        ( pstDirectory->bType != FILESYSTEM_TYPE_DIRECTORY ) )
    {
        return -1;
    }
    pstDirectoryHandle = &( pstDirectory->stDirectoryHandle );

    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 루트 디렉터리의 버퍼를 해제하고 핸들을 반환
    kFreeMemory( pstDirectoryHandle->pstDirectoryBuffer );
    kFreeFileDirectoryHandle( pstDirectory );    
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
```

## 유틸리티 헤더 파일과 콘솔 셸 파일의 수정

#### 02.Kernel64/Source/Utility.h

```c
/**
 *  file    Utility.h
 *  date    2009/01/17
 *  author  kkamagui 
 *          Copyright(c)2008 All rights reserved by kkamagui
 *  brief   OS에서 사용할 유틸리티 함수에 관련된 파일
 */

#ifndef __UTILITY_H__
#define __UTILITY_H__

#include <stdarg.h>
#include "Types.h"

////////////////////////////////////////////////////////////////////////////////
//
//  매크로
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
#define MIN(x, y) (((x)<(y))?(x):(y))
#define MAX(x, y) (((x)>(y))?(x):(y))
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//
//  함수
//
////////////////////////////////////////////////////////////////////////////////
void kMemSet( void* pvDestination, BYTE bData, int iSize );
int kMemCpy( void* pvDestination, const void* pvSource, int iSize );
int kMemCmp( const void* pvDestination, const void* pvSource, int iSize );
BOOL kSetInterruptFlag( BOOL bEnableInterrupt );
void kCheckTotalRAMSize( void );
QWORD kGetTotalRAMSize( void );
void kReverseString( char* pcBuffer );
long kAToI( const char* pcBuffer, int iRadix );
QWORD kHexStringToQword( const char* pcBuffer );
long kDecimalStringToLong( const char* pcBuffer );
int kIToA( long lValue, char* pcBuffer, int iRadix );
int kHexToString( QWORD qwValue, char* pcBuffer );
int kDecimalToString( long lValue, char* pcBuffer );
int kSPrintf( char* pcBuffer, const char* pcFormatString, ... );
int kVSPrintf( char* pcBuffer, const char* pcFormatString, va_list ap );
QWORD kGetTickCount( void );
void kSleep( QWORD qwMillisecond );

////////////////////////////////////////////////////////////////////////////////
//
//  기타
//
////////////////////////////////////////////////////////////////////////////////
extern volatile QWORD g_qwTickCount;

#endif /*__UTILITY_H__*/

```

#### 02.Kernel64/Source/ConsoleShell.h

```c
#ifndef __CONSOLESHELL_H__
#define __CONSOLESHELL_H__

#include "Types.h"

////////////////////////////////////////////////////////////////////////////////
//
// 매크로
//
////////////////////////////////////////////////////////////////////////////////
#define CONSOLESHELL_MAXCOMMANDBUFFERCOUNT  300
#define CONSOLESHELL_PROMPTMESSAGE          "CYNOS64! >"

// 문자열 포인터를 파라미터로 받는 함수 포인터 타입 정의
typedef void ( * CommandFunction ) ( const char* pcParameter );


////////////////////////////////////////////////////////////////////////////////
//
// 구조체
//
////////////////////////////////////////////////////////////////////////////////
// 1바이트로 정렬
#pragma pack( push, 1 )

// 셸의 커맨드를 저장하는 자료구조
typedef struct kShellCommandEntryStruct
{
    // 커맨드 문자열
    char* pcCommand;
    // 커맨드의 도움말
    char* pcHelp;
    // 커맨드를 수행하는 함수의 포인터
    CommandFunction pfFunction;
} SHELLCOMMANDENTRY;

// 파라미터를 처리하기위해 정보를 저장하는 자료구조
typedef struct kParameterListStruct
{
    // 파라미터 버퍼의 어드레스
    const char* pcBuffer;
    // 파라미터의 길이
    int iLength;
    // 현재 처리할 파라미터가 시작하는 위치
    int iCurrentPosition;
} PARAMETERLIST;

#pragma pack( pop )

////////////////////////////////////////////////////////////////////////////////
//
// 함수
//
////////////////////////////////////////////////////////////////////////////////
// 실제 셸 코드
void kStartConsoleShell( void );
void kExecuteCommand( const char* pcCommandBuffer );
void kInitializeParameter( PARAMETERLIST* pstList, const char* pcParameter );
int kGetNextParameter( PARAMETERLIST* pstList, char* pcParameter );

// 커맨드를 처리하는 함수
static void kHelp( const char* pcParameterBuffer );
static void kCls( const char* pcParameterBuffer );
static void kShowTotalRAMSize( const char* pcParameterBuffer );
static void kStringToDecimalHexTest( const char* pcParameterBuffer );
static void kShutdown( const char* pcParameterBuffer );

////////////////////////////////////////////////////////////////////////////////
//
// 타이머 디바이스 드라이버 추가
//
////////////////////////////////////////////////////////////////////////////////
static void kSetTimer(const char* pcParameterBuffer);
static void kWaitUsingPIT(const char* pcParameterBuffer);
static void kReadTimeStampCounter(const char* pcParameterBuffer);
static void kMeasureProcessorSpeed(const char* pcParameterBuffer);
static void kShowDateAndTime(const char* pcParameterBuffer);
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 태스크 개념을 추가해 멀티태스킹을 구현하자
//
////////////////////////////////////////////////////////////////////////////////
static void kCreateTestTask(const char* pcParameterBuffer);
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 멀티레벨 큐 스케줄러와 태스크 종료기능 추가
//
////////////////////////////////////////////////////////////////////////////////
static void kChangeTaskPriority( const char* pcParameterBuffer );
static void kShowTaskList( const char* pcParameterBuffer );
static void kKillTask( const char* pcParameterBuffer );
static void kCPULoad( const char* pcParameterBuffer );
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 멀티 스레딩 기능을 추가하자.
//
////////////////////////////////////////////////////////////////////////////////
static void kTestMutex( const char* pcParameterBuffer );
static void kCreateThreadTask( void );
static void kTestThread( const char* pcParameterBuffer );
static void kShowMatrix( const char* pcParameterBuffer );
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 실수 연산 기능 통합과 빌드
//
////////////////////////////////////////////////////////////////////////////////
static void kTestPIE(const char* pcParameterBuffer);
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 동적 메모리 할당
//
//////////////////////////////////////////////////////////////////////////////// 
static void kShowDyanmicMemoryInformation( const char* pcParameterBuffer );
static void kTestSequentialAllocation(const char* pcParameterBuffer);
static void kTestRandomAllocation(const char* pcParameterBuffer);
static void kRandomAllocationTask(void);
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
//
// 하드디스크 디바이스 드라이버 추가 
//
////////////////////////////////////////////////////////////////
static void kShowHDDInformation( const char* pcParameterBuffer );
static void kReadSector( const char* pcParameterBuffer );
static void kWriteSector( const char* pcParameterBuffer );
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
//
// 간단한 파일 시스템 구현
//
////////////////////////////////////////////////////////////////
static void kMountHDD(const char* pcParameterBuffer);
static void kFormatHDD(const char* pcParameterBuffer);
static void kShowFileSystemInformation(const char* pcParameterBuffer);
static void kCreateFileInRootDirectory(const char* pcParameterBuffer);
static void kDeleteFileInRootDirectory(const char* pcParameterBuffer);
static void kShowRootDirectory(const char* pcParameterBuffer);
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
static void kWriteDataToFile( const char* pcParameterBuffer );
static void kReadDataFromFile( const char* pcParameterBuffer );
static void kTestFileIO( const char* pcParameterBuffer );
////////////////////////////////////////////////////////////////////////////////
#endif /*__CONSOLESHELL_H__*/

```

#### 02.Kernel64/Source/ConsoleShell.c

```c
#include "ConsoleShell.h"
#include "Console.h"
#include "Keyboard.h"
#include "Utility.h"
#include "PIT.h"
#include "RTC.h"
#include "AssemblyUtility.h"
////////////////////////////////////////////////////////////////////////////////
//
// 멀티레벨 큐 스케줄러와 태스크 종료기능 추가
//
////////////////////////////////////////////////////////////////////////////////
#include "Task.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// 멀티 스레딩 기능을 추가하자.
//
////////////////////////////////////////////////////////////////////////////////
#include "Synchronization.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// 동적 메모리 할당
//
//////////////////////////////////////////////////////////////////////////////// 
#include "DynamicMemory.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// 하드디스크 디바이스 드라이버 추가 
//
////////////////////////////////////////////////////////////////
#include "HardDisk.h"
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// 간단한 파일 시스템 구현
//
////////////////////////////////////////////////////////////////
#include "FileSystem.h"
////////////////////////////////////////////////////////////////

// 커맨드 테이블 정의
SHELLCOMMANDENTRY gs_vstCommandTable[] =
{
        { "help", "Show Help", kHelp },
        { "cls", "Clear Screen", kCls },
        { "totalram", "Show Total RAM Size", kShowTotalRAMSize },
        { "strtod", "String To Decial/Hex Convert", kStringToDecimalHexTest },
        { "shutdown", "Shutdown And Reboot OS", kShutdown },
        
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 타이머 디바이스 드라이버 추가
        //
        ////////////////////////////////////////////////////////////////////////////////
        { "settimer", "Set PIT Controller Counter0, ex)settimer 10(ms) 1(periodic)", 
                kSetTimer },
        { "wait", "Wait ms Using PIT, ex)wait 100(ms)", kWaitUsingPIT },
        { "rdtsc", "Read Time Stamp Counter", kReadTimeStampCounter },
        { "cpuspeed", "Measure Processor Speed", kMeasureProcessorSpeed },
        { "date", "Show Date And Time", kShowDateAndTime },
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 라운드 로빈 스케줄러를 추가하자
        //
        ////////////////////////////////////////////////////////////////////////////////
        {"createtask","Create Task, ex)createtask 1(type) 10(count)", kCreateTestTask},
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 멀티레벨 큐 스케줄러와 태스크 종료기능 추가
        //
        ////////////////////////////////////////////////////////////////////////////////
        { "changepriority", "Change Task Priority, ex)changepriority 1(ID) 2(Priority)",
                kChangeTaskPriority },
        { "tasklist", "Show Task List", kShowTaskList },
        { "killtask", "End Task, ex)killtask 1(ID)", kKillTask },
        { "cpuload", "Show Processor Load", kCPULoad },
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 멀티 스레딩 기능을 추가하자.
        //
        ////////////////////////////////////////////////////////////////////////////////
        { "testmutex", "Test Mutex Function", kTestMutex },
        { "testthread", "Test Thread And Process Function", kTestThread },
        { "showmatrix", "Show Matrix Screen", kShowMatrix },
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 실수 연산 기능 통합과 빌드
        //
        ////////////////////////////////////////////////////////////////////////////////
        { "testpie", "Test PIE Calculation", kTestPIE },      
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 동적 메모리 할당
        //
        //////////////////////////////////////////////////////////////////////////////// 
        { "dynamicmeminfo", "Show Dyanmic Memory Information", kShowDyanmicMemoryInformation },
        { "testseqalloc", "Test Sequential Allocation & Free", kTestSequentialAllocation },
        { "testranalloc", "Test Random Allocation & Free", kTestRandomAllocation },
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////
        //
        // 하드디스크 디바이스 드라이버 추가 
        //
        ////////////////////////////////////////////////////////////////
        { "hddinfo", "Show HDD Information", kShowHDDInformation },
        { "readsector", "Read HDD Sector, ex)readsector 0(LBA) 10(count)", 
                kReadSector },
        { "writesector", "Write HDD Sector, ex)writesector 0(LBA) 10(count)", 
                kWriteSector },
        ////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////
        //
        // 간단한 파일 시스템 구현
        //
        ////////////////////////////////////////////////////////////////
        { "mounthdd", "Mount HDD", kMountHDD },
        { "formathdd", "Format HDD", kFormatHDD },
        { "filesysteminfo", "Show File System Information", kShowFileSystemInformation },
        { "createfile", "Create File, ex)createfile a.txt", kCreateFileInRootDirectory },
        { "deletefile", "Delete File, ex)deletefile a.txt", kDeleteFileInRootDirectory },
        { "dir", "Show Directory", kShowRootDirectory },
        ////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // C 표준 입출력 함수 추가
        //
        ////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////
};                                     

//==============================================================================
//  실제 셸을 구성하는 코드
//==============================================================================

	... 생략 ...

////////////////////////////////////////////////////////////////
//
// 간단한 파일 시스템 구현
//
////////////////////////////////////////////////////////////////
/**
 *  하드 디스크를 연결
 */
static void kMountHDD( const char* pcParameterBuffer )
{
    if( kMount() == FALSE )
    {
        kPrintf( "HDD Mount Fail\n" );
        return ;
    }
    kPrintf( "HDD Mount Success\n" );
}

/**
 *  하드 디스크에 파일 시스템을 생성(포맷)
 */
static void kFormatHDD( const char* pcParameterBuffer )
{
    if( kFormat() == FALSE )
    {
        kPrintf( "HDD Format Fail\n" );
        return ;
    }
    kPrintf( "HDD Format Success\n" );
}

/**
 *  파일 시스템 정보를 표시
 */
static void kShowFileSystemInformation( const char* pcParameterBuffer )
{
    FILESYSTEMMANAGER stManager;
    
    kGetFileSystemInformation( &stManager );
    
    kPrintf( "================== File System Information ==================\n" );
    kPrintf( "Mouted:\t\t\t\t\t %d\n", stManager.bMounted );
    kPrintf( "Reserved Sector Count:\t\t\t %d Sector\n", stManager.dwReservedSectorCount );
    kPrintf( "Cluster Link Table Start Address:\t %d Sector\n", 
            stManager.dwClusterLinkAreaStartAddress );
    kPrintf( "Cluster Link Table Size:\t\t %d Sector\n", stManager.dwClusterLinkAreaSize );
    kPrintf( "Data Area Start Address:\t\t %d Sector\n", stManager.dwDataAreaStartAddress );
    kPrintf( "Total Cluster Count:\t\t\t %d Cluster\n", stManager.dwTotalClusterCount );
}

/**
 *  루트 디렉터리에 빈 파일을 생성
 */
static void kCreateFileInRootDirectory( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcFileName[ 50 ];
    int iLength;
    DWORD dwCluster;
    DIRECTORYENTRY stEntry;
    int i;
    ////////////////////////////////////////////////////////////////////////////////
    //
    // C 표준 입출력 함수 추가
    //
    ////////////////////////////////////////////////////////////////////////////////
    FILE* pstFile;
    ////////////////////////////////////////////////////////////////////////////////
    
    // 파라미터 리스트를 초기화하여 파일 이름을 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    iLength = kGetNextParameter( &stList, vcFileName );
    vcFileName[ iLength ] = '\0';
    if( ( iLength > ( sizeof( stEntry.vcFileName ) - 1 ) ) || ( iLength == 0 ) )
    {
        kPrintf( "Too Long or Too Short File Name\n" );
        return ;
    }

    ////////////////////////////////////////////////////////////////////////////////
    //
    // C 표준 입출력 함수 추가
    //
    ////////////////////////////////////////////////////////////////////////////////
    pstFile = fopen(vcFileName,"w");
    if(pstFile == NULL)
    {
        kPrintf("File Create Fail\n");
        return;
    }
    fclose(pstFile);
    ////////////////////////////////////////////////////////////////////////////////
    kPrintf( "File Create Success\n" );
}

/**
 *  루트 디렉터리에서 파일을 삭제
 */
static void kDeleteFileInRootDirectory( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcFileName[ 50 ];
    int iLength;
    DIRECTORYENTRY stEntry;
    int iOffset;
    
    // 파라미터 리스트를 초기화하여 파일 이름을 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    iLength = kGetNextParameter( &stList, vcFileName );
    vcFileName[ iLength ] = '\0';
    ////////////////////////////////////////////////////////////////////////////////
    //
    // C 표준 입출력 함수 추가
    //
    ////////////////////////////////////////////////////////////////////////////////
    if((iLength > (FILESYSTEM_MAXFILENAMELENGTH - 1))||(iLength == 0))
    {
        kPrintf("Too Long or Too Short File Name\n");
        return;
    }

    if(remove(vcFileName) != 0)
    {
        kPrintf("File Not Found or File Opened\n");
        return;
    }
    ////////////////////////////////////////////////////////////////////////////////
    
    kPrintf( "File Delete Success\n" );
}

/**
 *  루트 디렉터리의 파일 목록을 표시
 */
static void kShowRootDirectory( const char* pcParameterBuffer )
{
    ////////////////////////////////////////////////////////////////////////////////
    //
    // C 표준 입출력 함수 추가
    //
    ////////////////////////////////////////////////////////////////////////////////
    DIR* pstDirectory;
    int i, iCount, iTotalCount;
    struct dirent* pstEntry;
    char vcBuffer[ 400 ];
    char vcTempValue[ 50 ];
    DWORD dwTotalByte;
    DWORD dwUsedClusterCount;
    FILESYSTEMMANAGER stManager;
    
    // 파일 시스템 정보를 얻음
    kGetFileSystemInformation( &stManager );
     
    // 루트 디렉터리를 엶
    pstDirectory = opendir( "/" );
    if( pstDirectory == NULL )
    {
        kPrintf( "Root Directory Open Fail\n" );
        return ;
    }
    
    // 먼저 루프를 돌면서 디렉터리에 있는 파일의 개수와 전체 파일이 사용한 크기를 계산
    iTotalCount = 0;
    dwTotalByte = 0;
    dwUsedClusterCount = 0;
    while( 1 )
    {
        // 디렉터리에서 엔트리 하나를 읽음
        pstEntry = readdir( pstDirectory );
        // 더이상 파일이 없으면 나감
        if( pstEntry == NULL )
        {
            break;
        }
        iTotalCount++;
        dwTotalByte += pstEntry->dwFileSize;

        // 실제로 사용된 클러스터의 개수를 계산
        if( pstEntry->dwFileSize == 0 )
        {
            // 크기가 0이라도 클러스터 1개는 할당되어 있음
            dwUsedClusterCount++;
        }
        else
        {
            // 클러스터 개수를 올림하여 더함
            dwUsedClusterCount += ( pstEntry->dwFileSize + 
                ( FILESYSTEM_CLUSTERSIZE - 1 ) ) / FILESYSTEM_CLUSTERSIZE;
        }
    }
    
    // 실제 파일의 내용을 표시하는 루프
    rewinddir( pstDirectory );
    iCount = 0;
    while( 1 )
    {
        // 디렉터리에서 엔트리 하나를 읽음
        pstEntry = readdir( pstDirectory );
        // 더이상 파일이 없으면 나감
        if( pstEntry == NULL )
        {
            break;
        }
        
        // 전부 공백으로 초기화 한 후 각 위치에 값을 대입
        kMemSet( vcBuffer, ' ', sizeof( vcBuffer ) - 1 );
        vcBuffer[ sizeof( vcBuffer ) - 1 ] = '\0';
        
        // 파일 이름 삽입
        kMemCpy( vcBuffer, pstEntry->d_name, 
                 kStrLen( pstEntry->d_name ) );

        // 파일 길이 삽입
        kSPrintf( vcTempValue, "%d Byte", pstEntry->dwFileSize );
        kMemCpy( vcBuffer + 30, vcTempValue, kStrLen( vcTempValue ) );

        // 파일의 시작 클러스터 삽입
        kSPrintf( vcTempValue, "0x%X Cluster", pstEntry->dwStartClusterIndex );
        kMemCpy( vcBuffer + 55, vcTempValue, kStrLen( vcTempValue ) + 1 );
        kPrintf( "    %s\n", vcBuffer );

        if( ( iCount != 0 ) && ( ( iCount % 20 ) == 0 ) )
        {
            kPrintf( "Press any key to continue... ('q' is exit) : " );
            if( kGetCh() == 'q' )
            {
                kPrintf( "\n" );
                break;
            }        
        }
        iCount++;
    }
    
    // 총 파일의 개수와 파일의 총 크기를 출력
    kPrintf( "\t\tTotal File Count: %d\n", iTotalCount );
    kPrintf( "\t\tTotal File Size: %d KByte (%d Cluster)\n", dwTotalByte, 
             dwUsedClusterCount );
    
    // 남은 클러스터 수를 이용해서 여유 공간을 출력
    kPrintf( "\t\tFree Space: %d KByte (%d Cluster)\n", 
             ( stManager.dwTotalClusterCount - dwUsedClusterCount ) * 
             FILESYSTEM_CLUSTERSIZE / 1024, stManager.dwTotalClusterCount - 
             dwUsedClusterCount );
    
    // 디렉터리를 닫음
    closedir( pstDirectory );
    ////////////////////////////////////////////////////////////////////////////////
}
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
/**
 *  파일을 생성하여 키보드로 입력된 데이터를 씀
 */
static void kWriteDataToFile( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcFileName[ 50 ];
    int iLength;
    FILE* fp;
    int iEnterCount;
    BYTE bKey;
    
    // 파라미터 리스트를 초기화하여 파일 이름을 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    iLength = kGetNextParameter( &stList, vcFileName );
    vcFileName[ iLength ] = '\0';
    if( ( iLength > ( FILESYSTEM_MAXFILENAMELENGTH - 1 ) ) || ( iLength == 0 ) )
    {
        kPrintf( "Too Long or Too Short File Name\n" );
        return ;
    }
    
    // 파일 생성
    fp = fopen( vcFileName, "w" );
    if( fp == NULL )
    {
        kPrintf( "%s File Open Fail\n", vcFileName );
        return ;
    }
    
    // 엔터 키가 연속으로 3번 눌러질 때까지 내용을 파일에 씀
    iEnterCount = 0;
    while( 1 )
    {
        bKey = kGetCh();
        // 엔터 키이면 연속 3번 눌러졌는가 확인하여 루프를 빠져 나감
        if( bKey == KEY_ENTER )
        {
            iEnterCount++;
            if( iEnterCount >= 3 )
            {
                break;
            }
        }
        // 엔터 키가 아니라면 엔터 키 입력 횟수를 초기화
        else
        {
            iEnterCount = 0;
        }
        
        kPrintf( "%c", bKey );
        if( fwrite( &bKey, 1, 1, fp ) != 1 )
        {
            kPrintf( "File Wirte Fail\n" );
            break;
        }
    }
    
    kPrintf( "File Create Success\n" );
    fclose( fp );
}

/**
 *  파일을 열어서 데이터를 읽음
 */
static void kReadDataFromFile( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcFileName[ 50 ];
    int iLength;
    FILE* fp;
    int iEnterCount;
    BYTE bKey;
    
    // 파라미터 리스트를 초기화하여 파일 이름을 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    iLength = kGetNextParameter( &stList, vcFileName );
    vcFileName[ iLength ] = '\0';
    if( ( iLength > ( FILESYSTEM_MAXFILENAMELENGTH - 1 ) ) || ( iLength == 0 ) )
    {
        kPrintf( "Too Long or Too Short File Name\n" );
        return ;
    }
    
    // 파일 생성
    fp = fopen( vcFileName, "r" );
    if( fp == NULL )
    {
        kPrintf( "%s File Open Fail\n", vcFileName );
        return ;
    }
    
    // 파일의 끝까지 출력하는 것을 반복
    iEnterCount = 0;
    while( 1 )
    {
        if( fread( &bKey, 1, 1, fp ) != 1 )
        {
            break;
        }
        kPrintf( "%c", bKey );
        
        // 만약 엔터 키이면 엔터 키 횟수를 증가시키고 20라인까지 출력했다면 
        // 더 출력할지 여부를 물어봄
        if( bKey == KEY_ENTER )
        {
            iEnterCount++;
            
            if( ( iEnterCount != 0 ) && ( ( iEnterCount % 20 ) == 0 ) )
            {
                kPrintf( "Press any key to continue... ('q' is exit) : " );
                if( kGetCh() == 'q' )
                {
                    kPrintf( "\n" );
                    break;
                }
                kPrintf( "\n" );
                iEnterCount = 0;
            }
        }
    }
    fclose( fp );
}

/**
 *  파일 I/O에 관련된 기능을 테스트
 */
static void kTestFileIO( const char* pcParameterBuffer )
{
    FILE* pstFile;
    BYTE* pbBuffer;
    int i;
    int j;
    DWORD dwRandomOffset;
    DWORD dwByteCount;
    BYTE vbTempBuffer[ 1024 ];
    DWORD dwMaxFileSize;
    
    kPrintf( "================== File I/O Function Test ==================\n" );
    
    // 4Mbyte의 버퍼 할당
    dwMaxFileSize = 4 * 1024 * 1024;
    pbBuffer = kAllocateMemory( dwMaxFileSize );
    if( pbBuffer == NULL )
    {
        kPrintf( "Memory Allocation Fail\n" );
        return ;
    }
    // 테스트용 파일을 삭제
    remove( "testfileio.bin" );

    //==========================================================================
    // 파일 열기 테스트
    //==========================================================================
    kPrintf( "1. File Open Fail Test..." );
    // r 옵션은 파일을 생성하지 않으므로, 테스트 파일이 없는 경우 NULL이 되어야 함
    pstFile = fopen( "testfileio.bin", "r" );
    if( pstFile == NULL )
    {
        kPrintf( "[Pass]\n" );
    }
    else
    {
        kPrintf( "[Fail]\n" );
        fclose( pstFile );
    }
    
    //==========================================================================
    // 파일 생성 테스트
    //==========================================================================
    kPrintf( "2. File Create Test..." );
    // w 옵션은 파일을 생성하므로, 정상적으로 핸들이 반환되어야함
    pstFile = fopen( "testfileio.bin", "w" );
    if( pstFile != NULL )
    {
        kPrintf( "[Pass]\n" );
        kPrintf( "    File Handle [0x%Q]\n", pstFile );
    }
    else
    {
        kPrintf( "[Fail]\n" );
    }
    
    //==========================================================================
    // 순차적인 영역 쓰기 테스트
    //==========================================================================
    kPrintf( "3. Sequential Write Test(Cluster Size)..." );
    // 열린 핸들을 가지고 쓰기 수행
    for( i = 0 ; i < 100 ; i++ )
    {
        kMemSet( pbBuffer, i, FILESYSTEM_CLUSTERSIZE );
        if( fwrite( pbBuffer, 1, FILESYSTEM_CLUSTERSIZE, pstFile ) !=
            FILESYSTEM_CLUSTERSIZE )
        {
            kPrintf( "[Fail]\n" );
            kPrintf( "    %d Cluster Error\n", i );
            break;
        }
    }
    if( i >= 100 )
    {
        kPrintf( "[Pass]\n" );
    }
    
    //==========================================================================
    // 순차적인 영역 읽기 테스트
    //==========================================================================
    kPrintf( "4. Sequential Read And Verify Test(Cluster Size)..." );
    // 파일의 처음으로 이동
    fseek( pstFile, -100 * FILESYSTEM_CLUSTERSIZE, SEEK_END );
    
    // 열린 핸들을 가지고 읽기 수행 후, 데이터 검증
    for( i = 0 ; i < 100 ; i++ )
    {
        // 파일을 읽음
        if( fread( pbBuffer, 1, FILESYSTEM_CLUSTERSIZE, pstFile ) !=
            FILESYSTEM_CLUSTERSIZE )
        {
            kPrintf( "[Fail]\n" );
            return ;
        }
        
        // 데이터 검사
        for( j = 0 ; j < FILESYSTEM_CLUSTERSIZE ; j++ )
        {
            if( pbBuffer[ j ] != ( BYTE ) i )
            {
                kPrintf( "[Fail]\n" );
                kPrintf( "    %d Cluster Error. [%X] != [%X]\n", i, pbBuffer[ j ], 
                         ( BYTE ) i );
                break;
            }
        }
    }
    if( i >= 100 )
    {
        kPrintf( "[Pass]\n" );
    }

    //==========================================================================
    // 임의의 영역 쓰기 테스트
    //==========================================================================
    kPrintf( "5. Random Write Test...\n" );
    
    // 버퍼를 모두 0으로 채움
    kMemSet( pbBuffer, 0, dwMaxFileSize );
    // 여기 저기에 옮겨다니면서 데이터를 쓰고 검증
    // 파일의 내용을 읽어서 버퍼로 복사
    fseek( pstFile, -100 * FILESYSTEM_CLUSTERSIZE, SEEK_CUR );
    fread( pbBuffer, 1, dwMaxFileSize, pstFile );
    
    // 임의의 위치로 옮기면서 데이터를 파일과 버퍼에 동시에 씀
    for( i = 0 ; i < 100 ; i++ )
    {
        dwByteCount = ( kRandom() % ( sizeof( vbTempBuffer ) - 1 ) ) + 1;
        dwRandomOffset = kRandom() % ( dwMaxFileSize - dwByteCount );
        
        kPrintf( "    [%d] Offset [%d] Byte [%d]...", i, dwRandomOffset, 
                dwByteCount );

        // 파일 포인터를 이동
        fseek( pstFile, dwRandomOffset, SEEK_SET );
        kMemSet( vbTempBuffer, i, dwByteCount );
              
        // 데이터를 씀
        if( fwrite( vbTempBuffer, 1, dwByteCount, pstFile ) != dwByteCount )
        {
            kPrintf( "[Fail]\n" );
            break;
        }
        else
        {
            kPrintf( "[Pass]\n" );
        }
        
        kMemSet( pbBuffer + dwRandomOffset, i, dwByteCount );
    }
    
    // 맨 마지막으로 이동하여 1바이트를 써서 파일의 크기를 4Mbyte로 만듦
    fseek( pstFile, dwMaxFileSize - 1, SEEK_SET );
    fwrite( &i, 1, 1, pstFile );
    pbBuffer[ dwMaxFileSize - 1 ] = ( BYTE ) i;

    //==========================================================================
    // 임의의 영역 읽기 테스트
    //==========================================================================
    kPrintf( "6. Random Read And Verify Test...\n" );
    // 임의의 위치로 옮기면서 파일에서 데이터를 읽어 버퍼의 내용과 비교
    for( i = 0 ; i < 100 ; i++ )
    {
        dwByteCount = ( kRandom() % ( sizeof( vbTempBuffer ) - 1 ) ) + 1;
        dwRandomOffset = kRandom() % ( ( dwMaxFileSize ) - dwByteCount );

        kPrintf( "    [%d] Offset [%d] Byte [%d]...", i, dwRandomOffset, 
                dwByteCount );
        
        // 파일 포인터를 이동
        fseek( pstFile, dwRandomOffset, SEEK_SET );
        
        // 데이터 읽음
        if( fread( vbTempBuffer, 1, dwByteCount, pstFile ) != dwByteCount )
        {
            kPrintf( "[Fail]\n" );
            kPrintf( "    Read Fail\n", dwRandomOffset ); 
            break;
        }
        
        // 버퍼와 비교
        if( kMemCmp( pbBuffer + dwRandomOffset, vbTempBuffer, dwByteCount ) 
                != 0 )
        {
            kPrintf( "[Fail]\n" );
            kPrintf( "    Compare Fail\n", dwRandomOffset ); 
            break;
        }
        
        kPrintf( "[Pass]\n" );
    }
    
    //==========================================================================
    // 다시 순차적인 영역 읽기 테스트
    //==========================================================================
    kPrintf( "7. Sequential Write, Read And Verify Test(1024 Byte)...\n" );
    // 파일의 처음으로 이동
    fseek( pstFile, -dwMaxFileSize, SEEK_CUR );
    
    // 열린 핸들을 가지고 쓰기 수행. 앞부분에서 2Mbyte만 씀
    for( i = 0 ; i < ( 2 * 1024 * 1024 / 1024 ) ; i++ )
    {
        kPrintf( "    [%d] Offset [%d] Byte [%d] Write...", i, i * 1024, 1024 );

        // 1024 바이트씩 파일을 씀
        if( fwrite( pbBuffer + ( i * 1024 ), 1, 1024, pstFile ) != 1024 )
        {
            kPrintf( "[Fail]\n" );
            return ;
        }
        else
        {
            kPrintf( "[Pass]\n" );
        }
    }

    // 파일의 처음으로 이동
    fseek( pstFile, -dwMaxFileSize, SEEK_SET );
    
    // 열린 핸들을 가지고 읽기 수행 후 데이터 검증. Random Write로 데이터가 잘못 
    // 저장될 수 있으므로 검증은 4Mbyte 전체를 대상으로 함
    for( i = 0 ; i < ( dwMaxFileSize / 1024 )  ; i++ )
    {
        // 데이터 검사
        kPrintf( "    [%d] Offset [%d] Byte [%d] Read And Verify...", i, 
                i * 1024, 1024 );
        
        // 1024 바이트씩 파일을 읽음
        if( fread( vbTempBuffer, 1, 1024, pstFile ) != 1024 )
        {
            kPrintf( "[Fail]\n" );
            return ;
        }
        
        if( kMemCmp( pbBuffer + ( i * 1024 ), vbTempBuffer, 1024 ) != 0 )
        {
            kPrintf( "[Fail]\n" );
            break;
        }
        else
        {
            kPrintf( "[Pass]\n" );
        }
    }
        
    //==========================================================================
    // 파일 삭제 실패 테스트
    //==========================================================================
    kPrintf( "8. File Delete Fail Test..." );
    // 파일이 열려있는 상태이므로 파일을 지우려고 하면 실패해야 함
    if( remove( "testfileio.bin" ) != 0 )
    {
        kPrintf( "[Pass]\n" );
    }
    else
    {
        kPrintf( "[Fail]\n" );
    }
    
    //==========================================================================
    // 파일 닫기 테스트
    //==========================================================================
    kPrintf( "9. File Close Test..." );
    // 파일이 정상적으로 닫혀야 함
    if( fclose( pstFile ) == 0 )
    {
        kPrintf( "[Pass]\n" );
    }
    else
    {
        kPrintf( "[Fail]\n" );
    }

    //==========================================================================
    // 파일 삭제 테스트
    //==========================================================================
    kPrintf( "10. File Delete Test..." );
    // 파일이 닫혔으므로 정상적으로 지워져야 함 
    if( remove( "testfileio.bin" ) == 0 )
    {
        kPrintf( "[Pass]\n" );
    }
    else
    {
        kPrintf( "[Fail]\n" );
    }
    
    // 메모리를 해제
    kFreeMemory( pbBuffer );    
}
////////////////////////////////////////////////////////////////////////////////
```

