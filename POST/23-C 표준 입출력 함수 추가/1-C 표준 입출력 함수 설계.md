# C 표준 입출력 함수 설계

C 표준 입출력 함수를 개별적으로 살펴보기 전에 우리가 구현할 함수가 어떤 타입으로 정의되어 있는지 함수 원형(Prototype)을 먼저 확인해보자.

<hr>

## 구현할 함수 목록과 함수 원형

우리는 파일과 디렉터리에 관련된 고수준 함수를 구현해야 한다.

고수준 함수의 형태는 C 표준 라이브러리를 따르기로 했으므로 먼저 해당 함수의 원형을 살펴보자.

![image](https://user-images.githubusercontent.com/34773827/62225559-a64d0100-b3f3-11e9-969e-b90b2153b8bd.png)

<hr>

## FILE 자료구조와 DIR 자료구조 설계

### 파일 관련 자료구조 FILE 정의



#### 파일 핸들 자료구조의 코드

표준 입출력 함수처럼 파일을 클러스터 단위가 아닌 바이트 단위로 처리하려면 현재 작업이 수행되는 위치(파일 포인터)에 따라 클러스터를 이동하는 부분이 필요하다.

파일 포인터에 따라 클러스터를 이동시키려면 우선 파일 오프셋을 클러스터 크기로 나누어 몇 번째 클러스터인지 판단해야 한다.

그후 파일 포인터가 현재 클러스터 내부에 있는지 확인해야 하며, 다른 클러스터로 이동해야 한다면 클러스터를 탐색해서 찾아야 한다.

이러한 작업을 처리하려면 파일 포인터의 현재 위치와 파일의 시작 클러스터 인덱스, 파일 포인터가 위치한 클러스터(현재 클러스터)의 인덱스가 필요하다.

그리고 실제 파일의 크기는 전체 클러스터가 차지하는 크기보다 작을 수 있으므로,<br>파일의 끝을 정확히 판단하려면 파일의 크기도 필요하다.

디렉터리 엔트리에 있는 파일의 크기는 파일이 커질 때마다 갱신해야 하므로 최악의 경우 1바이트마다 디렉터리 엔트리를 변경해야 할지도 모른다.

그럴때마다 루트 디렉터리에서 파일명으로 디렉터리 엔트리를 검색하는 것 보다는 디렉터리 엔트리의 오프셋을 저장했다가 해당 오프셋만 갱신하는 것이 효율적이다.

```c
// 파일을 관리하는 파일 핸들 자료구조
typedef struct kFileHandleStruct
{
    // 파일이 존재하는 디렉터리 엔트리의 오프셋
    int iDirectoryEntryOffset;
    // 파일 크기
    DWORD dwFileSize;
    // 파일의 시작 클러스터 인덱스
    DWORD dwStartClusterIndex;
    // 현재 I/O가 수행중인 클러스터의 인덱스
    DWORD dwCurrentClusterIndex;
    // 현재 클러스터의 바로 이전 클러스터의 인덱스
    DWORD dwPreviousClusterIndex;
    // 파일 포인터의 현재 위치
    DWORD dwCurrentOffset;
} FILEHANDLE;
```



#### 디렉터리 핸들 자료구조의 코드

디렉터리는 파일보다 필요한 정보가 비교적 작다.

디렉터리 관련 함수는 순차적으로 엔트리를 읽는 기능만 제공하므로,<br>루트 디렉터리에서 현재 어느 오프셋의 엔트리를 읽고 있는가만 저장하면 된다.

디렉터리 관련 함수는 특성상 루트 디렉터리에 접근하는 횟수가 많으므로,<br>루트 디렉터리의 내용을 버퍼에 저장해 디스크에 매번 접근하지 않도록 한다.

```c
// 디렉터리를 관리하는 디렉터리 핸들 자료구조
typedef struct kDirectoryHandleStruct
{
    // 루트 디렉터리를 저장해둔 버퍼
    DIRECTORYENTRY* pstDirectoryBuffer;
    
    // 디렉터리 포인터의 현재 위치
    int iCurrentOffset;
} DIRECTORYHANDLE;
```



#### FILE과 DIR 자료구조의 코드

파일 핸들과 디렉터리 핸들 자료구조를 정의했으니, 이제 두 자료구조를 하나로 합친다.

분리해 만든 자료구조를 다시 하나로 합치는 이유는 관리 때문이다.

우리 OS는 모든 자료구조를 태스크 자료구조처럼 풀 형태로 관리하므로 위의 두 자료구조도 풀 형태로 생성한다.

그런데 파일 핸들과 디렉터리 핸들을 별도의 풀로 관리한다면 처리하는 코드도 풀 별로 작성해야 한다.

```c
// 핸들의 타입을 정의
#define FILESYSTEM_TYPE_FREE                0
#define FILESYSTEM_TYPE_FILE                1
#define FILESYSTEM_TYPE_DIRECTORY           2

// 파일과 디렉터리에 대한 정보가 들어있는 자료구조
typedef struct kFileDirectoryHandleStruct
{
    // 자료구조의 타입 설정. 파일 핸들이나 디렉터리 핸들, 또는 빈 핸들 타입 지정 가능
    BYTE bType;

    // bType의 값에 따라 파일 또는 디렉터리로 사용
    union
    {
        // 파일 핸들
        FILEHANDLE stFileHandle;
        // 디렉터리 핸들
        DIRECTORYHANDLE stDirectoryHandle;
    };    
} FILE, DIR;
```

메모리 공간 하나를 여러 타입으로 사용하고 싶을 때 쓰는 것이 바로 공용체 (Union)이다.

공용체는 내부에 정의된 데이터 타입 중에서 가장 큰 크기 만큼 메모리를 할당하며,<br>이렇게 할당된 메모리는 사용자의 필요에 따라 원하는 타입으로 접근할 수 있다.