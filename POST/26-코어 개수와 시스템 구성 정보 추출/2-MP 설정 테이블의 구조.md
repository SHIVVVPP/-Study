# MP 설정 테이블의 구조

지금까지 BIOS가 멀티프로세서와 멀티코어 프로세서 환경을 어떤 방식으로 싱글코어 프로세서 환경처럼 구성하는지 살펴보았다.

사실 BIOS가 구성하는 호환 모드의 종류를 아는 것도 중요하지만 그보다 더 중요한 것은 현재 호환 모드가 어떤 것인지 아는 것이다.

이러한 정보는 BIOS에서 얻을 수 있다.

BIOS는 프로세서 초기화 과정에서 찾은 프로세서의 코어 개수와 PIC 컨트롤러, I/O APIC의 관계 등 여러 가지 정보를 BIOS 데이터 영역에 저장한다.

이러한 정보가 저장된 영역이 MP 설정 테이블이다.

MP 설정 테이블 (MP Configuration Table)은 프로세서와 시스템 버스, I/O APIC에 대한 정보가 저장된 테이블이다

MP 설정 테이블은 BIOS가 생성하고 관리하므로 BIOS 영역을 검색하면 쉽게 찾을 수 있다.

<hr>

## MP 설정 테이블과 MP 플로팅 포인터 자료구조

인텔에서 제정한 Multiprocessor Specification 문서에는 멀티프로세서 환경에 대한 정보를 제공하는 두 가지 방법을 정의하고 있다.

그중 하나는 MP 설정 테이블을 통해 직접 생성한 정보를 전달하는 방법이며,<br>다른 하나는 Multiprocessor Specification 문서에서 정의한 기본 설정을 사용하는 방법이다.

직접 생성한 MP 설정 테이블을 사용할지 아니면 기본 설정을 사용할지는 MP 플로팅 포인터 자료구조 (MP Floating Pointer Data Structure)에 명시되어 있으며,<br>이 자료구조는 MP 설정 테이블이 시작하는 위치의 물리 어드레스 정보와 IMCR 레지스터의 구현등도 포함된다.

다음 그림은 MP 플로팅 포인터 자료구조의 구성과 MP 설정 테이블의 관계이다.

![image](https://user-images.githubusercontent.com/34773827/62429739-64062580-b74d-11e9-8d96-e110528fb58a.png)

다음은 MP 플로팅 포인터 자료구조에 있는 각 필드의 의미이다.

![image](https://user-images.githubusercontent.com/34773827/62429774-d8d95f80-b74d-11e9-96de-ca6ba94765f5.png)

MP 플로팅 포인터 자료구조에서 우리가 유심히 봐야 할 부분은 시그니처와 MP 설정 테이블이 시작하는 물리 어드레스 포인터, MP 특성 정보 바이트 1/2이고 이중에서 시그니처가 특히 중요하다.

시그니처가 중요한 이유는 MP 플로팅 포인터 자료구조가 이름 그대로 BIOS 영역을 떠다니기 때문이다.

Multiprocessor Specification 문서에 따르면 MP 플로팅 포인터 자료구조는 아래 3가지 영역중 한 곳에 위치한다.

- 확장 BIOS 데이터 영역의 시작 어드레스에서 1KB 범위 내에 존재
  - 확장 BIOS 데이터 영역의 시작 세그먼트 어드레스는 물리 메모리 어드레스 0x040E에 2바이트로 저장
  - 저장된 값은 확장 BIOS데이터 영역이 시작하는 세그먼트의 어드레스이다.<br>따라서 저장된 값에 16을 곱해야 실제 확장 BIOS 데이터 영역이 시작하는 물리 어드레스가 된다.
- 시스템 기본 메모리의 끝부분에서 1KB 이하 범위에 존재
  - 640KB의 기본 메모리를 가지고 있다면 639KB ~ 640KB 범위 내에 존재
  - 시스템 기본 메모리의 크기는 물리 메모리 어드레스 0x0413에 2바이트로 저장되어 있다.
  - 저장된 값의 단위 KB이므로 1024를 곱하여 실제 크기로 변환해야 한다.
  - BIOS의 롬 영역 중에서 0x0F0000 ~ 0x0FFFFF 범위 내에 존재한다.

<hr>

MP 플로팅 포인터는 위에서 설명한 메모리 영역에서 시그니처를 비교하는 방법으로 쉽게 찾을 수 있다.<br>MP 플로팅 포인터를 BIOS 데이터 영역에서 찾았다면 MP 설정 테이블이 시작하는 물리 어드레스 포인터와 MP 특성 정보 바이트 1/2를 얻을 수 있다.

만일 MP 설정 테이블의 시작 어드레스가 0이라면 Multiprocessor Specification 문서에 정의된 기본 설정을 사용하는 것이다.

이때 MP 특성 정보 바이트 1의 값과 Multiprocessor Specification 문서에 정의된 기본 설정 값을 참조해서 구성을 파악해야 한다.

그 반대로 시작 어드레스 필드가 0이 아니면 MP 설정 테이블이 존재하는 것이므로 MP 설정 테이블을 분석해야 한다.

<hr>

MP 플로팅 포인터에서 MP 설정 테이블 존재 여부와 시작 어드레스를 확인했다면,<br>남은 것은 시스템이 IMCR 레지스터를 구현했는지 확인하는 것이다.

IMCR 레지스터는 싱글코어 프로세서처럼 설정 할 때 PIC 모드를 사용하는가 혹은 연결 모드를 사용하는가를 단적으로 보여주는 레지스터이다.

시스템이 IMCR 레지스터를 구현했다면 인터럽트 처리 경로를 변경할 때 IMCR 레지스터도 고려해야 하므로 확인한다.

<hr>

## MP 설정 테이블과 기본 MP 설정 테이블 엔트리

MP 설정 테이블은 고정 길이의 헤더와 그 뒤를 따르는 엔트리로 구성된다.

엔트리는 다시 필수 정보가 들어 있는 기본 MP 설정 테이블 엔트리와 부가 정보가 들어 있는 확장 MP 설정 테이블 엔트리로 나누어진다. 확장 MP 설정 테이블 엔트리는 선택 사항이므로 존재하지 않을 수도 있다.

각 엔트리를 설명하기 전에 먼저 MP 설정 테이블의 헤더와 필드의 의미를 살펴보면 다음과 같다.

![image](https://user-images.githubusercontent.com/34773827/62429918-864d7280-b750-11e9-8f59-bc0ca6f24edc.png)

![image](https://user-images.githubusercontent.com/34773827/62429938-f0feae00-b750-11e9-9fdd-7e7ada9f7cb4.png)

MP 설정 테이블 헤더는 여러 필드로 구성되어 있지만 주로 뒤에 따라오는 엔트리의 개수와 로컬 APIC 레지스터의 기준 어드레스를 알려준다. 따라서 엔트리 개수 필드와 로컬 APIC의 메모리 맵 I/O 어드레스 필드가 핵심이라 할 수 있다. 

엔트리 개수는 MP 설정 테이블 헤더 직후에 위치하는 기본 MP 설정 테이블 엔트리의 개수를 나타낸다. <br>기본 MP 설정 테이블 엔트리의 길이는 엔트리의 시작 부분에 위치하느 엔트리 타입에 따라 달라지기 때문에<br>엔트리를 정확하게 찾으려면 엔트리 개수가 꼭 필요하다.

로컬 APIC는 메모리 맵 I/O 방식으로 연결되어 있으며,<br>메모리 맵 I/O 어드레스 필드가 기준 어드레스를 나타낸다.<br>필드를 할당해서 기준 어드레스를 특별히 저장하는 이유는 로컬 APIC의 메모리 맵 I/O 어드레스를 변경할 수 있기 때문이다. 프로세서가 리셋되었을 때 로컬 APIC의 메모리 맵 I/O 어드레스는 0xFEE00000로 설정되지만,<br>필요하다면 BIOS가 POST 과정에서 다른 어드레스로 변경 할 수 있으므로 이를 저장해 두는 것이다.

<hr>

### 기본 MP 설정 테이블 엔트리

엔트리의 타입에는 프로세서, 버스, I/O APIC, I/O 인터럽트 지정(I/O Interrupt Assignment), 로컬 인터럽트 지정(Local Interrupt Assignment) 다섯 가지가 있다.

![image](https://user-images.githubusercontent.com/34773827/62429995-d8db5e80-b751-11e9-9992-1b584d44216e.png)

기본 MP 설정 테이블의 엔트리 타입을 보면 프로세서 또는 코어 정보부터 시스템 버스, 로컬 APIC와 I/O APIC 까지 우리가 필요한 정보는 모두 포함하고 있음을 알 수 있다.

<hr>

#### 프로세서 엔트리

프로세서 엔트리(Processor Entry)는 시스템에 존재하는 프로세서나 코어의 정보를 나타내는 엔트리이다.

멀티프로세서라면 각 프로세서 별로 엔트리가 존재하며 멀티 프로세서라면 각 코어별로 엔트리가 존재한다.

그러므로 프로세서 엔트리의 개수를 세면 시스템의 전체 프로세서나 코어의 수를 알 수 있다.

![image](https://user-images.githubusercontent.com/34773827/62430122-cdd4fe00-b752-11e9-83f2-496758812f15.png)

![image](https://user-images.githubusercontent.com/34773827/62430133-fceb6f80-b752-11e9-9b17-715efd5b6542.png)

<hr>

#### 버스 엔트리

버스 엔트리(Bus Entry)는 시스템에 존재하는 버스 정보를 나타내며, 엔트리 타입 중에서 구조가 가장 간단하다.

![image](https://user-images.githubusercontent.com/34773827/62430146-31f7c200-b753-11e9-96ce-0c8955884dc8.png)

버스 엔트리의 구조는 굉장히 간단하지만 프로세스 엔트리만큼 중요하다.

PC 내부에 있는 키보드 컨트롤러와 하드 디스크 컨트롤러 등이 사용하는 ISA 버스(Industry Standard Architecture)에 대한 정보가 들어 있기 때문이다. ISA 버스를 먼저 찾아야만 이 정보를 바탕으로 디바이스의 IRQ가 어느 I/O APIC 핀으로 연결되었는지를 확인할 수 있다.

<hr>

#### I/O APIC 엔트리

I/O APIC 엔트리(I/O APIC Entry)는 시스템에 존재하는 I/O APIC의 정보를 나타낸다.

I/O APIC에 접근할 수 있는 메모리 맵 I/O 어드레스와 활성화 여부가 담겨 있다.

![image](https://user-images.githubusercontent.com/34773827/62430173-ae8aa080-b753-11e9-8919-0f935723cfc5.png)

I/O APIC에서 중요한 부분은 I/O APIC ID 필드, I/O APIC 플래그 필드, I/O APIC의 메모리 맵 I/O 어드레스 필드이다

<hr>

#### I/O 인터럽트 지정 엔트리

I/O 인터럽트 지정 엔트리(I/O Interrupt Assignment Entry)는 인터럽트 전달 경로를 나타내는 중추로<br>인터럽트가 발생하는 버스와 IRQ, 연결된 I/O APIC와 핀 정보가 들어 있다.

![image](https://user-images.githubusercontent.com/34773827/62430196-1214ce00-b754-11e9-898a-d983522404a5.png)

I/O 인터럽트 지정 엔트리의 인터럽트 타입은 INT, NMI, SMI, ExtINT 네 가지로, <br>전달되는 인터럽트가 어떠한 형식인지를 나타낸다.

![image](https://user-images.githubusercontent.com/34773827/62430202-2eb10600-b754-11e9-97ec-56afe80720f9.png)

I/O 인터럽트 지정 엔트리는 I/O APIC에 연결된 인터럽트의 정보를 알려주므로, <br>인터럽트 타입은 I/O APIC가 처리 가능한 인터럽트의 종류라고 볼 수 있다.

I/O APIC는 다양한 종류의 인터럽트를 지원해야 하므로 여러 극성(Polarity)과 트리거(Trigger) 모드를 지원한다. I/O APIC가 지원하는 극성과 트리거 모드는 I/O 인터럽트 플래그의 종류를 보면 알 수 있다.

![image](https://user-images.githubusercontent.com/34773827/62430232-ac751180-b754-11e9-9e9b-705461e1cebe.png)

인터럽트 플래그 필드에 있는 극성이나 트리거 모드는 향후 I/O APIC의 I/O 리다이렉션 테이블을 설정할 때 사용한다. I/O 리다이렉션 테이블은 I/O APIC 핀에 전달된 인터럽트를 로컬 APIC로 어떻게 전달할지를 설정하는 테이블이다.

BIOS가 POST 과정에서 테이블을 생성하지만 우리가 정의한 인터럽트 벡터 테이블과 일치한다는 보장이 없으므로 재설정 한다.

#### 로컬 인터럽트 지정 엔트리

로컬 인터럽트 지정 엔트리(Local Interrupt Assignment Entry)는 로컬 APIC의 LINT0 핀과 LINT1 핀에 직접 연결된 인터럽트 신호의 정보를 나타낸다.

![image](https://user-images.githubusercontent.com/34773827/62430254-05dd4080-b755-11e9-940d-bb734e0600b9.png)



