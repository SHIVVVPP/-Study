# 멀티코어 프로세서와 BIOS

이번 절에서는 멀티코어 프로세서의 특징에 대하여 간단히 알아본다.

그리고 멀티코어 프로세서이지만 싱글 코어 프로세서 환경과 호환을 유지하기위해 BIOS가 어떻게 동작하는 지 알아본다.

<hr>

## 멀티코어 프로세서의 특징과<br>OS관점에서 본 멀티코어 프로세서

멀티코어 프로세서는 싱글코어 프로세서에 대비되는 개념으로 최소한 두 개 이상의 코어,<br>즉 CPU를 가지고 있는 프로세서를 의미한다.

멀티코어 프로세서는 다음 그림과 같이 코어를 연결하는 내부 버스와 공유 캐시를 바탕으로 정보를 주고 받으며 서로 독립적인 작업을 수행한다.

![image](https://user-images.githubusercontent.com/34773827/62428377-47152680-b73c-11e9-963d-1c619cc25b0c.png)

<hr>

멀티 코어 프로세서의 가장 큰 장점은 코어의 병렬 작업으로 인한 성능 향상이다.<br>싱글코어 프로세서를 사용할 때는 시분할 멀티태스킹을 통해 병렬 처리를 수행했다.

하지만 멀티코어 프로세서를 사용하면서 진정한 의미의 병렬 처리가 가능해졌다.

서로 연관성이 없는 두 태스크가 있고 이 태스크를 끝내려면 각각 프로세서가 10만큼 필요하다고 가정하자.

이를 싱글코어 프로세서로 실행한다면 시분할 멀티태스킹을 하기 때문에 두 작업이 끝나려면 20만큼 걸린다.

하지만 멀티코어 프로세서로 실행한다면 각 코어에 할당하면 되므로 10 밖에 걸리지 않는다.

> OS는 기본적으로 시분할 멀티태스킹을 사용하므로<br>싱글코어 프로세서라면 계산을 많이 하는 인코딩 작업을 하면 시스템 성능이 전체적으로 떨어진다.<br>하지만 멀티코어 프로세서는 코어가 두 개 이상이기 때문에 동시에 두 개 이상의 태스크를 실행할 수 있다.
>
> 한쪽 코어에서 인코딩하는 동안 다른 쪽 코어에서는 다른 작업을 동시에 처리할 수 있으므로 채감 성능의 저하가 거의 없이 쾌적하게 작업할 수 있다.

<hr>

### 싱글 코어 OS에서 멀티 코어 OS로 업그레이드 하는데 중요한 부분

#### 커널 자료 구조의 재설계

코어는 서로 독립적으로 작업을 처리하므로 코어별로 관리해야 하는 자료구조와 코어 간에 공유하는 자료구조를 잘 분리해야 한다.

특히 코어 간에 공유되는 자료구조는 동기화 문제가 발생하지 않도록 철저하게 대비해야 한다.

#### 코어 사이의 부하 분산(Load Balancing) 처리

코어가 모두 활성화되어 있더라도 특정 코어에만 작업이 몰린다면 싱글코어 프로세서와 차이가 없다.

각 코어 사이의 상태를 모니터링하여 작업을 분산시키는 것이 무엇보다 중요하다.

<hr>

## BIOS와 프로세서

OS의 부팅 과정을 생각해 보면 BIOS는 PC에 설치된 각종 디바이스의 상태를 검사한 후<br>부트 로더를 디스크에서 로딩하여 실행한다.

부트 로더를 메모리에 로딩했으면 이후 과정은 OS가 할 일이므로 BIOS의 역할은 부트 로더를 메모리로 복사하는 작업이 마지막이라고 할 수 있다.

![image](https://user-images.githubusercontent.com/34773827/62428524-c8b98400-b73d-11e9-9e67-83cd7598174c.png)

그림에서 POST(Power On Self Test) 과정을 살펴보면 프로세서를 초기화하는 과정이 있다.

BIOS는 이 과정에서 프로세서의 모든 코어를 초기화하고 시스템을 16비트 리얼모드로 설정한다.

16비트 모드로 설정하는 과정에는 코어 중에 하나만 남기고 나머지 코어는 대기 모드에 진입시키는 작업이 포함되어 있다.

즉, BIOS는 이미 부팅 과정에서 프로세서에 몇 개의 코어가 있는지 알고 있다는 것이다.

<hr>

프로세스 초기화 과정에서 선택되어 부팅 과정을 진행하는 코어를 부트 스트랩 프로세서(BootStrap Processor) 또는 BSP라고 하며, BSP를 제외한 나머지 코어를 애플리케이션 프로세서(Application Processor) 또는 AP 라고 한다.

BSP는 이어서 부팅 과정을 계속 진행하며 AP는 대기 모드로 진입해 BSP가 깨울 때 까지 대기한다.

BIOS에 의해 선택되어 부팅과정을 진행하는 것이 BSP라는 점을 제외하면 BSP와 AP의 기능 차이는 없다.

<hr>

프로세서를 초기화하고 16비트 모드로 만드는 과정에는 인터럽트를 BSP에 전달하도록 인터럽트 전달 경로를 설정하는 작업도 있다. 사실 PIC 컨트롤러를 통해 인터럽트를 처리하는 과정은 과거 싱글코어 프로세서 기반에서 사용했던 고전적인 방법이다.

<hr>

PIC 컨트롤러는 싱글코어 프로세서를 하나만 사용한다는 전제 하에 설계되었기 때문에 멀티코어 환경에서는 사용할 수 없다. 

그래서 새롭게 등장한 것이 APIC와 I/O APIC이다.<br>두 컨트롤러는 여러 코어로 인터럽트를 전달할 수 있도록 설계되었기 때문에<br>멀티코어 프로세서 환경에서 필수이다.

이러한 이유로 멀티코어 프로세서를 지원하는 메인보드에는 PIC 컨트롤러와 APIC, I/O APIC가 공존한다.<br>BIOS는 16비트 모드로 설정하는 과정에서 APIC와 I/O APIC, 기타 레지스터를 설정하여,<br>PIC 컨트롤러를 통해 인터럽트가 전달되도록 한다.

그리고 인터럽트가 BSP로만 전달되도록 하여 마치 싱글코어 프로세서에 16비트 환경인 것처럼 만들어 준다.

멀티코어 프로세서를 사용하든 싱글코어 프로세서를 사용하든 부팅 과정에서는 싱글코어 프로세서처럼 동작하기 때문에 싱글코어 기반으로 작성된 예전 OS가 동작하는 데 아무 문제가 없다.

<hr>

BIOS가 프로세서의 모든 정보를 알고 있으니 코어 활성화도 해주면 좋겠지만,<br>BIOS의 역할은 싱글코어 프로세서 환경처럼 만들어 주는 것이 전부이다.<br>잠들어 있는 모든 코어를 깨워 64비트 모드로 전환시켜 작업을 할당하는 것은 우리의 몫이다.

<hr>

## 멀티코어 프로세서, 로컬 APIC, I/O APIC, PIC 컨트롤러

프로세서 내부에 있는 각 코어는 인터럽트 처리를 담당하는 자신만의 로컬 APIC를 가지고 있으며,<br>로컬 APIC는 I/O APIC와 다른 코어의 로컬 APIC와 연결된다.

여러 디바이스의 인터럽트 라인은 I/O APIC와 PIC 컨트롤러에 직접 연결되어 있으며,<br>PIC 컨트롤러는 I/O APIC와 로컬 APIC 또는 CPU에 직접 연결된다.

다음은 멀티코어 프로세서와 인터럽트 처리에 관련된 컨트롤러의 연관 관계이다.

![image](https://user-images.githubusercontent.com/34773827/62428823-20a5ba00-b741-11e9-8906-94bb736b2ce5.png)

그림에서 알 수 있듯이 프로세서 내부에 있는 코어는 중앙처리장치(CPU, Central Processing Unit)와<br>로컬 APIC를 모두 개별적으로 가지고 있다.

<hr>

### 로컬 APIC

APIC ( Advanced Programmable Interrupt Controller)는 팬티엄4 프로세서부터 사용된 것으로,<br>멀티코어 프로세서가 등장하기 이전의 멀티프로세서용으로 등장한 인터럽트 컨트롤러였다.

이때 사용하던 APIC가 프로세서 내부나 코어 내부로 옮겨진 것이 바로 APIC이다.<br>로컬 APIC 컨트롤러는 주로 PIC 컨트롤러나 I/O APIC에서 전달하는 인터럽트를 처리한다.<br>로컬 APIC에는 인터럽트 라인을 연결할 수 있는 LINT0(Local Interrupt 0)핀과 LINT1 핀이 있어 직접 처리할 수 있다.

그리고 APIC 버스나 ICC 버스(Interrupt Controller Communication Bus)를 통해 I/O APIC로부터 인터럽트를 전달받아 처리할 수도 있다.

로컬 APIC의 인터럽트 처리 방식과 기존의 인터럽트 처리 방식과 다른 점은<br>태스크 우선순위 레지스터가 있어서 특정 벡터 범위만 선택하여 처리하는 것이 가능하다는 점이다.

기존에는 프로세서로 모든 인터럽트가 전달되었지만 로컬 APIC의 우선순위 레지스터를 사용하면 코어별로 인터럽트 벡터를 나누어 효율적으로 처리할 수 있다.

로컬 APIC는 외부 인터럽트를 처리하는 기능 외에 프로세서나 코어 간에 인터럽트를 생성하고 전달하는<br>IPI(Inter-processor Interrupt) 메시지 처리 기능도 포함하고 있다.

IPI 메시지는 프로세서나 코어가 임의로 생성할 수 있는 인터럽트로 다른 프로세서나 코어를 활성화하거나 특정 인터럽트 벡터를 실행시키는 데 사용한다. 그리고 프로세서가 코어가 동시에 특정 작업을 수행할 필요가 있을 때도 사용한다.

<hr>

### I/O APIC와 PIC 컨트롤러

PIC 컨트롤러는 하나의 프로세서로만 인터럽트를 전달할 수 있었기 때문에 멀티프로세서나 멀티코어 프로세서 환경에서 사용할 수가 없다. 

따라서 PIC 컨트롤러를 대체하면서 멀티프로세서도 지원할 수 있는 새로운 인터럽트 컨트롤러가 필요하다.

이것이 바로 I/O APIC 인데,<br>I/O APIC는 PIC 컨트롤러와 같이 외부의 인터럽트를 취합하며 로컬 APIC로 인터럽트를 전달한다.

I/O APIC는 APIC 버스나 ICC 버스를 통해 각 프로세서나 코어의 로컬 APIC와 연결되고 설정 값에 따라 인터럽트를 모든 로컬 APIC로 전달하거나 특정 로컬 APIC에만 전달할 수 있다.

그리고 I/O APIC는 24개의 인터럽트 라인을 동시에 처리할 수 있으며,<br>외부 디바이스의 인터럽트 라인을 직접 연결하거나 PIC 컨트롤러를 거쳐서 연결하는 것도 가능하다.

<hr>

## 인터럽트 모드와 싱글코어 프로세서 모드

멀티코어 프로세서 환경에서는 코어와 로컬 APIC, I/O APIC가 아주 복잡하게 얽혀 있지만,<br>부팅 과정에서는 마치 싱글코어 프로세서처럼 동작한다.

다시 말하면 아무리 많은 코어가 있다고 해도 기존 방식과 호환을 위해서는 PIC 컨트롤러를 거쳐서<br>BSP(Bootstrap Processor)로만 인터럽트를 전달해야 한다는 것이다.

여기서 문제가 있는데,<br>메인보드 제조사가 하나가 아니고 BIOS도 하나가 아니므로 각기 다른 방법을 사용해야 한다는 점이다.

인텔에서는 이러한 문제를 피하기 위해 가이드를 정했다.<br>인텔에서 제정한 Multiprocessor Specification v1.4 문서는 멀티프로세서 또는 멀티코어 프로세서 환경에서 BIOS와 OS가 담당해야 할 일을 정의하고 있으며, 그 중에 싱글코어 프로세서 처럼 설정하는 부분도 있다.

<hr>

싱글코어 프로세서처럼 동작하는 인터럽트 모드에는 PIC 모드와 로컬 APIC를 통한 가상 연결 모드,<br>I/O APIC를 통한 가상 연결 모드 세 가지가 있다. 

이 세 가지 모드는 우리가 직접 설정한 필요가 없으니 어떤 경로로 연결되는지만 살펴보자.

<hr>

### PIC 모드

PIC 모드 (PIC Mode)는 BSP에 PIC 컨트롤러의 인터럽트 라인을 직접 연결하는 방식이다.

이 방법은 로컬 APIC를 통하지 않기 때문에 싱글코어 프로세서의 인터럽트 처리 방식과 똑같이 동작한다.

인터럽트 중에서 마스크를 할 수 없는 NMI(Non-maskable Interrupt)도 코어와 직접연결되어 있으며,<br>IMCR(Interrupt Mode Configuration Register)를 통해서 인터럽트 연결 여부를 제어할 수 있다.

IMCR 레지스터는 I/O 포트 0x22에 0x70을 쓴 후 I/O 포트 0x23에 값을 쓰는 방식으로 제어할 수 있으며,<br>최하위 비트만 유효하다. Bit 0을 0으로 설정하면 로컬 APIC를 사용하지 않고 PIC 컨트롤러와 코어를 직접 연결함을 의미하고, 1로 설정하면 I/O APIC와 로컬 APIC를 통해서 연결함을 의미한다.

IMCR 레지스터는 BIOS가 PIC 모드를 지원하는 경우에만 존재하며 IMCR 레지스터 지원 여부는<br>MP 플로팅 포인터(MP Floating Pointer) 정보에서 찾을 수 있다.

PIC모드는 BSP의 CPU와 PIC컨트롤러만 활성화하면 되므로 나머지는 모두 비활성화나 대기상태로 만든다. 

다음 그림은 PIC 모드일 때 코어와 인터럽트 컨트롤러 간의 연결 관계를 표시한 것이다.

![image](https://user-images.githubusercontent.com/34773827/62429447-acbbdf80-b749-11e9-88a8-ae17cdff0b31.png)

<hr>

### 가상 연결 모드

가상 연결 모드 (Virtual Wire Mode)는 로컬 APIC를 통한 가상 연결 모드와 I/O APIC를 통한 가상 연결 모드로 나누어진다.

#### 로컬 APIC를 이용한 가상 연결 모드

로컬 APIC를 이용한 가상 연결 모드는 PIC 컨트롤러의 인터럽트 라인을 BSP의 CPU가 아닌 로컬 APIC에 연결한다.

NMI 인터럽트도 BSP의 로컬 APIC에 직접 연결하므로 PIC 모드에서 사용했던 IMCR 레지스터는 존재하지 않는다.

로컬 APIC에 전달된 인터럽트를 그대로 CPU의 INTR 핀으로 전달하려면 로컬 APIC의 LINT0 핀을 외부 인터럽트 모드로 설정한다. 핀의 타입을 외부 인터럽트 타입으로 설정하면 마치 PIC 컨트롤러가 CPU에 직접 연결된 것처럼 사용할 수 있다.<br>NMI도 마찬가지이다. LINT1 핀을 NMI 모드로 설정하면  로컬 APIC는 LINT1으로 전달된 인터럽트를 그대로 CPU의 NMI핀으로 전달한다.

로컬 APIC를 통한 가상 연결 모드는 BSP만 사용하므로 BSP의 CPU와 로컬 APIC를 제외한 나머지 부분은 비활성화 하거나 대기 상태로 만든다.

다음 그림은 로컬 APIC를 이용한 가상 연결 모드일 때 코어와 인터럽트 컨트롤러 사이의 연결관계이다.

![image](https://user-images.githubusercontent.com/34773827/62429432-84cc7c00-b749-11e9-9756-d1ed2484ebb0.png)

#### I/O APIC를 통한 가상 연결 모드

I/O APIC를 통한 가상 연결 모드는 로컬 APIC를 통한 가상 연결 모드와 거의 같고 차이점이라면<br>PIC 컨트롤러의 인터럽트를 I/O APIC를 통해서 전달한다는 것이다.

I/O APIC 역시 로컬 APIC와 마찬가지로 외부 인터럽트 모드를 지원한다.<br>따라서 PIC 컨트롤러가 연결된 라인으로 인터럽트가 전달되면 APIC 버스나 ICC 버스를 통해 BSP의 로컬 APIC로 그대로 전달할 수 있다.

NMI 부분은 로컬 APIC를 통한 가상 연결 모드와 같은 방식으로 로컬 APIC의 LINT1 핀을 NMI 모드로 설정하여 처리한다.

I/O APIC를 통한 가상 연결 모드는 BSP와 I/O APIC를 사용하므로 이를 제외한 나머지 코어는 대기 상태로 만든다.

다음 그림은 I/O APIC를 이용한 가상 연결 모드일 때 코어와 인터럽트 컨트롤러간의 연결관계이다.

![image](https://user-images.githubusercontent.com/34773827/62429519-af6b0480-b74a-11e9-9675-79a51226fd02.png)

<hr>

