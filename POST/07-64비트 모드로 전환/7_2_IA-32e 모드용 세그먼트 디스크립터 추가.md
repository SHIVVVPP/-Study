# IA-32e 모드용 세그먼트 디스크립터 추가

리얼 모드에서 보호 모드로 전환하려면 보호 모드용 세그먼트 디스크립터가 필요했듯이,<br>보호 모드에서 IA-32e 모드로 전환하기 위해서 IA-32e 모드용 세그먼트 디스크립터가 필요하다.

IA-32e 모드 커널을 위해 1MB 이상의 영역에 IA-32e 모드용 GDT를 새로 생성해도 되지만,<br>이미 보호 모드 커널 엔트리 포인트에 GDT를 생성했으므로 여기에 추가한다.

<hr>

## 보호 모드 커널 엔트리 포인트에 디스크립터 추가

IA-32e 모드 커널용 코드 디스크립터와 데이터 디스크립터를 생성하는 방법은 보호 모드와 거의 유사하다.

> 왜냐하면, IA-32e 모드의 세그먼트 디스크립터는 <br>보호 모드의 세그먼트 디스크립터와 거의 같은 크기와 필드로 되어있기 때문이다.

차이점이라면 IA-32e 모드에서는<br>디스크립터의 기준 주소와 세그먼트 크기 값에 상관 없이 64GB 전체 영역으로 설정된다는 것과,<br>세그먼트 디스크립터의 L 비트가 IA-32e 서브 모드 중 호환 모드나 64비트 모드를 선택하는 데 사용된다는 것이다.

![image](https://user-images.githubusercontent.com/34773827/60969586-db1ce980-a35a-11e9-803e-02ac4334486c.png)

우리는 IA-32e 모드의 서브 모드 중에서 64비트 모드를 사용할 것이므로,<br>보호 모드용 세그먼트 디스크립터를 기반으로 L 비트를 1로 D 비트를 0으로 설정하면 된다.

> D 비트를 0으로 설정하는 이유는  L 비트와 D 비트가 모두 1인 경우를 다른 목적으로 예약해 두었기 때문이다.
>
> QEMU 에서는 이를 확인하지 않지만,<br>실제 PC로 테스트 할 때 L 비트와 D 비트를 모두 1로 설정하면 리부팅 될수 있으니 주의해야 한다.



다음 코드는 보호 모드 엔트리 포인트 코드에 IA-32e 모드 커널용 코드 세그먼트 디스크립터와 데이터 세그먼트 디스크립터를 추가한 것이다.

> IA-32e 모드로 전화한 후에는 보호 모드용 세그먼트 디스크립터를 사용하지 않으므로 IA-32e 모드용 세그먼트 디스크립터를 앞쪽으로 배치한다.

```assembly
GDT:
	; 널(NULL) 디스크립터, 반드시 0으로 초기화 해야 한다.
	NULLDescriptor:
		dw 0x0000
		dw 0x0000
		db 0x00
		db 0x00
		db 0x00
		db 0x00
		
	; IA-32e 모드 커널용 코드 세그먼트 디스크립터
	IA_32eCODEDESCRIPTOR:
		dw 0xFFFF	; Limit [15:0]
		dw 0x0000	; Base [15:0]
		db 0x00		; Base [23:16]
		db 0x9A		; P=1, DPL=0, Code Segment, Execute/Read
		db 0xAF		; G=1, D=0, L=1, Limit[19:16]
		db 0x00		; Base [31:24]
		
	; IA-32e 모드 커널용 데이터 세그먼트 디스크립터
	CODEDESCRIPTOR:
		dw 0xFFFF	; Limit [15:0]
		dw 0x0000	; Base [15:0]
		db0x00		; Base [23:16]
		db 0x9A		; P=1, DPL=0, Code Segment, Execute/Read
		db 0xCF		; G=1, D=1, L=0, Limit[19:16]
		db 0x00		; Base [31:24]
		
	; 보호 모드 커널용 데이터 세그먼트 디스크립터
	DATADESCRIPTOR:
		dw 0xFFFF	; Limit [15:0]
		dw 0x0000	; Base [15:0]
		db 0x00		; Base [23:16]
		db 0x92		; P=1, DPL=0, Data Segment, Read/Write
		db 0xCF		; G=1, D=1, L=0, Limit [19:16]
		db 0x00		; Base [31:24]
```



<hr>

IA-32e 모드용 세그먼트 디스크립터가 보호 모드용 세그먼트 디스크립터의 앞에 있으므로,<br>보호 모드로 전환할 때 사용했던 세그먼트 셀렉터의 값을 변경해주어야 한다.

이전 장에서 보호 모드용 코드 세그먼트 디스크립터와 데이터 세그먼트 디스크립터가 0x08, 0x10에 있었지만,<br>IA-32e 모드용 코드와 데이터 디스크립터가 추가된 지금은 0x18, 0x20으로 바뀌었으므로 이를 적용해준다.

다음 코드는 보호 모드 커널 엔트리 포인트 파일(01.Kernel32/Source/EntryPoint.s)에서<br>세그먼트 디스크립터를 참조한 코드를 수정한 것이다.

```assembly
[ORG 0x00]
[BITS 16]

SECTION .text

START:
	... 생략 ...
	
	; 커널 코드 세그먼트를 0x00을 기준으로 하는 것으로 교체하고 EIP의 값을 0x00을 기준으로 재설정
	; CS 세그먼트 셀렉터 : EIP
	jmp dword 0x18:	(PROTECTEDMODE - $$ + 0x10000)
	
	
[BITS 32]
PROTECTEDMODE:
	mov ax, 0x20	; 보호 모드 커널용 데이터 세그먼트 디스크립터를 AX 레지스터에 저장
	mov ds, ax
	mov es, ax
	mov fs, ax
	mov gs, ax
	
	... 생략 ...
	
	jmp dword 0x18: 0x10200	; C 언어 커널이 존재하는 0x10200 어드레스로 이동하여
							; C 언어 커널 수행
```

이제 IA-32e 모드 커널용 세그먼트 디스크립터가 준비되었다. <br>다음 단계로 페이징을 활성화하여 IA-32e 모드로 전환한다.