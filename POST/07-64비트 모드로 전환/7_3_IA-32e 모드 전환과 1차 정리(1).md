# IA-32e 모드 전환과 1차 정리

이제 실제 코드를 작성하여 IA-32e 모드로 전환해보고 IA-32e 모드 커널로 들어가기 전에 코드를 정리하겠다.

<hr>

## 물리 메모리 확장 기능 활성화와 페이지 테이블 설정

물리 메모리 확장(PAE, Physical Address Extensions) 기능은 CR4 레지스터의 PAE 비트(비트 5)가 담당하며,<br>PAE 비트를 1로 설정해서 물리 메모리 확장 기능을 사용할 수 있다.

프로세서에 페이지 테이블을 설정하려면 CR3 레지스터에 PML4 테이블의 어드레스를 저장하면 된다.

다음은 CR3 레지스터와 CR4 레지스터를 조작하여 페이지 테이블을 설정하고<br>물리 메모리 확장 기능을 활성화 하는 코드이다.

```assembly
; CR4 컨트롤 레지스터의 PAE 비트를 1로 설정
mov eax, cr4	; CR4 컨트롤 레지스터의 값을 EAX 레지스터에 저장
or eax, 0x20	; PAE 비트(비트 5)를 1로 설정
				; PAE 비트는 CR4 레지스터의 비트 5에 위치하므로,
				; 해당 비트를 1로 설정하려고 0x20(00100000)을 or 연산한다.
mov cr4, eax	; PAE 비트가 1로 설정된 값을 CR4 컨트롤 레지스터에 저장
	
; CR3 컨트롤 레지스터에 PML4 테이블의 어드레스 및 캐시 활성화
mov eax, 0x100000	; EAX 레지스터에 PML4 테이블이 존재하는 0x100000(1MB)를 저장
	; 캐시 기능을 활성화해야 하므로 PCD 비트와 PWT 비트를 모두 0으로 설정하고,
	; PML4 테이블이 어드레스 0x100000(1MB)에 있으므로,
	; CR3 레지스터에 0x100000을 설정한다.
mov cr3, eax		; CR3 컨트롤 레지스터에 0x100000(1MB)를 저장
```

<hr>



## 64비트 모드 활성화와 페이징 활성화

IA-32e 모드를 활설화하는 최종 관문은 IA32_EFER 레지스터의 LME 비트를 1로 설정하는 작업이다.

IA32_EFER 레지스터의 비트를 활성화 하지 않으면,<br>IA-32e 모드용 세그먼트 레지스터로 교체한다 해도 32비트 보호 모드로 동작한다.

<hr>

#### IA32_EFER 레지스터의 기본 내용과 MSR 레지스터

IA32_EFER 레지스터는 범용 또는 컨트롤 레지스터가 아니며, MSR(Model-Specific Register)라고 불리는 특수한 용도의 레지스터이다.

MSR 레지스터는 프로세서 모델에 따라 특수하게 정의된 레지스터로<br>크기는 64비트이며 각 모델에 따라 차이가 있다.

MSR 레지스터의 종류에는 크게 6가지가 있다.

- 디버깅 및 성능 측정(Debugging And Performance Monitoring)
- 하드웨어 에러 검사(Machine-Check)
- 메모리 범위와 메모리 타입 설정(Memory Type Range Register, MTRRs)
- 온도와 전력 관리(Thermal And Power Management)
- 특수 명령어 지원(Instruction-Specific Support)
- 프로세서 특성과 모드 지원(Processor Feature/Mode Support)

IA-32e 모드 전환에 사용할 IA32_EFER(Extended Feature Enable Register) 레지스터는 프로세서 특성과 모드 지원에 속하는 MSR 레지스터로 프로세서의 확장 기능을 제어할 수 있는 레지스터이다.

IA32_EFER 레지스터로 제어할 수 있는 항목에는 

- SYSTEMCALL/SYSRET 사용
- IA-32e 모드 사용
- Execute Disable(EXB)

등이 있으며 제어 기능 외에 현재 운영중인 모드가 IA-32e 모드인지 확인하는 기능도 포함하고 있다.

MSR 레지스터는 개별적으로 할당된 레지스터 어드레스가 있고 해당 어드레스를 통해서만 접근할 수 있다.<br>또 다른 레지스터와 달리 데이터 이동 명령 (mov)으로 접근할 수 없으며,<br>MSR 레지스터용 명령인 RDMSR(Read From Model Specific Register)과 WRMSR(Write To Model Specific Register)를 사용해야 한다.

RDMSR 명령어는 MSR 레지스터에서 값을 읽어오는 역할을 하며, ECX와 EDX, 그리고 EAX 레지스터를 사용한다.

> ECX 레지스터에 읽을 MSR 레지스터 어드레스를 넘겨주면,<br>MSR 레지스터의 상위 32비트는 EDX 레지스터에 하위 32비트는 EAX 레지스터에 저장해준다.

WRMSR 명령어는 MSR 레지스터에 값을 쓰는 역할을 한다.

> ECX 레즈스터에 쓸 MSR 레지스터 어드레스를 넘겨주면,<br>상위 32비트는 EDX 레지스터의 값으로 하위 32비트는 EAX 레지스터의 값으로 MSR 레지스터에 저장해준다.

우리가 사용할 IA32_EFER 레지스터는 0xC0000080 어드레스에 있고 다음 표와 같이 구성된다.

![image](https://user-images.githubusercontent.com/34773827/61019836-8dde5d80-a3d6-11e9-9d94-5adf242024e4.png)

<hr>

#### LME 비트를 1로 설정하는 코드 ( IA-32e 모드 활성화 )

```assembly
; IA-32EFER.LME 를 1로 설정하여 IA-32e 모드를 활성화
mov ecx, 0xC0000080	; IA32_EFER MSR 레지스터의 어드레스를 저장
					; IA32_EFER 레지스터의 어드레스가 0xC0000080 이므로
					; ECX 레지스터에 설정하여 RDMSR 명령으로 접근한다.
rdmsr				; MSR 레지스터를 읽기

or eax, 0x0100		; EAX 레지스터에 저장된 IA32_EFER MSR의 하위 32비트에서
					; LME 비트가 비트 8에 있으므로 0x0100을 OR 하여
					; LME 비트(비트 8)을 1로 설정
wrmsr				; MSR 레지스터에 쓰기
```

<hr>



## IA-32e 모드로 전환과 세그먼트 셀렉터 초기화

IA-32e 모드로 전환하는 마지막 작업은 CR0 레지스터를 변경하여 캐시와 페이징을 활성화하고서<br>세그먼트 셀렉터를 IA-32e 커널용으로 교체하는 것이다.

<hr>

이전 장에서 초기화한 페이지 테이블의 PCD 비트와 PWT 비트는 페이징을 활성화 했을 때만 유효하다.

x86 계열의 프로세서에는 페이지의 캐시 설정보다 우선하는 캐시 관련 비트가 있으며,<br>그것은 CR0 컨트롤 레지스터의 NW 비트(비트 29) CD 비트(비트 30)이다.

NW 비트와 CD 비트는 각각 Not Write-thorugh와 Cache Disable의 약자로,<br>캐시를 사용하려면 두 비트 모두 0으로 설정해야 한다.

>  CR0 컨트롤 레지스터의 CD 비트를 1로 설정하여 캐시를 비활성화 했다면,<br>페이지 테이블에 있는 PCD 비트와 PWT 비트가 캐시를 사용하게 설정되었다 해도 무시된다.



다음은 CR0 레지스터를 변경하여 페이징을 활성화하고 <br>IA-32e 모드로 전환하여 세그먼트 셀렉터를 초기화하는 코드이다.

```assembly
; CR0 컨트롤 레지스터를 NW 비트(비트 29) = 0, CD 비트(비트 30) = 0, PG 비트(비트 31) = 1 로
; 설정하여 캐시 기능과 페이징 기능을 활성화
mov eax, cr0
or eax, 0xE0000000
xor eax, 0x60000000
mov cr0, eax

jmp 0x08:0x200000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	0x200000(2MB) 어드레스에 위치하는 코드
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[BITS 64]
; 기타 세그먼트 셀렉터를 IA-32e 모드용 데이터 세그먼트 디스크립터로 교체
mov ax, 0x10
mov ds, ax
mov es, ax
mov fs, ax
mov gs, ax

; 스택을 0x600000 ~ 0x6FFFFF 영역에 1MB 크기로 설정
mov ss, ax
mov rsp, 0x6FFFF8
mov rbp, 0x6FFFF8

... 생략 ...
```

지금까지 IA-32e 모드로 전환하기 위한 모든단계에 대해 알아보았다.

이제 IA-32e 모드 커널을 준비하고 OS 이미지에 통합하면 모든 작업이 끝난다.