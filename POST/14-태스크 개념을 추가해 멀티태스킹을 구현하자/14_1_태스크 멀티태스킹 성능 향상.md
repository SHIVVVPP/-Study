# 태스크, 멀티태스킹, 성능 향상

멀티태스킹의 원리와 장단점을 중심으로 살펴보자.

<hr>

## 태스크, 콘텍스트, 스택

**태스크는 프로세서의 관점에서 개별적으로 수행할 수 있는 작업을 의미한다.**

개별적으로 처리할 수 있다는 의미는 태스크마다 프로세서 상태가 독립적이라는 말과 같다.

콘텍스트는 실행 중인 프로세서의 상태, **즉 모든 레지스터를 저장하고 있다.**<br>따라서, 각 태스크마다 개별적인 콘텍스트만 보장한다면 여러 개의 태스크를 동시에 실행해도 서로 간섭 없이 처리할 수 있다.

하지만 태스크를 완전히 독립시키려면 프로세서의 상태,<br>즉 콘텍스트를 개별적으로 할당하는 것만으로는 부족하다.

> x86 프로세서 계열은 코드 실행 시,<br>임시 데이터나 복귀 어드레스와 같은 데이터를 스택에 저장하기 때문이다.
>
> 아무리 독립적인 콘텍스트를 보장한다 해도 스택이 구분되지 않으면,<br>다른 태스크로 인해 스택의 내용이 변경되어 문제가 발생한다.

한편, 태스크에 의존적인 정보를 저장하는 콘텍스트나 스택과 달리<br> 코드와 데이터는 쓰임에 따라 공통으로 사용될 수 있다.

> 만약 여러 태스크가 같은 코드를 수행한다면,<br>굳이 코드를 태스크마다 복사할 필요 없이 공유하면 된다.
>
> 또한 여러 태스크가 협업하여 결과를 도출해야 하는 경우 각 태스크의 결과를 취합하거나 협업을 중계할 자료구조가 필요하므로 데이터를 공유하는 것이 유리하다.

<hr>

### 태스크, 코드와 데이터, 그리고 콘텍스트와 스택의 관계

다음 그림은 앞서 설명한 태스크와 코드 및 데이터, 그리고 콘텍스트와 스택의 관계를 나타낸 것이다.

태스크 2와 3은 같은 코드와 데이터를 공유하며, 태스크 1과는 별도의 메모리에 위치한다.

코드와 데이터는 태스크 2와 3이 공유하지만, 콘텍스트와 스택은 구분되어 있는 것을 알 수 있다.

![image](https://user-images.githubusercontent.com/34773827/61393602-48e98800-a8fc-11e9-926b-efd0b4ce6ae3.png)

<hr>



## 멀티태스킹과 성능 향상

멀티태스킹은 싱글 코어 프로세서(*Single-core Processor*) 시절부터 사용된 기법으로,<br>여러 개의 태스크를 동시에 실행하는 기능을 말한다.

실제로 하나의 코어는 여러 개의 태스크를 동시에 실행할 수 없으므로 특정 시점에서 실행되는 태스크는 코어당 하나이지만, 아주 짧은 주기마다 혹은 특정 이벤트가 발생할 때마다 다른 태스크로 전환함으로써 마치 여러 태스크를 동시에 수행하는 것 처럼 동작한다.

> 프로세서(*Processor*)는 패키지 형태로 출시된 칩(*Chip*)을 의미하고,<br>코어(*Core*)는 프로세서에 들어있는 CPU(*Central Processing Unit*)를 의미한다.
>
> 따라서 싱글 코어 프로세서는 프로세서당 코어가 하나씩 존재 했던 과거의 프로세서를 말하며,<br>멀티코어 프로세서는 프로세서당 2개 이상의 코어가 존재하는 현대의 프로세서를 말한다.

대부분의 OS가 택하고 있는 시분할 멀티태스킹(*Time-Sharing Multitasking*) 기법은 PIT 컨트롤러를 수 밀리세컨드(*Millisecond*, 10의 -3승)에서 수십 밀리 세컨드의 아주 짧은 주기로 설정하여, IRQ 0 인터럽트에 맞추어 태스크를 전환하는 기법이다.

시분할 멀티태스킹 기법은 프로세서 사용 시간을 할당하고 해당 시간이 지나면 강제로 다른 태스크로 전환하므로 다수의 태스크가 골고루 실행된다는 장점이 있다.

> 멀티태스킹 기법은 태스크에 할당된 프로세서 시간이 지났거나 특정 이벤트가 발생했을 때 강제로 태스크를 전환할 수 있는가에 따라 다시 **선점방식** 과 **비선점 방식** 으로 나눌 수 있다.
>
> 선점(*Preemptive*) 방식은<br>태스크를 강제로 전환하는 방식이며, 이러한 강제성 때문에 더 안정적으로 멀티태스킹을 수행할 수 있다는 장점이 있다. 하지만 어느 시점에서 강제로 태스크가 전환될지 예측할 수 없으므로 구현하기 까다롭다.
>
> 비선점(*Non-preemptive*) 방식은<br>선점 방식과 달리 태스크 전환 여부를 태스크 스스로가 판단한다.<br>태스크가 전환 시점을 판단하므로 코드가 효율적으로 작성되었다면 선점으로 인한 불필요한 태스크 전환을 피할 수 있다는 장점이 있다.<br>하지만 태스크가 프로세서를 독점하는 경우 시스템 전체 성능이 저하되는 문제가 있어서 유저 어플리케이션용 스레드 라이브러리에 일부 사용된다.
>
> 멀티태스킹을 지원하는 대부분의 OS는 시스템의 안정성을 위해 선점 방식을 주로 사용한다.

<hr>

### 멀티태스킹 사용 이유

멀티태스킹 기법을 사용하면 태스크를 수행하는데 필요한 시간에 태스크를 전환하는 시간이 추가되므로<br>단순한 덧셈으로 완료 시간을 계산하면 태스크의 전환 없이 순차적으로 처리하는 것보다 더 느리다.<br>그럼에도 불구하고 멀티태스킹 기법을 사용하는 이유는 두 가지 이다.

#### 응답시간이 빨라진다.

응답 시간은 사용자가 데이터를 입력한 후 첫 번째 결과가 나올 때까지 걸리는 시간이다.<br>이는 사용자 입력에 따른 반응속도라고 볼 수 있으며, 응답 시간이 짧을수록 사용자의 체감 속도는 빨라진다.

응답시간이 빠르다는 장점은 GUI 시스템에서 더욱 빛을 발한다.<br>GUI 환경에서는 각 태스크의 진행 상황을 윈도우를 통해 한 눈에 볼 수 있기 때문에 각 태스크의 결과가 빨리, 그리고 자주 표시될수록 사용자의 작업 처리 속도도 빨라진다.

이해를 돕기 위해 0이라는 시점에 A,B,C 순으로 세 가지 태스크가 입력되고,<br>작업을 완료하는데 프로세서가 각 4, 2, 1만큼 필요한 경우를 생각해 보자.

작업을 순차적으로 처리한다면 A, B, C의 순으로 작업을 처리하므로 시간이 4, 6, 7만큼 지나야 작업이 완료된다.

이때 A 태스크는 대기 시간이 없이 바로 실행되므로 응답시간은 0이다.

하지만 B태스크는 A태스크가 끝난 뒤에 실행되므로 응답시간은 4, C 태스크는 6이된다.

그리고 각 태스크가 실행될 때까지 대기한 시간을 보면 A 태스크는 바로 실행되므로 0,<br>B 태스크는 A가 끝나길 기다리므로 4, C 태스크는 모두 기다리므로 6이된다.

태스크 대기한 시간을 모두 합하면 10이며 태스크가 대기하는 시간이 길수록 체감속도가 떨어진다.

< 일괄 처리 방식으로 태스크를 처리할 때 태스크의 완료 시점과 대기 시간 >

![image](https://user-images.githubusercontent.com/34773827/61395925-86044900-a901-11e9-91de-a07f77dfe1d1.png)

이것을 시분할 멀티태스킹 기법으로 A, B, C의 순으로 공평하게 프로세서를 1씩 할당해보자.

태스크를 전환 시간은 태스크를 실행하는 시간에 비해 무척 짧기 때문에 태스크 실행 시간만을 고려하자.

멀티태스킹을 사용하면 태스크  A, B, C의 순으로 1씩 실행하므로 A는 0, B는 1, C는 2만큼 지난 뒤에 벌써 진행상황을 표시하기 시작한다. 그리고 프로세서를 가장 적게 사용하는 C 태스크는 프로세서를 할당받은 뒤 3시점에서 수행이 끝나며, 이후에는 A와 B만이 교대로 실행된다.

A와 B가 수행될 때도 프로세서는 1씩 할당되므로 결과적으로 B 태스크와 A 태스크의 순으로 각각 5와 7시점에서 실행이 완료된다.

< 멀티태스킹 방식으로 태스크를 처리할 때 태스크의 완료 시점과 대기 시간 >

![image](https://user-images.githubusercontent.com/34773827/61396406-a1238880-a902-11e9-9e02-ef70f838a7a6.png)

그림을 보면 A, B, C 태스크가 각각 0, 1, 2시간이 지난 후 실행되므로,<br>응답 시간의 관점에서 일괄 처리 방식보다 더 좋다.

비록 프로세서를 1씩 나누어 사용하기 때문에 대기 시간이 중간 중간 포함되지만,<br>모든 태스크가 동시에 실행되는 것처럼 표시되니 작업 상태를 확인하기가 훨씬 편리하다.

그리고 태스크가 프로세서를 얻기까지 대기한 시간도 순차적으로 처리했을 때 대기 시간이 10이고 멀티태스킹을 사용했을 때 대기 시간이 8이므로 더 짧다.

태스크 완료 시점 역시 프로세서를 적게 사용하는 C 태스크와 B 태스크의 완료시점이 일괄처리보다 빠르다.

이는 프로세서를 적게 사용하는 태스크가 빨리 완료될 수 있다는 것을 뜻한다.

#### 태스크가 주어진 시간을 활용하여 전체적인 처리량을 높인다.

멀티태스킹을 사용하는 두번째 이유는 태스크가 주어진 시간 동안 프로세서를 100% 활용하는 것이 아니므로, 이 시간을 활용하여 전체적인 처리량을 높이려는 것이다.

이는 태스크가 수행하는 작업의 특성과 관계가 있다.

태스크는 작업의 특성에 따라 **CPU 중심의 태스크** 와 **I/O 중심의 태스크** 두가지로 나뉜다.

CPU 중심의 태스크(*CPU-bound Task*)는 계산을 주로 하는 태스크를 말하며,<br>주어진 시간 동안 쉴 새 없이 프로세서를 사용한다.

반면, I/O 중심의 태스크(*I/O-bound Task*)는 하드 디스크나 키보드/마우스와 같이 주로 외부 컨트롤러나 디바이스에 입출력하는 태스크를 말하며, 프로세서를 많이 사용하지 않는다.

외부 컨트롤러나 디바이스는 프로세서에 비하면 아주 느리게 동작하므로 I/O 를 요청한 뒤 완료될 때까지 꽤나 오랜 시간을 대기해야 한다. 이때 멀티태스킹 기법을 사용하면 대기하는 시간 동안 다른 태스크를 실행할 수 있으므로 태스크의 대기 시간이 전체적으로 줄어들고 작업 처리량도 늘어난다.