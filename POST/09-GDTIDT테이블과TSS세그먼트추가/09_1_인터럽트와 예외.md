# 인터럽트와 예외

## 인터럽트와 예외의 차이점

인터럽트와 예외의 공통점은<br>코드 수행 도중에 발생하거나 프로세서에 의해 처리가 필요한 일종의 이벤트라는 것이다.

- 인터럽트

  키보드, 마우스 같은 외부 디바이스에 의해 발생하여 프로세서에 전달되는 이벤트이다.

- 예외

  프로세서가 코드를 수행하는 도중에 페이지 폴트나 잘못된 명령 같은 오류를 발견했을 때 발생한다.

이벤트가 인터럽트에 의해 발생했든 예외에 발생 하였든 상관없이<br>이벤트 별로 특수한 처리 함수가 필요하다.

**이런 처리 함수를 인터럽트 또는 예외 핸들러라고 부른다.**



< 인터럽트와 예외 발생 시점의 처리 과정 >

![image](https://user-images.githubusercontent.com/34773827/61179799-f9c5fd80-a644-11e9-922d-afea93676ed7.png)

<hr>



## IDT와 IDT 게이트 디스크립터

외부 인터럽트나 소프트웨어 인터럽트(SWI)가 발생 했을 때<br>벡터 테이블의 인덱스에 해당하는 어드레스로 이동하여 처리 함수를 수행한다.

벡터 테이블은 각 운영 모드마다 존재하는데

- 리얼모드

  리얼 모드의 벡터 테이블은 세그먼트:어드레스의 형태로 0x0000:0x0000에 위치한다.

- 보호모드와 IA-32e 모드

  이와 달리 IDT라고 불리는 특수한 형태의 벡터 테이블을 사용한다.



IDT는 GDT와 마찬가지로 IDT 게이트 디스크립터로 구성된 테이블이며,<br>IDTR 레지스터를 통해 프로세서에 IDT 테이블의 정보를 설정할 수 있다.

> IDT 테이블은 최대 256개의 엔트리를 포함할 수 있고,<br>IA-32e 모드의 IDT 게이트 디스크립터는 16바이트를 차지한다.



< IDT 테이블과 IDTR 레지스터, 인터럽트와 예외 핸들러의 관계 >

![image](https://user-images.githubusercontent.com/34773827/61179964-fe8cb080-a648-11e9-80f4-68bfb3358e2d.png)

<hr>

IDT 게이트 디스크립터는

- 인터럽트
- 예외처리 함수의 어드레스
- 코드 세그먼트 셀렉터
- 게이트 디스크립터 타입
- 권한

같은 여러 정보를 포함하고 있다.

< IA-32e 모드의 IDT 게이트 디스크립터 구조 >

![image](https://user-images.githubusercontent.com/34773827/61179954-d8ffa700-a648-11e9-9b7c-c7ed0a1ecc4e.png)

< IDT 게이트 디스크립터의 필드와 의미 >

- 핸들러 오프셋
  - 인터럽트 또는 예외 핸들러의 엔트리 포인트
  - 64비트 크기
- 세그먼트 셀렉터
  - 인터럽드 또는 예외 핸들러 수행 시 사용할 코드 세그먼트 디스크립터
- IST
  - 인터럽트나 예외 발생 시, 사용할 스택 어드레스(Top)
  - 0이 아닌 값으로 설정하면 인터럽트 발생 시 강제로 스택을 교환한다.
- 타입
  - IDT 게이트의 종류
    - 0110 : 인터럽트 게이트
    - 0111 : 트랩 게이트
  - 인터럽트 게이트로 설정하면 핸들러를 수행하는 동안 인터럽트가 발생하지 못하며,<BR>트랩 게이트로 설정하면 다른 인터럽트 발생 가능하다.
- DPL
  - Descriptor Privilege Level의 약자로 해당 디스크립터를 사용하는 데 필요한 권한을 의미한다.
  - 0(Highest) ~ 3(Lowest)의 범위를 가진다.
  - CPL나 RPL과 조합되어 접근 권한을 제한하는 데 사용된다.
- P
  - Present의 의미로 현재 디스크립터가 유효한 디스크립터인지 표시
  - 1로 설정하면 유효한 디스크립터임을 나타내며,<br>0으로 설정하면 유효하지 않은 디스크립터임을 나타낸다.

<hr>

IDT 게이트 디스크립터는 다른 디스크립터와 달리 세그먼트 셀렉터를 포함한다.

이 세그먼트 셀렉터는 인터럽트 또는 예외 핸들러가 수행될 때 코드 세그먼트를 교체하여<br>핸들러 함수를 수행하는데 충분한 권한(Privilege Level)으로 상승시키는 역할을 한다.

> 핸들러 실행을 위해 권한을 상승시켜야 하는 이유는
>
> 일반적으로 유저 레벨은 특권 레벨이 가장 낮고 커널 레벨은 가장 높다.<br>프로세서는 높은 레벨(커널 레벨, Ring 0)에서 낮은 레벨(유저 레벨, Ring 3)의 역역을 접근하는 것은 허락하지만 반대의 경우는 허락하지 않는다.
>
> 따라서 유저 레벨의 어플리케이션 코드를 실행하는 도중 인터럽트 또는 예외가 발생할 경우,<br>커널 영역에 있는 핸들러를 실행하면 권한 문제로 오류가 발생한다.
>
> 이 문제를 해결하기 위해 게이트 디스크립터의 세그먼트 셀렉터에 커널 레벨의 코드 디스크립터를 설정하고, 프로세서가 인터럽트 또는 예외 발생 시 자동으로 코드 세그먼트 셀렉터를 교체하는 방법을 사용한다.



IST는 IA-32e 모드에서 도입된 새로운 개념으로, 보호 모드에서는 지원하지 않는 기능이다.<br>IST는 인터럽트 스택 테이블(Interrupt Stack Table)의 약자로 인터럽트나 예외가 발생했을 때 별도의 스택 공간을 할당하는 기능이다.

> 별도의 스택 공간을 할당하는 이유는 핸들러를 수행하던 도중 스택 공간이 부족하여 코드나 데이터 영역을 덮어쓰는 것을 막기 위해서이다.

이 방식의 특징은 인터럽트나 예외가 발생했을 때,<br>핸들러 수행 전에 IST 필드에 지정된 스택 어드레스로 자동으로 전환한다. 

태스크가 사용하던 스택을 그대로 사용하는 것이 아니라 완전히 새로운 스택에서 처음부터 시작함으로써<br>핸들러 수행에 필요한 충분한 크기의 스택을 할당하는 것이다.

> 스택 부족으로 발생하는 문제를 해결할 수 있다.

<hr>



## 인터럽트와 예외의 종류

x86 프로세서는 IDT 테이블의 상위 32개 디스크립터를 예약해서 예외처리에 사용한다.<br>그 중에서 실제로 사용하는 것은 20개이며, 나머지 12개는 앞으로의 사용을 위해 미리 예약한 영역이다.

> 예외 처리에 할당한 0 ~ 31 번을 제외한 나머지 224개는 OS가 임으로 사용할 수 있는 부분이다.
>
> 이 부분은 일반적으로 인터럽트 처리와 애플리케이션 라이브러리 지원을 위한 시스템 콜 용도로 사용된다.



프로세서가 사용하는 20개의 예외는 다시 **Fault, Traps, Aborts** 세 가지로 분류할 수 있다.

- **Faults**

  Faults는 문제가 발생했으나 해당 코드의 문제를 수정하면 정상적으로 실행 가능한 예외를 의미한다.

- **Traps**

  Trap을 유발하는 명령어를 실행했을 때 발생하며,<br>디버깅 명령어와 깊은 관계가 있다.

- **Aborts**

  Aborts는 심각한 문제가 발생하여 문제가 발생한 정확한 어드레스를 찾을 수 없으며,<br>더 이상 코드를 수행할 수 없는 경우에 발생한다.



< 보호 모드, IA-32e 모드의 예외와 인터럽트 목록 >

![image](https://user-images.githubusercontent.com/34773827/61180224-6c87a680-a64e-11e9-9fb7-2d664cac9d77.png)

위 표는 인텔에서 정의한 32개의 예외와 인터럽트 목록이다.

목록을 보면 몇 가지 특이한 점을 발견할 수 있는데,<br>예외가 반환하는 에러 코드와 벡터 2에 자리 잡고 있는 NMI Interrupt가 그중 하나이다.

에러 코드는 예외가 발생했을 때의 상태를 나타내는 코드로 스택의 최상위(Top)에 위치한다.<br>에러 코드가 포함된 예외의 경우 핸들러 함수는 스택에서 에러 코드를 제거하는 작업이 필요하다.

> 벡터 2에 있는 NMI Interrupt는 프로세서에 연결된 NMI 핀(Nonmaskable Interrupt Pin)으로 전달되는 인터럽트를 의미하며, 프로세서에 직접 전달되는 인터럽트인 만큼 프로세서 외부에서 심각한 장애가 발생했을 때 발생한다.

<hr>





## PC 인터럽트의 종류와 발생 원인

과거의 PC는 PIC(Programmable Interrupt Controller) 컨트롤러를 사용해서 외부 인터럽트를 관리했다.

PIC 컨트롤러 한 개에는 8개의 인터럽트 핀이 있으며, PC는 PIC 컨트롤러 2개를 마스터-슬레이브 방식으로 연결해 최대 15개의 외부 인터럽트를 처리했다.

비록 IRQ 번호는 0번부터 15번가지 고정되어 있지만 인터럽트 벡터까지 0번부터 15번으로 고정된 것은 아니다.

PIC 컨트롤러의 경우 프로세서로 전달하는 인터럽트 벡터를 임의로 설정할 수 있기 때문이다.

우리 OS는 32개의 예외에 이어 IRQ용 인터럽트 벡터를 할당하여,<br>벡터 32번부터 47번가지를 사용한다.



