# 인터럽트와 예외, 스택과 태스크 상태 세그먼트

인텔 프로세서는 인터럽트나 예외가 발생했을 때 <br>이를 처리한 후 다시 코드로 복귀할 수 있는 메커니즘을 제공하며,<br>여기서 핵심적인 역할을 하는 것이 바로 스택과 스택 스위칭이다.

<hr>

## 스택 스위칭과 IST

### 스택 스위칭

x86 프로세서는 인터럽트나 예외가 발생했을 때,<br>IDT 게이트 디스크립터에 설정된 코드 디스크립터의 권한이 현재 수행 중인 코드의 권한보다 높다면<br>새로운 스택으로 전환한다. 이러한 과정을 **스택 스위칭(Stack Switching)** 이라고 한다.

스택 스위칭을 하는 이유는 크게 두 가지이다.

1. **높은 권한 코드, 즉 핸들러가 스택 공간의 부족으로 오류가 발생하는 일을 방지한다.**

   유저 애플리케이션의 함수와 달리 높은 권한을 가지는 커널 영역의 함수들은<br>한 프로그램에 국한 되는 것이 아니라 시스템 전체에 영향을 준다.

   커널 함수를 수행하다 스택 부족으로 오류가 발생한다면, 그영향은 시스템 전체로 퍼진다.

2. **권한이 높은 함수가 낮은 권한의 스택을 공유함으로써 발생할 수 있는 간섭의 최소화**

   커널 레벨의 함수는 애플리케이션 함수보다 견고하게 작성되지만, 버그에서 완전히 벗어나지 못한다.

   따라서 스택을 공유한다면 커널 함수의 버그로 스택의 내용이 변조 될 수 있으며,<br>실행 중이던 코드로 복귀했을 때 정상적으로 수행되지 않을 수도 있다.

<hr>

### IST (*Interrupt Stack Table*)

보호모드도 스택 스위칭 기능을 지원하지만, 권한이 변경되어야만 스택 스위칭이 발생한다.

이는 최상위 권한을 가지는 커널 코드를 실행하다가 인터럽트가 발생하면<br>권한의 변동이 없으므로 스택이 스위칭 되지 않음을 의미한다.

IA-32e 모드에서는 이러한 문제를 해결하기 위해 **인터럽트 스택 테이블(IST, Interrupt Stack Table)** 이라는 새로운 기능을 도입했다.

**IST는 인터럽트 처리를 위한 스택을 정의한 테이블로 최대 7개의 스택을 지정할 수 있다.**

IST를 사용하면 기존의 스택 스위칭 기법과는 달리 무조건 스택 스위칭이 발생한다.<br>이를 통해 커널 코드 수행 중에 인터럽트나 예외가 발생했을 대 스택 부족으로 인한 문제를 해결할 수 있다.

> 우리 OS역시 IST를 사용하여 커널 스택 영역 이후 7MB ~ 8MB 영역을 IST 공간으로 할당한다.

<hr>

#### IST 스택을 사용하도록 설정하는 방법

인터럽트나 예외 벡터에서 IST 스택을 사용하도록 설정하는 방법은 아주 간단한데<br>IDT 테이블의 해당 게이트 디스크립터를 찾아 IST 필드를 1 ~ 7 사이의 값으로 설저어하면 된다.

> IST 필드를 0으로 정하면 기존의 스택 스위칭 방식을 사용한다.

<hr>

##### 다시 수행중이던 코드로의 복귀

![image](https://user-images.githubusercontent.com/34773827/61181112-71ebed80-a65c-11e9-9cec-abed9499ba4f.png)

그림을 보면 인터럽트 또는 예외가 발생했을 때<br>핸들러의 스택에서 수행 중이던 코드의 정보(CS와 RIP 레지스터)와 스택의 정보(SS와 RSP 레지스터)가 삽입된다.

이런 정보와 함께 프로세서의 플래그 레지스터(RFLAGS)를 저장하기 때문에 핸들러가 수행을 완료하고 나서 코드로 복귀했을 때 코드가 정상적으로 수행될 수 있다.

<hr>



## 프로세서와 태스크 상태 세그먼트, 태스크 디스크립터

**태스크 상태 세그먼트(TSS, *Task Status Segment*)** 는 태스크의 상태를 저장하는 영역으로,<br>프로세서의 상태, 즉 레지스터의 값을 저장하는 역할을 한다.

보호 모드의 TSS는 FPU에 관련된 레지스터를 제외한 프로세서의 모든 레지스터를 저장할 수 있으며,<br>하드웨어 멀티 태스킹 구현에서 핵심 역할을 맡는다.

또한 권한별 스택 정보를 저장하는 역할과 유저 애플리 케이션이 I/O 포트에 접근하는 것을 제한하는<br>I/O 맵 어드레스의 주소를 지정하는 역할도 같이 수행한다.

< 보호 모드의 TSS 세그먼트 구조 >

SS와 ESP 뒤에 붙은 숫자는 특권 레벨을 의미한다.

[![tss 세그먼트 구조에 대한 이미지 검색결과](https://t1.daumcdn.net/cfile/tistory/2436224A53FF29F122)](https://www.google.co.kr/url?sa=i&rct=j&q=&esrc=s&source=images&cd=&cad=rja&uact=8&ved=2ahUKEwi_h9_u_7PjAhVrKqYKHSUKCEoQjRx6BAgBEAU&url=%2Furl%3Fsa%3Di%26rct%3Dj%26q%3D%26esrc%3Ds%26source%3Dimages%26cd%3D%26ved%3D%26url%3Dhttps%3A%2F%2Fkcats.tistory.com%2F170%26psig%3DAOvVaw07UEmwAcIQ5whQjdMZzCt6%26ust%3D1563179572493198&psig=AOvVaw07UEmwAcIQ5whQjdMZzCt6&ust=1563179572493198)

<hr>

IA-32e 모드로 옮겨가면서 레지스터의 크기가 커지며 기존의 104바이트로는 모든 레지스터를 담을 수 없다.

하드웨어 멀티태스킹에서 저장소 역할을 하던 TSS가 제 역할을 못하게 되었기 때문에<br>IA-32e 모드에서는 더 이상 하드웨어 멀티 태스킹 기능을 지원하지 않는다.

그러나 IA-32e 모드에서는 이런 TSS가 **7개의 IST의 정보를 저장하는 역할을 맡는다.** 

> 그 외 특권 레벨에 따른 스택 정보를 저장하는 역할과 I/O 맵 기준 주소를 저장하는 역할도 여전히 맡고있다.

< IA-32e 모드의 TSS 세그먼트 구조 >

![img](https://t1.daumcdn.net/cfile/tistory/2566734D587A00C612)

IST1 부터 IST7 까지의 영역은 IDT 게이트 디스크립터의 IST 필드와 관계가 있다.

IDT 게이트 디스크립터의 IST 영역에 정보를 저장하고,<br>TSS 세그먼트의 해당 필드에 스택 정보를 저장함으로써 IST 방식을 사용할 수 있다.

> 기존의 스택 스위칭 방식에서 사용되는 RSP0~RSP2 필드는 IST 기능을 사용하면 참조하지 않는다.

TSS 세그먼트에 있는 I/O 맵 기준 주소 필드는 I/O 제한을 설정하는 비트맵의 시작 어드레스를 나타낸다.

> I/O 제한 비트맵은 현재 수행 중인 코드의 특권 레벨(CPL)과 RFLAGS 레지스터에 설정된 IO특권 레벨(IOPL)의 값을 비교하여, CPL이 더 낮으면 1로 설정된 포트 어드레스의 I/O를 제한하는 역할을 한다.
>
> 비트맵의 바이트 순서와 비트 인덱스는 하위 바이트/비트 에서 상위 바이트/비트 의 순서로 증가하며,<br>각 비트맵은 해당 위치의 I/O 포트 어드레스와 1:1 대응한다.
>
> 그리고 비트맵의 길이는 제어할 I/O 어드레스에 따라 달라지며,<br>비트맵의 끝을 나타내는 마지막 바이트는 반드시 0xFF로 설정해야 한다.



#### 애플리케이션이 9번 I/O 포트에 접근하는 것을 막고 싶다면?

> 먼저 I/O 비트맵을 위해 3바이트를 할당한 다음 마지막 바이트를 0xFF로 설정한다.<br>그리고 비트맵의 두 번째 바이트에서 비트 2를 1로 설정하고 나서 RFLAGS 레지스터의 IOPL 필드를 최고 특권 레벨인 Ring 0으로 설정하면 된다.

<hr>

### TSS 디스크립터

TSS 세그먼트는 메모리 어드레스에 있는 단순한 데이터이다.

따라서 프로세서가 TSS 세그먼트를 참조할 수 있도록 TSS 세그먼트의 어드레스를 알려주어야 한다.

**프로세서에 TSS 세그먼트에 대한 정보를 알려주는 역할을 하는 것이 TSS 디스크립터와 LTR어셈블리 명령어이다.**

TSS 디스크립터는 GDT 테이블에 있으며 다른 디스크립터와 달리 16바이트를 차지한다.



< IA-32e 모드의 TSS 디스크립터 >

TSS 디스크립터의 하위 8바이트는 기존의 세그먼트 디스크립터와 필드 구성이 같고,<br>상위 8바이트는 64비트 어드레스를 위한 공간으로 사용된다.

![image](https://user-images.githubusercontent.com/34773827/61181430-79fa5c00-a661-11e9-89ce-7a9e92dd1853.png)

타입의 B 필드는Busy를 나타내는 필드로,<br>1로 설정되면 현재 TSS 디스크립터가 가리키는 태스크가 실행 중임을 나타낸다.

> B 필드는 TSS 세그먼트와 TSS 디스크립터가 프로세서 상태와 밀접한 관계가 있던 보호 모드에서 유용했던 필드이며, IA-32e 모드에서 동작하는 우리 OS는 B 필드를 참조하지 않는다.

<hr>

### LTR

GDT 테이블에서 위와 같은 구조의 TSS 디스크립터를 생성했다면,<br>이제 남은 작업은 프로세서에 현재 수행중인 태스크의 TSS가 어떤 것인지 알려주는 것이다.

이러한 작업은 **LTR 어셈블리 명령어** 로 수행할 수 있다.

LTR은 LGDT나 LIDT 명령어와 달리 GDT 테이블 내의 TSS 디스크립터의 오프셋을 사용한다.

LTR 명령어를 수행하는 순간 프로세서에 TSS 세그먼트의 정보가 로드되므로,<br>모든 작업이 완료된 후 LTR 명령을 마지막에 수행해야 한다.



