# MINT 파일 시스템 설계

우리 파일 시스템을 구현하려면 먼저 파일 시스템부터 설계해야 한다.

이번 절에서는 파일시스템의 구조와 각 영역을 구성하는 자료구조에 대해 살펴본다.

<hr>

## MINT 파일 시스템 특징

MINT 파일 시스템은 파일 시스템을 관리하는 메타 정보의 크기를 줄이고 하드 디스크에 효과적으로 접근하려고 4KB를 묶어서 하나의 클러스터로 사용한다.

그리고 디렉터리 구조와 경로 처리의 복잡함을 줄이려고 트리 형태의 계층적인 구조 대신 수평적 구조로 설계한다.

다음은 MINT 파일 시스템의 특징이다.

- 클러스터 링크 방식을 사용한 체인 구조 : 4KB 클러스터 사용
- 루트 디렉터리와 파일로 구성된 단층 형태
- 루트 디렉터리에 최대 128개 파일 생성 가능 : 파일 이름, 파일 크기, 시작 클러스터만 저장
- 이론상 16TB(4GB X 4KB) 크기의 하드 디스크 지원 가능
- 약 4GB까지 단일 파일 지원 가능

<hr>

## MINT 파일 시스템 구조

MINT 파일 시스템은 실제 데이터를 저장하는 데이터 영역과 데이터 영역을 관리하는 데 필요한 메타 데이터 영역으로 구분할 수 있다.

메타 데이터 영역은 다시 MBR 영역, 예약된 영역, 클러스터 링트 테이블 영역으로 나눌 수 있다.

메타 데이터 영역은 데이터 영역의 비어 있는 공간과 파일을 구성하는 클러스터의 연결 관계를 관리한다.

메타 데이터 영역과 데이터 영역의 위치는 다음과 같다.

![image](https://user-images.githubusercontent.com/34773827/62174137-c1782c00-b373-11e9-9273-f1a23c1b49d1.png)

- MBR 영역 (Master Boot Record Area)

  하드 디스크의 첫 부분에 위치하는 섹터로 부트 로더 코드, 파티션 정보, 파일 시스템 정보가 들어있다.<br>MINT 파일 시스템 역시 이 부분에 파일 시스템 정보를 등록하여 사용한다.

- 예약된 영역(Reserved Area)

  외부로 공개하고 싶지 않은 데이터를 저장하거나, 파일 시스템의 중요한 정보를 저장하는 용도로 사용하는 영역이다.

- 클러스터 링크 테이블 영역(Cluster Link Table Area)

  데이터 영역에 있는 클러스터 사이에 연결 정보를 저장하는 영역<br>클러스터 링크 테이블 영역의 크기는 데이터 영역의 클러스터 개수에 따라 좌우되며, 최소 한 섹터 이상 할당해야 한다.

- 데이터 영역(Data Area)

  데이터 영역은 실제 데이터가 저장되는 영역이다.<br>데이터 영역은 다시 파일과 디렉터리로 구분된다.<br>파일은 데이터를 보관하는 실질적인 공간으로 디렉터리는 파일이나 디렉터리의 목록을 관리한다.<br>파일과 디렉터리는 파일 시스템의 최소 단위인 클러스터 단위로 처리한다.

메타 정보 중에서 가장 중요한 영역은 클러스터 링크 테이블 영역이라고 할 수 있다.<br>클러스터 링크 테이블 영역을 구성하는 링크 정보는 해당 클러스터의 할당 여부를 저장하며,<br>할당되었다면 다음에 연결된 클러스터의 인덱스를 저장한다.

클러스터 링크 테이블에 저장된 정보는 데이터를 추가하거나 삭제, 데이터를 읽을 때 사용된다.

<hr>

## MBR 영역

MBR 영역은 하드 디스크의 첫 번째 섹터 (LBA 0)를 의미하며, 부트 코드와 파티션 정보, 파일 시스템 정보가 들어있다.

**파티션 (Partition)**

파티션은 하드 디스크를 논리적으로 분할한 영역이다.

물리적으로 파티션은 같은 하드디스크 내에 존재하지만, 논리적으로는 독립된 공간을 갖는 개별적인 영역으로 취급된다.

파티션은 주로 하드 디스크 하나에 여러 OS를 설치하거나, OS영역과 데이터 영역을 구분할 목적으로 사용한다.

파티션은 MBR 영역의 뒤쪽에 있는 파티션 테이블 영역에 정보를 기록하여 생성하는데,<br>파티션 테이블은 MBR 시작 어드레스로부터 446바이트 떨어진 위치에 존재하며,<br>총 4개의 파티션 정보로 구성된다.

파티션 정보는 16바이트로 부팅 가능 여부와 파티션의 시작과 끝, 파티션의 종류와 총 섹터 수가 들어있다.

다음은 MBR 영역에 있는 파티션 테이블의 위치와 파티션의 관계를 나타낸 것이다.

![image](https://user-images.githubusercontent.com/34773827/62174845-4f551680-b376-11e9-9385-0746b5e582dd.png)

파티션을 생성할 때 주의할 점은 서로 겹치는 부분이 없어야 한다는 것이다.

파티션을 겹쳐서 생성해 메타 데이터가 덮어 써지면 파티션에 파일 시스템을 다시 생성해야 하는 상황이 발생할 수 있으니 주의해야 한다.

<hr>

#### MBR 영역의 자료구조 - 부트 로더 코드, 파일 시스템, 파티션 정보 포함

MBR의 시작 위치부터 파티션 테이블까지 446바이트는 부트 로더 코드와 파일 시스템 데이터가 위치한다.

MINT 파일 시스템은 그 중에서 파티션 테이블 이전의 영역을 일부 사용하며 파일 시스템 시그니처, 예약된 영역 크기, 클러스터 링크 테이블 영역의 크기, 클러스터의 개수를 저장한다.

다음은 부트 로더 코드 영역, 파일 시스템 정보, 파티션 테이블이 포함된 MBR 영역의 자료구조를 나타낸 코드이다.

```c
// MINT 파일 시스템 시그너처(Signature)
#define FILESYSTEM_SIGNATURE                0x7E38CF10

// 파티션 자료구조
typedef struct kPartitionStruct
{
    // 부팅 가능 플래그. 0x80이면 부팅 가능을 나타내며 0x00은 부팅 불가
    BYTE bBootableFlag;
    // 파티션의 시작 어드레스. 현재는 거의 사용하지 않으며 아래의 LBA 어드레스를 대신 사용
    BYTE vbStartingCHSAddress[ 3 ];
    // 파티션 타입
    BYTE bPartitionType;
    // 파티션의 마지막 어드레스. 현재는 거의 사용 안 함
    BYTE vbEndingCHSAddress[ 3 ];
    // 파티션의 시작 어드레스. LBA 어드레스로 나타낸 값
    DWORD dwStartingLBAAddress;
    // 파티션에 포함된 섹터 수
    DWORD dwSizeInSector;
} PARTITION;


// MBR 자료구조
typedef struct kMBRStruct
{
    // 부트 로더 코드가 위치하는 영역
    BYTE vbBootCode[ 430 ];

    // 파일 시스템 시그너처, 0x7E38CF10
    DWORD dwSignature;
    // 예약된 영역의 섹터 수
    DWORD dwReservedSectorCount;
    // 클러스터 링크 테이블 영역의 섹터 수
    DWORD dwClusterLinkSectorCount;
    // 클러스터의 전체 개수
    DWORD dwTotalClusterCount;
    
    // 파티션 테이블
    PARTITION vstPartition[ 4 ];
    
    // 부트 로더 시그너처, 0x55, 0xAA
    BYTE vbBootLoaderSignature[ 2 ];
} MBR;
```

<hr>

## 예약된 영역

예약된 영역(Reserved Area)은 선택 사항으로 파일 시스템 백업 공간이나 외부로 공개할 수 없는 데이터를 저장하는 영역으로 사용할 수 있다.

그리고 MINT64 OS처럼 OS 이미지가 디스크의 첫 번째 섹터부터 연속적으로 저장되는 경우도 유용하게 사용할 수 있다.

이를 이용하면 파일 시스템을 생성할 때 OS 이미지 크기만큼 예약된 영역으로 설정함으로써,<br>OS 이미지와 파일 시스템 데이터가 서로 겹치지 않도록 구성할 수 있다.

예약된 영역은 파일 시스템 확장을 위해 추가한 영역으로 지금은 사용하지 않는다.

<hr>

## 클러스터 링크 테이블 영역과 데이터 영역

### 클러스터 링크 테이블 영역

클러스터 링크 테이블 영역(Cluster Link Table Area)은 각 클러스터의 사용 여부와 다음에 연결된 클러스터의 인덱스를 저장한다.

클러스터 링크 테이블을 구성하는 링크 정보는 클러스터 수만큼 존재하며,<br>링크 정보의 인덱스는 데이터 영역 내에 클러스터의 인덱스와 같다.

링크 정보의 크기는 4바이트이므로 필요한 클러스터 링크 테이블의 크기는 (4바이트 X 클러스터의 개수)가 된다.

하지만, 하드 디스크는 섹터 단위로 데이터를 처리하므로 실제 하드 디스크에서 차지하는 영역은 계산된 크기를 섹터 단위로 올림한 크기가 된다.

<hr>

### 데이터 영역

데이터 영역(Data Area)은 하드 디스크에서 메타 정보가 차지하는 영역을 제외한 나머지 영역으로써<br>전체 크기는 클러스터 단위로 정렬되어 있다.

MINT 파일 시스템은 섹터 8개, 즉 4KB를 묶어서 클러스터로 사용하므로 4KB 미만인 자투리 공간은 버려서 데이터 영역을 클러스터 단위로 맞춘다. 파일도 클러스터 단위로 잘라서 저장하며, 파일 읽기와 쓰기, 확장 역시 모두 클러스터 단위로 처리한다.

파일을 클러스터 단위로 잘라서 체인으로 관리하는 이유는 파일의 크기가 다양하기 때문이다.<br>파일의 크기가 다양하니 파일 크기만큼의 공간을 순차적으로 할당하면 동적 메모리 할당과 같은 단편화 문제가 발생 할 수 있다.

이러한 문제를 피하기 위해 파일을 클러스터 단위로 나눈 뒤에 체인으로 연결하여 저장하는 것이다.

#### 클러스터 링크 테이블에서 클러스터를 찾는 방법

이때 사용하는 것이 바로 클러스터 링크 테이블의 링크 정보이다.

클러스터의 인덱스와 링크 정보의 인덱스는 1:1로 대응하며,<br>각 링크 정보는 클러스터가 사용되었는지 여부와 사용되었다면 자신의 다음에 연결된 클러스터의 오프셋을 가지고 있다.

파일 시스템을 생성한 직후나 파일이 몇 개 존재하지 않으면 대부분의 파일이 연속된 클러스터, <br>즉 하드 디스크에 연속된 섹터에 위치할 것이다. 하지만 파일 추가와 삭제를 반복하다 보면 클러스터가 조각나서 파일을 구성하는 클러스터의 위치가 뒤죽박죽이 될 수 있다. 이 때문에 클러스터마다 다음 클러스터의 인덱스를 확인해서 정확한 클러스터를 찾아야 한다.

현재 클러스터의 다음에 연결된 클러스터 정보는 클러스터 링크 테이블에 저장되어 있으므로,<br>링크 정보의 값을 차례로 따라가면 전체 클러스터를 찾을 수 있다.

다음은 총 4개의 클러스터로 구성된 파일을 클러스터 링크 테이블을 참조하여 조합하는 과정을 나타낸 것이다.

![image](https://user-images.githubusercontent.com/34773827/62176097-2edb8b00-b37b-11e9-8141-1a0224bf5a91.png)

위 그림에서 보면 파일의 시작 클러스터는 클러스터 0이다.

여기에 대응하는 링크 테이블은 클러스터 1이라고 되어있으므로,<br>클러스터 0의 다음 클러스터는 클러스터 1이라는 것을 알 수 있다.

이와 같은 방식으로 클러스터 7까지 이동한 뒤에 클러스터 링크 테이블을 확인하면 0xFFFFFFFF으로 되어있으므로 마지막 클러스터라는 것을 알 수 있으며 파일은 0, 1, 4, 7이라는 것을 알 수 있다.

### 파일의 시작 클러스터는 누가 가지고 있는가?

파일의 시작 클러스터라면 파일의 이름과 시작 클러스터를 연결해주는 무엇인가가 있어야 하지만 위 그림에서는 찾아볼 수 없다.

이와 같은 정보는 **디렉터리** 에서 찾을 수 있다.

디렉터리는 파일 정보를 저장하는 파일로서 파일의 이름과 시작 클러스터, 파일의 크기 등의 정보가 담겨 있다.

MINT 파일 시스템은 가장 첫 번째 클러스터인 클러스터 0을 최상위 디렉터리인 루트 디렉터리로 사용한다.

<hr>

## 루트 디렉터리와 파일

디렉터리도 파일 목록을 관리하는 일종의 파일이다.

다만 그 내용이 파일 시스템에서 파일을 추가하거나 수정, 삭제하는데 사용되기 때문에 다른 형태로 처리하는 것 뿐이다.

MINT 파일 시스템은 최상위 디렉터리인 루트 디렉터리만 사용하며, 루트 디렉터리 하위에서 계층적 구조를 만드는데 사용하는 서브 디렉터리는 지원하지 않는다.

따라서 모든 파일은 루트 디렉터리에 존재하며 계층적인 관계가 아니라 수평적인 관계를 갖는다.

<hr>

MINT 파일 시스템은 루트 디렉터리로 첫 번째 클러스터 1개를 예약해서 사용한다.

루트 디렉터리의 내부에는 파일 정보를 저장하는 자료구조로 가득 차 있다.

파일 정보를 저장하는 자료구조는 32바이트이고, 이것을 디렉터리 엔트리(Directory Entry)라고 부른다.

MINT 파일 시스템은 클러스터의 크기가 4KB이므로 디렉터리 엔트리를 최대 128개(4KB/32바이트) 까지 생성할 수 있다.

디렉터리 엔트리에는 파일 이름과 파일의 크기, 시작 클러스터 정보가 들어 있다.

#### 디렉터리 엔트리 자료구조의 코드

```c
// 디렉터리 엔트리 자료구조
typedef struct kDirectoryEntryStruct
{
    // 파일 이름
    char vcFileName[ FILESYSTEM_MAXFILENAMELENGTH ];
    // 파일의 실제 크기
    DWORD dwFileSize;
    // 파일이 시작하는 클러스터 인덱스
    DWORD dwStartClusterIndex;
} DIRECTORYENTRY;
```

MINT 파일 시스템의 모든 파일은 루트 디렉터리에 존재한다.

그러므로 파일을 루트 디렉터리에 추가하거나 삭제하려면 빈 디렉터리 엔트리를 검색하거나 해당 디렉터리를 빈 디렉터리로 설정해야 한다.

우리는 시작 클러스터 인덱스가 0인지를 검사해 빈 디렉터리 엔트리인지 판단하는 방법을 사용하는데<br>루트 디렉터리가 클러스터 0에 위치하므로 다른 파일은 시작 클러스터 인덱스가 0일 수 없기 때문이다.

![image](https://user-images.githubusercontent.com/34773827/62177127-c2628b00-b37e-11e9-888b-f920b9d1ca58.png)

<hr>

## 파일 추가와 파일 삭제 알고리즘

### 파일 생성

루트 디렉터리에 파일을 추가하려면 디렉터리 엔트리 1개와 클러스터 1개가 필요하다.

그러므로 루트 디렉터리를 우선 검색하여 빈 엔트리가 있는지 확인한 뒤에 클러스터 링크 테이블을 검색해 빈 클러스터를 찾아야한다.

빈 클러스터와 빈 디렉터리 엔트리가 모두 존재한다면, 해당 클러스터의 링크 테이블에 0xFFFFFFFF를 설정해 클러스터가 할당된 상태이며 마지막 클러스터임을 표시한다.

끝으로 디렉터리 엔트리에 파일 이름, 파일 크기, 할당받은 클러스터 인덱스를 저장하면 파일을 생성하는 작업이 마무리 된다.

![image](https://user-images.githubusercontent.com/34773827/62177878-95fc3e00-b381-11e9-8983-065145391eb2.png)

### 파일 삭제

파일 삭제는 파일이 생성된 후에 수행하는 작업이므로, 루트 디렉터리에서 빈 디렉터리 엔트리를 검색하는 대신 간ㅌ은 이름의 디렉터리 엔트리를 찾는다.

파일을 찾았다면 파일의 첫 번째 클러스터를 알 수 있으므로 해당 클러스터에 대응하는 클러스터 링크 테이블을 0x00으로 설정하여 빈 상태로 지정한다.

마지막으로 찾은 디렉터리 엔트리를 모두 0으로 초기화해 빈 상태로 설정하면 파일을 삭제하는 작업이 끝난다.

![image](https://user-images.githubusercontent.com/34773827/62177979-0014e300-b382-11e9-9111-5470e9d96ce7.png)

<hr>

## MINT 파일 시스템 자료구조 설계

MINT 파일 시스템은 여러 영역으로 나누어지므로 각 영역의 시작 어드레스와 섹터 수를 미리 계산해 두면 각 영역에 접근하기가 편리하다.

### MINT 파일 시스템 자료구조

```c
// 파일 시스템을 관리하는 구조체
typedef struct kFileSystemManagerStruct
{
    // 파일 시스템이 정상적으로 인식되었는지 여부
    BOOL bMounted;
    
    // 각 영역의 섹터 수와 시작 LBA 어드레스
    DWORD dwReservedSectorCount;
    DWORD dwClusterLinkAreaStartAddress;
    DWORD dwClusterLinkAreaSize;
    DWORD dwDataAreaStartAddress;   
    // 데이터 영역의 클러스터의 총 개수
    DWORD dwTotalClusterCount;
    
    // 마지막으로 클러스터를 할당한 클러스터 링크 테이블의 섹터 오프셋을 저장
    DWORD dwLastAllocatedClusterLinkSectorOffset;
    
    // 파일 시스템 동기화 객체
    MUTEX stMutex;    
} FILESYSTEMMANAGER;
```

만일 파일 시스템을 초기화하는 과정에서 문제가 발생하거나,<br>하드 디스크에 있는 파일 시스템이 MINT 파일 시스템이 아니라면 관련 함수를 수행하는 것이 의미 없다.

이러한 용도로 추가된 것이 자료구조의 bMount 필드이다. bMount 필드는 파일 시스템이 인식된 결과를 저장하는데 사용한다.

dwLastAllocatedClusterLinkSectorOffset 필드는 가장 최근에 클러스터를 할당한 클러스터 링크 테이블의 섹터 오프셋을 저장한다.

이 필드는 빈 클러스터를 할당하는데 드는 시간을 줄이기 위해 추가한 필드이다.

