# 파일 시스템 캐시와 램 디스크의 통합과 빌드

```c
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
```



## 파일 시스템 캐시 파일 추가

#### 02.Kernel64/Source/CacheManager.h

```c
#ifndef __CACHEMANAGER_H__
#define __CACHEMANAGER_H__

#include "Types.h"

////////////////////////////////////////////////////////////////////////////////
//
// 매크로
//
////////////////////////////////////////////////////////////////////////////////
// 클러스터 링크 테이블 영역의 최대 캐시 버퍼의 개수
#define CACHE_MAXCLUSTERLINKTABLEAREACOUNT      16
// 데이터 영역의 최대 캐시 버퍼의 수
#define CACHE_MAXDATAAREACOUNT                  32
// 유효하지 않은 태그, 비어있는 캐시 버퍼를 나타내는 데 사용
#define CACHE_INVALIDTAG                        0xFFFFFFFF

// 캐시 테이블의 최대 개수. 클러스터 링크 테이블과 데이터 영역만 있으므로 2로 설정
#define CACHE_MAXCACHETABLEINDEX                2
// 클러스터 링크 테이블 영역의 인덱스
#define CACHE_CLUSTERLINKTABLEAREA              0
// 데이터 영역의 인덱스
#define CACHE_DATAAREA                          1

////////////////////////////////////////////////////////////////////////////////
//
// 구조체
//
////////////////////////////////////////////////////////////////////////////////
// 파일 시스템 캐시를 구성하는 캐시 버퍼의 구조체
typedef struct kCacheBufferStruct
{
    // 캐시와 대응하는 클러스터 링크 테이블 영역이나 데이터 영역의 인덱스
    DWORD dwTag;

    // 캐시 버퍼에 접근한 시간
    DWORD dwAccessTime;

    // 데이터의 내용이 변경되었는지 여부
    BOOL bChanged;

    // 데이터 버퍼
    BYTE* pbBuffer;
} CACHEBUFFER;

// 파일 시스템 캐시를 관리하는 캐시 매니저의 구조체
typedef struct kCacheManagerStruct
{
    // 클러스터 링크 테이블 영역과 데이터 영역의 접근 시간 필드
    DWORD vdwAccessTime[ CACHE_MAXCACHETABLEINDEX ];

    // 클러스터 링크 테이블 영역과 데이터 영역의 데이터 버퍼
    BYTE* vpbBuffer[ CACHE_MAXCACHETABLEINDEX ];

    // 클러스터 링크 테이블 영역과 데이터 영역의 캐시 버퍼
    // 두 값 중에서 큰 값만큼 생성해야 함
    CACHEBUFFER vvstCacheBuffer[ CACHE_MAXCACHETABLEINDEX ][ CACHE_MAXDATAAREACOUNT ];

    // 캐시 버퍼의 최댓값을 저장
    DWORD vdwMaxCount[ CACHE_MAXCACHETABLEINDEX ];
} CACHEMANAGER;

////////////////////////////////////////////////////////////////////////////////
//
// 함수
//
////////////////////////////////////////////////////////////////////////////////
BOOL kInitializeCacheManager( void );
CACHEBUFFER* kAllocateCacheBuffer( int iCacheTableIndex );
CACHEBUFFER* kFindCacheBuffer( int iCacheTableIndex, DWORD dwTag );
CACHEBUFFER* kGetVictimInCacheBuffer( int iCacheTableIndex );
void kDiscardAllCacheBuffer( int iCacheTableIndex );
BOOL kGetCacheBufferAndCount( int iCacheTableIndex, 
        CACHEBUFFER** ppstCacheBuffer, int* piMaxCount );

static void kCutDownAccessTime( int iCacheTableIndex );

#endif /*__CACHEMANAGER_H__*/

```

#### 02.Kernel64/Source/CacheManager.c

```c
#include "CacheManager.h"
#include "FileSystem.h"
#include "DynamicMemory.h"

// 파일 시스템 캐시 자료구조
static CACHEMANAGER gs_stCacheManager;

/**
 *  파일 시스템 캐시를 초기화
 */
BOOL kInitializeCacheManager( void )
{
    int i;
    
    // 자료구조 초기화
    kMemSet( &gs_stCacheManager, 0, sizeof( gs_stCacheManager ) );
    
    // 접근 시간 초기화
    gs_stCacheManager.vdwAccessTime[ CACHE_CLUSTERLINKTABLEAREA ] = 0;
    gs_stCacheManager.vdwAccessTime[ CACHE_DATAAREA ] = 0;

    // 캐시 버퍼의 최댓값 설정
    gs_stCacheManager.vdwMaxCount[ CACHE_CLUSTERLINKTABLEAREA ] = 
        CACHE_MAXCLUSTERLINKTABLEAREACOUNT;
    gs_stCacheManager.vdwMaxCount[ CACHE_DATAAREA ] = CACHE_MAXDATAAREACOUNT;
    
    // 클러스터 링크 테이블 영역용 메모리 할당, 클러스터 링크 테이블은 512바이트로 관리함
    gs_stCacheManager.vpbBuffer[ CACHE_CLUSTERLINKTABLEAREA ] = 
        ( BYTE* ) kAllocateMemory( CACHE_MAXCLUSTERLINKTABLEAREACOUNT * 512 );
    if( gs_stCacheManager.vpbBuffer[ CACHE_CLUSTERLINKTABLEAREA ] == NULL )
    {
        return FALSE;
    }
    
    // 할당 받은 메모리 영역을 나누어서 캐시 버퍼에 등록
    for( i = 0 ; i < CACHE_MAXCLUSTERLINKTABLEAREACOUNT ; i++ )
    {
        // 캐시 버퍼에 메모리 공간 할당
        gs_stCacheManager.vvstCacheBuffer[ CACHE_CLUSTERLINKTABLEAREA ][ i ].
            pbBuffer = gs_stCacheManager.vpbBuffer[ CACHE_CLUSTERLINKTABLEAREA ] 
            + ( i * 512 );
        
        // 태그를 유효하지 않은 것으로 설정하여 빈 것으로 만듦
        gs_stCacheManager.vvstCacheBuffer[ CACHE_CLUSTERLINKTABLEAREA ][ i ].
            dwTag = CACHE_INVALIDTAG;
        
    }
    
    // 데이터 영역용 메모리 할당, 데이터 영역은 클러스터 단위(4 Kbyte)로 관리함
    gs_stCacheManager.vpbBuffer[ CACHE_DATAAREA ] = 
        ( BYTE* ) kAllocateMemory( CACHE_MAXDATAAREACOUNT * FILESYSTEM_CLUSTERSIZE );
    if( gs_stCacheManager.vpbBuffer[ CACHE_DATAAREA ] == NULL )
    {
        // 실패하면 이전에 할당 받은 메모리를 해제해야 함
        kFreeMemory( gs_stCacheManager.vpbBuffer[ CACHE_CLUSTERLINKTABLEAREA ] );
        return FALSE;
    }
    
    // 할당 받은 메모리 영역을 나누어서 캐시 버퍼에 등록
    for( i = 0 ; i < CACHE_MAXDATAAREACOUNT ; i++ )
    {
        // 캐시 버퍼에 메모리 공간 할당
        gs_stCacheManager.vvstCacheBuffer[ CACHE_DATAAREA ][ i ].pbBuffer = 
            gs_stCacheManager.vpbBuffer[ CACHE_DATAAREA ] + 
            ( i * FILESYSTEM_CLUSTERSIZE );
        
        // 태그를 유효하지 않은 것으로 설정하여 빈 것으로 만듦
        gs_stCacheManager.vvstCacheBuffer[ CACHE_DATAAREA ][ i ].dwTag = 
            CACHE_INVALIDTAG;
    }
    
    return TRUE;
}

/**
 *  캐시 버퍼에서 빈 것을 찾아서 반환
 */
CACHEBUFFER* kAllocateCacheBuffer( int iCacheTableIndex )
{
    CACHEBUFFER* pstCacheBuffer;
    int i;
    
    // 캐시 테이블의 최대 개수를 넘어서면 실패
    if( iCacheTableIndex > CACHE_MAXCACHETABLEINDEX )
    {
        return FALSE;
    }
    
    // 접근 시간 필드가 최대 값까지 가면 전체적으로 접근 시간을 낮춰줌
    kCutDownAccessTime( iCacheTableIndex );

    // 최대 개수만큼 검색하여 빈 것을 반환
    pstCacheBuffer = gs_stCacheManager.vvstCacheBuffer[ iCacheTableIndex ];
    for( i = 0 ; i < gs_stCacheManager.vdwMaxCount[ iCacheTableIndex ] ; i++ )
    {
        if( pstCacheBuffer[ i ].dwTag == CACHE_INVALIDTAG )
        {
            // 임시로 캐시 태그를 설정하여 할당된 것으로 만듦
            pstCacheBuffer[ i ].dwTag = CACHE_INVALIDTAG - 1;

            // 접근 시간을 갱신
            pstCacheBuffer[ i ].dwAccessTime = 
                gs_stCacheManager.vdwAccessTime[ iCacheTableIndex ]++;
            
            return &( pstCacheBuffer[ i ] );
        }
    }
    
    return NULL;
}

/**
 *  캐시 버퍼에서 태그가 일치하는 것을 찾아서 반환
 */
CACHEBUFFER* kFindCacheBuffer( int iCacheTableIndex, DWORD dwTag )
{
    CACHEBUFFER* pstCacheBuffer;
    int i;
    
    // 캐시 테이블의 최대 개수를 넘어서면 실패
    if( iCacheTableIndex > CACHE_MAXCACHETABLEINDEX )
    {
        return FALSE;
    }
    
    // 접근 시간 필드가 최대 값까지 증가하면 전체적으로 접근 시간을 낮춤
    kCutDownAccessTime( iCacheTableIndex );
    
    // 최대 개수만큼 검색하여 빈 것을 반환
    pstCacheBuffer = gs_stCacheManager.vvstCacheBuffer[ iCacheTableIndex ];
    for( i = 0 ; i < gs_stCacheManager.vdwMaxCount[ iCacheTableIndex ] ; i++ )
    {
        if( pstCacheBuffer[ i ].dwTag == dwTag )
        {
            // 접근 시간을 갱신
            pstCacheBuffer[ i ].dwAccessTime = 
                gs_stCacheManager.vdwAccessTime[ iCacheTableIndex ]++;
            
            return &( pstCacheBuffer[ i ] );
        }
    }
    
    return NULL;
}

/**
 *  접근한 시간을 전체적으로 낮춤
 */
static void kCutDownAccessTime( int iCacheTableIndex )
{
    CACHEBUFFER stTemp;
    CACHEBUFFER* pstCacheBuffer;
    BOOL bSorted;
    int i, j;

    // 캐시 테이블의 최대 개수를 넘어서면 실패
    if( iCacheTableIndex > CACHE_MAXCACHETABLEINDEX )
    {
        return ;
    }

    // 접근 시간이 아직 최대치를 넘지 않았다면 접근 시간을 줄일 필요 없음
    if( gs_stCacheManager.vdwAccessTime[ iCacheTableIndex ] < 0xfffffffe )
    {
        return ;
    }

    // 캐시 버퍼를 접근 시간으로 오름차순으로 정렬함
    // 버블 정렬(Bouble Sort) 사용
    pstCacheBuffer = gs_stCacheManager.vvstCacheBuffer[ iCacheTableIndex ];
    for( j = 0 ; j < gs_stCacheManager.vdwMaxCount[ iCacheTableIndex ] - 1 ; j++ )
    {
        // 기본은 정렬된 것으로 저장
        bSorted = TRUE;
        for( i = 0 ; i < gs_stCacheManager.vdwMaxCount[ iCacheTableIndex ] - 1 - j ;
             i++ )
        {
            // 인접한 두 데이터를 비교하여 접근 시간이 큰 것을 우측(i+1)에 위치시킴
            if( pstCacheBuffer[ i ].dwAccessTime > 
                pstCacheBuffer[ i + 1 ].dwAccessTime )
            {
                // 두 데이터를 교환하므로 정렬되지 않은 것으로 표시
                bSorted = FALSE;

                // i번째 캐시와 i+1번째 캐시를 교환
                kMemCpy( &stTemp, &( pstCacheBuffer[ i ] ), 
                        sizeof( CACHEBUFFER ) );
                kMemCpy( &( pstCacheBuffer[ i ] ), &( pstCacheBuffer[ i + 1 ] ), 
                        sizeof( CACHEBUFFER ) );
                kMemCpy( &( pstCacheBuffer[ i + 1 ] ), &stTemp, 
                        sizeof( CACHEBUFFER ) );
            }
        }

        // 다 정렬되었으면 루프를 빠져 나감
        if( bSorted == TRUE )
        {
            break;
        }
    }

    // 오름차순으로 정렬했으므로, 인덱스가 증가할수록 접근 시간 큰(최신) 캐시 버퍼임
    // 접근 시간을 0부터 순차적으로 설정하여 데이터 갱신
    for( i = 0 ; i < gs_stCacheManager.vdwMaxCount[ iCacheTableIndex ] ; i++ )
    {
        pstCacheBuffer[ i ].dwAccessTime = i;
    }

    // 접근 시간을 파일 시스템 캐시 자료구조에 저장하여 다음부터는 변경된 값으로 
    // 접근 시간을 설정하도록 함
    gs_stCacheManager.vdwAccessTime[ iCacheTableIndex ] = i;
}

/**
 *  캐시 버퍼에서 내보낼 것을 찾음
 */
CACHEBUFFER* kGetVictimInCacheBuffer( int iCacheTableIndex )
{
    DWORD dwOldTime;
    CACHEBUFFER* pstCacheBuffer;
    int iOldIndex;
    int i;

    // 캐시 테이블의 최대 개수를 넘어서면 실패
    if( iCacheTableIndex > CACHE_MAXCACHETABLEINDEX )
    {
        return FALSE;
    }
    
    // 접근 시간을 최대로 해서 접근 시간이 가장 오래된(값이 작은) 캐시 버퍼를 검색
    iOldIndex = -1;
    dwOldTime = 0xFFFFFFFF;

    // 캐시 버퍼에서 사용 중이지 않거나 접근한지 가장 오래된 것을 찾아서 반환
    pstCacheBuffer = gs_stCacheManager.vvstCacheBuffer[ iCacheTableIndex ];
    for( i = 0 ; i < gs_stCacheManager.vdwMaxCount[ iCacheTableIndex ] ; i++ )
    {
        // 빈 캐시 버퍼가 있으면 빈 것을 반환
        if( pstCacheBuffer[ i ].dwTag == CACHE_INVALIDTAG )
        {
            iOldIndex = i;
            break;
        }

        // 접근 시간이 현재 값보다 오래되었으면 저장해둠
        if( pstCacheBuffer[ i ].dwAccessTime < dwOldTime )
        {
            dwOldTime = pstCacheBuffer[ i ].dwAccessTime;
            iOldIndex = i;
        }
    }

    // 캐시 버퍼를 찾지 못하면 문제가 발생한 것임
    if( iOldIndex == -1 )
    {
        kPrintf( "Cache Buffer Find Error\n" );
        
        return NULL;
    }

    // 선택된 캐시 버퍼의 접근 시간을 갱신
    pstCacheBuffer[ iOldIndex ].dwAccessTime = 
        gs_stCacheManager.vdwAccessTime[ iCacheTableIndex ]++;
    
    return &( pstCacheBuffer[ iOldIndex ] );
}

/**
 *  캐시 버퍼의 내용을 모두 비움
 */
void kDiscardAllCacheBuffer( int iCacheTableIndex )
{
    CACHEBUFFER* pstCacheBuffer;
    int i;
    
    // 캐시 버퍼를 모두 빈 것으로 설정
    pstCacheBuffer = gs_stCacheManager.vvstCacheBuffer[ iCacheTableIndex ];
    for( i = 0 ; i < gs_stCacheManager.vdwMaxCount[ iCacheTableIndex ] ; i++ )
    {
        pstCacheBuffer[ i ].dwTag = CACHE_INVALIDTAG;
    }
    
    // 접근 시간을 초기화
    gs_stCacheManager.vdwAccessTime[ iCacheTableIndex ] = 0;
}

/**
 *  캐시 버퍼의 포인터와 최대 개수를 반환
 */
BOOL kGetCacheBufferAndCount( int iCacheTableIndex, 
        CACHEBUFFER** ppstCacheBuffer, int* piMaxCount )
{
    // 캐시 테이블의 최대 개수를 넘어서면 실패
    if( iCacheTableIndex > CACHE_MAXCACHETABLEINDEX )
    {
        return FALSE;
    }
    
    // 캐시 버퍼의 포인터와 최댓값을 반환
    *ppstCacheBuffer = gs_stCacheManager.vvstCacheBuffer[ iCacheTableIndex ];
    *piMaxCount = gs_stCacheManager.vdwMaxCount[ iCacheTableIndex ];
    return TRUE;
}

```

<hr>

## 램 디스크 파일 추가

#### 02.Kernel64/Source/RAMDisk.h

```c
#ifndef __RAMDISK_H__
#define __RAMDISK_H__

#include "Types.h"
#include "Synchronization.h"
#include "HardDisk.h"

////////////////////////////////////////////////////////////////////////////////
//
// 매크로
//
////////////////////////////////////////////////////////////////////////////////
// 램 디스크의 총 섹터 수. 8Mbyte 크기로 생성
#define RDD_TOTALSECTORCOUNT        ( 8 * 1024 * 1024 / 512)

////////////////////////////////////////////////////////////////////////////////
//
// 구조체
//
////////////////////////////////////////////////////////////////////////////////
// 1바이트로 정렬
#pragma pack( push, 1 )

// 램 디스크의 자료구조를 저장하는 구조체
typedef struct kRDDManagerStruct
{
    // 램 디스크용으로 할당 받은 메모리 영역
    BYTE* pbBuffer;
    
    // 총 섹터 수
    DWORD dwTotalSectorCount;

    // 동기화 객체
    MUTEX stMutex;
} RDDMANAGER;

#pragma pack( pop)

////////////////////////////////////////////////////////////////////////////////
//
//  함수
//
////////////////////////////////////////////////////////////////////////////////
BOOL kInitializeRDD( DWORD dwTotalSectorCount );
BOOL kReadRDDInformation( BOOL bPrimary, BOOL bMaster, 
        HDDINFORMATION* pstHDDInformation );
int kReadRDDSector( BOOL bPrimary, BOOL bMaster, DWORD dwLBA, int iSectorCount, 
        char* pcBuffer );
int kWriteRDDSector( BOOL bPrimary, BOOL bMaster, DWORD dwLBA, int iSectorCount, 
        char* pcBuffer );

#endif /*__RAMDISK_H__*/

```

#### 02.Kernel64/Source/RAMDisk.c

```c
#include "RAMDisk.h"
#include "Utility.h"
#include "DynamicMemory.h"

// 램 디스크를 관리하는 자료구조
static RDDMANAGER gs_stRDDManager;

/**
 *  램 디스크 디바이스 드라이버 초기화 함수
 */
BOOL kInitializeRDD( DWORD dwTotalSectorCount )
{
    // 자료구조 초기화
    kMemSet( &gs_stRDDManager, 0, sizeof( gs_stRDDManager ) );
    
    // 램 디스크로 사용할 메모리를 할당
    gs_stRDDManager.pbBuffer = ( BYTE* ) kAllocateMemory( dwTotalSectorCount * 512 );
    if( gs_stRDDManager.pbBuffer == NULL )
    {
        return FALSE;
    }
    
    // 총 섹터 수와 동기화 객체를 설정
    gs_stRDDManager.dwTotalSectorCount = dwTotalSectorCount;
    kInitializeMutex( &( gs_stRDDManager.stMutex ) );
    return TRUE;
}

/**
 *  램 디스크의 정보를 반환
 */
BOOL kReadRDDInformation( BOOL bPrimary, BOOL bMaster, 
        HDDINFORMATION* pstHDDInformation )
{
    // 자료구조 초기화
    kMemSet( pstHDDInformation, 0, sizeof( HDDINFORMATION ) );
    
    // 총 섹터 수와 시리얼 번호, 그리고 모델 번호만 설정
    pstHDDInformation->dwTotalSectors = gs_stRDDManager.dwTotalSectorCount;
    kMemCpy( pstHDDInformation->vwSerialNumber, "0000-0000", 9 );
    kMemCpy( pstHDDInformation->vwModelNumber, "MINT RAM Disk v1.0", 18 ); 

    return TRUE;
}

/**
 *  램 디스크에서 여러 섹터를 읽어서 반환
 */
int kReadRDDSector( BOOL bPrimary, BOOL bMaster, DWORD dwLBA, int iSectorCount, 
        char* pcBuffer )
{
    int iRealReadCount;
    
    // LBA 어드레스부터 끝까지 읽을 수 있는 섹터 수와 읽어야 할 섹터 수를 비교해서
    // 실제로 읽을 수 있는 수를 계산
    iRealReadCount = MIN( gs_stRDDManager.dwTotalSectorCount - 
                      (dwLBA + iSectorCount), iSectorCount );

    // 램 디스크 메모리에서 데이터를 실제로 읽을 섹터 수만큼 복사해서 반환
    kMemCpy( pcBuffer, gs_stRDDManager.pbBuffer + ( dwLBA * 512 ), 
             iRealReadCount * 512 );
    
    return iRealReadCount;
}

/**
 *  램 디스크에 여러 섹터를 씀
 */
int kWriteRDDSector( BOOL bPrimary, BOOL bMaster, DWORD dwLBA, int iSectorCount, 
        char* pcBuffer )
{
    int iRealWriteCount;
    
    // LBA 어드레스부터 끝까지 쓸 수 있는 섹터 수와 써야 할 섹터 수를 비교해서
    // 실제로 쓸 수 있는 수를 계산
    iRealWriteCount = MIN( gs_stRDDManager.dwTotalSectorCount - 
                      (dwLBA + iSectorCount), iSectorCount );

    // 데이터를 실제로 쓸 섹터 수만큼 램 디스크 메모리에 복사
    kMemCpy( gs_stRDDManager.pbBuffer + ( dwLBA * 512 ), pcBuffer, 
             iRealWriteCount * 512 );
    
    return iRealWriteCount;    
}


```

<hr>

## 파일 시스템 파일 수정

#### 02.Kernel64/Source/FileSystem.h

```c
#include "FileSystem.h"
#include "HardDisk.h"
#include "DynamicMemory.h"
#include "Task.h"
#include "Utility.h"
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
#include "CacheManager.h"
#include "RAMDisk.h"
///////////////////////////////////////////////////////////////////

// 파일 시스템 자료구조
static FILESYSTEMMANAGER   gs_stFileSystemManager;
// 파일 시스템 임시 버퍼
static BYTE gs_vbTempBuffer[ FILESYSTEM_SECTORSPERCLUSTER * 512 ];

// 하드 디스크 제어에 관련된 함수 포인터 선언
fReadHDDInformation gs_pfReadHDDInformation = NULL;
fReadHDDSector gs_pfReadHDDSector = NULL;
fWriteHDDSector gs_pfWriteHDDSector = NULL;

/**
 *  파일 시스템을 초기화
 */
BOOL kInitializeFileSystem( void )
{
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    BOOL bCacheEnable = FALSE;
///////////////////////////////////////////////////////////////////

    // 자료구조 초기화와 동기화 객체 초기화
    kMemSet( &gs_stFileSystemManager, 0, sizeof( gs_stFileSystemManager ) );
    kInitializeMutex( &( gs_stFileSystemManager.stMutex ) );
    
    // 하드 디스크를 초기화
    if( kInitializeHDD() == TRUE )
    {
        // 초기화가 성공하면 함수 포인터를 하드 디스크용 함수로 설정
        gs_pfReadHDDInformation = kReadHDDInformation;
        gs_pfReadHDDSector = kReadHDDSector;
        gs_pfWriteHDDSector = kWriteHDDSector;

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
        // 캐시를 활성화한다.
        bCacheEnable = TRUE;
///////////////////////////////////////////////////////////////////
    }
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 하드 디스크 초기화가 실패하면 8MB 크기의 램 디스크를 생성
    else if(kInitializeRDD(RDD_TOTALSECTORCOUNT) == TRUE)
    {
        // 초기화가 성공하면 함수 포인터를 램 디스크용 함수로 설정
        gs_pfReadHDDInformation = kReadRDDInformation;
        gs_pfReadHDDSector = kReadRDDSector;
        gs_pfWriteHDDSector = kWriteRDDSector;
        
        // 램 디스크는 데이터가 남아있지 않으므로 매번 파일 시스템을 생성함
        if( kFormat() == FALSE )
        {
            return FALSE;
        }   
    }
///////////////////////////////////////////////////////////////////
    else
    {
        return FALSE;
    }
    
    // 파일 시스템 연결
    if( kMount() == FALSE )
    {
        return FALSE;
    }
    
    // 핸들을 위한 공간을 할당
    gs_stFileSystemManager.pstHandlePool = ( FILE* ) kAllocateMemory( 
        FILESYSTEM_HANDLE_MAXCOUNT * sizeof( FILE ) );
    
    // 메모리 할당이 실패하면 하드 디스크가 인식되지 않은 것으로 설정
    if( gs_stFileSystemManager.pstHandlePool == NULL )
    {
        gs_stFileSystemManager.bMounted = FALSE;
        return FALSE;
    }
    
    // 핸들 풀을 모두 0으로 설정하여 초기화
    kMemSet( gs_stFileSystemManager.pstHandlePool, 0, 
            FILESYSTEM_HANDLE_MAXCOUNT * sizeof( FILE ) );    
    
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 활성화
    if( bCacheEnable == TRUE )
    {
        gs_stFileSystemManager.bCacheEnable = kInitializeCacheManager();    
    }
///////////////////////////////////////////////////////////////////

    return TRUE;
}

//==============================================================================
//  저수준 함수(Low Level Function)
//==============================================================================
/**
 *  하드 디스크의 MBR을 읽어서 MINT 파일 시스템인지 확인
 *      MINT 파일 시스템이라면 파일 시스템에 관련된 각종 정보를 읽어서
 *      자료구조에 삽입
 */
BOOL kMount( void )
{
    MBR* pstMBR;
    
    // 동기화 처리
    kLock( &( gs_stFileSystemManager.stMutex ) );

    // MBR을 읽음
    if( gs_pfReadHDDSector( TRUE, TRUE, 0, 1, gs_vbTempBuffer ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }
    
    // 시그너처를 확인하여 같다면 자료구조에 각 영역에 대한 정보 삽입
    pstMBR = ( MBR* ) gs_vbTempBuffer;
    if( pstMBR->dwSignature != FILESYSTEM_SIGNATURE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }
    
    // 파일 시스템 인식 성공
    gs_stFileSystemManager.bMounted = TRUE;
    
    // 각 영역의 시작 LBA 어드레스와 섹터 수를 계산
    gs_stFileSystemManager.dwReservedSectorCount = pstMBR->dwReservedSectorCount;
    gs_stFileSystemManager.dwClusterLinkAreaStartAddress =
        pstMBR->dwReservedSectorCount + 1;
    gs_stFileSystemManager.dwClusterLinkAreaSize = pstMBR->dwClusterLinkSectorCount;
    gs_stFileSystemManager.dwDataAreaStartAddress = 
        pstMBR->dwReservedSectorCount + pstMBR->dwClusterLinkSectorCount + 1;
    gs_stFileSystemManager.dwTotalClusterCount = pstMBR->dwTotalClusterCount;

    // 동기화 처리
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return TRUE;
}

/**
 *  하드 디스크에 파일 시스템을 생성
 */
BOOL kFormat( void )
{
    HDDINFORMATION* pstHDD;
    MBR* pstMBR;
    DWORD dwTotalSectorCount, dwRemainSectorCount;
    DWORD dwMaxClusterCount, dwClsuterCount;
    DWORD dwClusterLinkSectorCount;
    DWORD i;
    
    // 동기화 처리
    kLock( &( gs_stFileSystemManager.stMutex ) );

    //==========================================================================
    //  하드 디스크 정보를 읽어서 메타 영역의 크기와 클러스터의 개수를 계산
    //==========================================================================
    // 하드 디스크의 정보를 얻어서 하드 디스크의 총 섹터 수를 구함
    pstHDD = ( HDDINFORMATION* ) gs_vbTempBuffer;
    if( gs_pfReadHDDInformation( TRUE, TRUE, pstHDD ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }    
    dwTotalSectorCount = pstHDD->dwTotalSectors;
    
    // 전체 섹터 수를 4Kbyte, 즉 클러스터 크기로 나누어 최대 클러스터 수를 계산
    dwMaxClusterCount = dwTotalSectorCount / FILESYSTEM_SECTORSPERCLUSTER;
    
    // 최대 클러스터의 수에 맞추어 클러스터 링크 테이블의 섹터 수를 계산
    // 링크 데이터는 4바이트이므로, 한 섹터에는 128개가 들어감. 따라서 총 개수를
    // 128로 나눈 후 올림하여 클러스터 링크의 섹터 수를 구함
    dwClusterLinkSectorCount = ( dwMaxClusterCount + 127 ) / 128;
    
    // 예약된 영역은 현재 사용하지 않으므로, 디스크 전체 영역에서 MBR 영역과 클러스터
    // 링크 테이블 영역의 크기를 뺀 나머지가 실제 데이터 영역이 됨
    // 해당 영역을 클러스터 크기로 나누어 실제 클러스터의 개수를 구함
    dwRemainSectorCount = dwTotalSectorCount - dwClusterLinkSectorCount - 1;
    dwClsuterCount = dwRemainSectorCount / FILESYSTEM_SECTORSPERCLUSTER;
    
    // 실제 사용 가능한 클러스터 수에 맞추어 다시 한번 계산
    dwClusterLinkSectorCount = ( dwClsuterCount + 127 ) / 128;

    //==========================================================================
    // 계산된 정보를 MBR에 덮어 쓰고, 루트 디렉터리 영역까지 모두 0으로 초기화하여
    // 파일 시스템을 생성
    //==========================================================================
    // MBR 영역 읽기
    if( gs_pfReadHDDSector( TRUE, TRUE, 0, 1, gs_vbTempBuffer ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }        
    
    // 파티션 정보와 파일 시스템 정보 설정    
    pstMBR = ( MBR* ) gs_vbTempBuffer;
    kMemSet( pstMBR->vstPartition, 0, sizeof( pstMBR->vstPartition ) );
    pstMBR->dwSignature = FILESYSTEM_SIGNATURE;
    pstMBR->dwReservedSectorCount = 0;
    pstMBR->dwClusterLinkSectorCount = dwClusterLinkSectorCount;
    pstMBR->dwTotalClusterCount = dwClsuterCount;
    
    // MBR 영역에 1 섹터를 씀
    if( gs_pfWriteHDDSector( TRUE, TRUE, 0, 1, gs_vbTempBuffer ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }
    
    // MBR 이후부터 루트 디렉터리까지 모두 0으로 초기화
    kMemSet( gs_vbTempBuffer, 0, 512 );
    for( i = 0 ; i < ( dwClusterLinkSectorCount + FILESYSTEM_SECTORSPERCLUSTER );
         i++ )
    {
        // 루트 디렉터리(클러스터 0)는 이미 파일 시스템이 사용하고 있으므로,
        // 할당된 것으로 표시
        if( i == 0 )
        {
            ( ( DWORD* ) ( gs_vbTempBuffer ) )[ 0 ] = FILESYSTEM_LASTCLUSTER;
        }
        else
        {
            ( ( DWORD* ) ( gs_vbTempBuffer ) )[ 0 ] = FILESYSTEM_FREECLUSTER;
        }
        
        // 1 섹터씩 씀
        if( gs_pfWriteHDDSector( TRUE, TRUE, i + 1, 1, gs_vbTempBuffer ) == FALSE )
        {
            // 동기화 처리
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return FALSE;
        }
    }    

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 버퍼를 모두 버림
    if( gs_stFileSystemManager.bCacheEnable == TRUE )
    {
        kDiscardAllCacheBuffer( CACHE_CLUSTERLINKTABLEAREA );
        kDiscardAllCacheBuffer( CACHE_DATAAREA );
    }
///////////////////////////////////////////////////////////////////
    
    // 동기화 처리
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return TRUE;
}

/**
 *  파일 시스템에 연결된 하드 디스크의 정보를 반환
 */
BOOL kGetHDDInformation( HDDINFORMATION* pstInformation)
{
    BOOL bResult;
    
    // 동기화 처리
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    bResult = gs_pfReadHDDInformation( TRUE, TRUE, pstInformation );
    
    // 동기화 처리
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    
    return bResult;
}

/**
 *  클러스터 링크 테이블 내의 오프셋에서 한 섹터를 읽음
 */
static BOOL kReadClusterLinkTable( DWORD dwOffset, BYTE* pbBuffer )
{
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 여부에 따라 다른 읽기 함수 호출
    if( gs_stFileSystemManager.bCacheEnable == FALSE )
    {
        kInternalReadClusterLinkTableWithoutCache( dwOffset, pbBuffer );
    }
    else
    {
        kInternalReadClusterLinkTableWithCache( dwOffset, pbBuffer );
    }
///////////////////////////////////////////////////////////////////
}

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
/**
 *  클러스터 링크 테이블 내의 오프셋에서 한 섹터를 읽음
 *      내부적으로 사용하는 함수, 캐시 사용 안함
 */
static BOOL kInternalReadClusterLinkTableWithoutCache( DWORD dwOffset, 
        BYTE* pbBuffer )
{
    // 클러스터 링크 테이블 영역의 시작 어드레스를 더함
    return gs_pfReadHDDSector( TRUE, TRUE, dwOffset + 
              gs_stFileSystemManager.dwClusterLinkAreaStartAddress, 1, pbBuffer );
}

/**
 *  클러스터 링크 테이블 내의 오프셋에서 한 섹터를 읽음
 *      내부적으로 사용하는 함수, 캐시 사용
 */
static BOOL kInternalReadClusterLinkTableWithCache( DWORD dwOffset, 
        BYTE* pbBuffer )
{
    CACHEBUFFER* pstCacheBuffer;
    
    // 먼저 캐시에 해당 클러스터 링크 테이블이 있는지 확인
    pstCacheBuffer = kFindCacheBuffer( CACHE_CLUSTERLINKTABLEAREA, dwOffset );

    // 캐시 버퍼에 있다면 캐시의 내용을 복사
    if( pstCacheBuffer != NULL )
    {
        kMemCpy( pbBuffer, pstCacheBuffer->pbBuffer, 512 );
        return TRUE;
    }
    
    // 캐시 버퍼에 없다면 하드 디스크에서 직접 읽음
    if( kInternalReadClusterLinkTableWithoutCache( dwOffset, pbBuffer ) == FALSE )
    {
        return FALSE;
    }
    
    // 캐시를 할당 받아서 캐시 내용을 갱신
    pstCacheBuffer = kAllocateCacheBufferWithFlush( CACHE_CLUSTERLINKTABLEAREA );
    if( pstCacheBuffer == NULL )
    {
        return FALSE;
    }    

    // 캐시 버퍼에 읽은 내용을 복사한 후, 태그 정보를 갱신
    kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, 512 );
    pstCacheBuffer->dwTag = dwOffset;
    
    // 읽기를 수행했으므로 버퍼의 내용을 수정되지 않은 것으로 표시
    pstCacheBuffer->bChanged = FALSE;
    return TRUE;
}

/**
 *  클러스터 링크 테이블 영역의 캐시 버퍼 또는 데이터 영역의 캐시 버퍼에서 할당
 *      빈 캐시 버퍼가 없는 경우 오래된 것 중에 하나를 골라서 비운 후 사용
 */
static CACHEBUFFER* kAllocateCacheBufferWithFlush( int iCacheTableIndex )
{
    CACHEBUFFER* pstCacheBuffer;
    
    // 캐시 버퍼에 없다면 캐시를 할당 받아서 캐시 내용을 갱신
    pstCacheBuffer = kAllocateCacheBuffer( iCacheTableIndex );
    // 캐시를 할당 받을 수 없다면 캐시 버퍼에서 오래된 것을 찾아 버린 후 사용
    if( pstCacheBuffer == NULL )
    {
        pstCacheBuffer = kGetVictimInCacheBuffer( iCacheTableIndex );
        // 오래된 캐시 버퍼도 할당 받을 수 없으면 오류
        if( pstCacheBuffer == NULL )
        {
            kPrintf( "Cache Allocate Fail~!!!!\n" );
            return NULL;
        }

        // 캐시 버퍼의 데이터가 수정되었다면 하드 디스크로 옮겨야 함
        if( pstCacheBuffer->bChanged == TRUE )
        {
            switch( iCacheTableIndex )
            {
                // 클러스터 링크 테이블 영역의 캐시인 경우
            case CACHE_CLUSTERLINKTABLEAREA:
                // 쓰기가 실패한다면 오류
                if( kInternalWriteClusterLinkTableWithoutCache( 
                    pstCacheBuffer->dwTag, pstCacheBuffer->pbBuffer ) == FALSE )
                {
                    kPrintf( "Cache Buffer Write Fail~!!!!\n" );
                    return NULL;
                }
                break;
                
                // 데이터 영역의 캐시인 경우
            case CACHE_DATAAREA:
                // 쓰기가 실패한다면 오류
                if( kInternalWriteClusterWithoutCache( 
                    pstCacheBuffer->dwTag, pstCacheBuffer->pbBuffer ) == FALSE )
                {
                    kPrintf( "Cache Buffer Write Fail~!!!!\n" );
                    return NULL;
                }
                break;
                
                // 기타는 오류
            default:
                kPrintf( "kAllocateCacheBufferWithFlush Fail\n" );
                return NULL;
                break;
            }
        }
    }    
    return pstCacheBuffer;
}
///////////////////////////////////////////////////////////////////

/**
 *  클러스터 링크 테이블 내의 오프셋에 한 섹터를 씀
 */
static BOOL kWriteClusterLinkTable( DWORD dwOffset, BYTE* pbBuffer )
{
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 여부에 따라 다른 쓰기 함수 호출
    if( gs_stFileSystemManager.bCacheEnable == FALSE )
    {
        return kInternalWriteClusterLinkTableWithoutCache( dwOffset, pbBuffer );
    }
    else
    {
        return kInternalWriteClusterLinkTableWithCache( dwOffset, pbBuffer );
    }
///////////////////////////////////////////////////////////////////
}

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
/**
 *  클러스터 링크 테이블 내의 오프셋에 한 섹터를 씀
 *      내부적으로 사용하는 함수, 캐시 사용 안 함
 */
static BOOL kInternalWriteClusterLinkTableWithoutCache( DWORD dwOffset, 
        BYTE* pbBuffer )
{
    // 클러스터 링크 테이블 영역의 시작 어드레스를 더함
    return gs_pfWriteHDDSector( TRUE, TRUE, dwOffset + 
               gs_stFileSystemManager.dwClusterLinkAreaStartAddress, 1, pbBuffer );
}

/**
 *  클러스터 링크 테이블 내의 오프셋에 한 섹터를 씀
 *      내부적으로 사용하는 함수, 캐시 사용
 */
static BOOL kInternalWriteClusterLinkTableWithCache( DWORD dwOffset, 
        BYTE* pbBuffer )
{
    CACHEBUFFER* pstCacheBuffer;
    
    // 캐시에 해당 클러스터 링크 테이블이 있는지 확인
    pstCacheBuffer = kFindCacheBuffer( CACHE_CLUSTERLINKTABLEAREA, dwOffset );

    // 캐시 버퍼에 있다면 캐시에 씀
    if( pstCacheBuffer != NULL )
    {
        kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, 512 );

        // 쓰기를 수행했으므로 버퍼의 내용을 수정된 것으로 표시
        pstCacheBuffer->bChanged = TRUE;  
        return TRUE;
    }
    
    // 캐시 버퍼에 없다면 캐시 버퍼를 할당 받아서 캐시 내용을 갱신
    pstCacheBuffer = kAllocateCacheBufferWithFlush( CACHE_CLUSTERLINKTABLEAREA );
    if( pstCacheBuffer == NULL )
    {
        return FALSE;
    } 

    // 캐시 버퍼에 쓰고, 태그 정보를 갱신
    kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, 512 );
    pstCacheBuffer->dwTag = dwOffset;
    
    // 쓰기를 수행했으므로 버퍼의 내용을 수정된 것으로 표시
    pstCacheBuffer->bChanged = TRUE;  

    return TRUE;
}
///////////////////////////////////////////////////////////////////

/**
 *  데이터 영역의 오프셋에서 한 클러스터를 읽음
 */
static BOOL kReadCluster( DWORD dwOffset, BYTE* pbBuffer )
{
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 여부에 따라 다른 읽기 함수 호출
    if( gs_stFileSystemManager.bCacheEnable == FALSE )
    {
        kInternalReadClusterWithoutCache( dwOffset, pbBuffer );
    }
    else
    {
        kInternalReadClusterWithCache( dwOffset, pbBuffer );
    }
///////////////////////////////////////////////////////////////////
}

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
/**
 *  데이터 영역의 오프셋에서 한 클러스터를 읽음
 *      내부적으로 사용하는 함수, 캐시 사용 안 함
 */
static BOOL kInternalReadClusterWithoutCache( DWORD dwOffset, BYTE* pbBuffer )
{
    // 데이터 영역의 시작 어드레스를 더함
    return gs_pfReadHDDSector( TRUE, TRUE, ( dwOffset * FILESYSTEM_SECTORSPERCLUSTER ) + 
              gs_stFileSystemManager.dwDataAreaStartAddress, 
              FILESYSTEM_SECTORSPERCLUSTER, pbBuffer );
}

/**
 *  데이터 영역의 오프셋에서 한 클러스터를 읽음
 *      내부적으로 사용하는 함수, 캐시 사용
 */
static BOOL kInternalReadClusterWithCache( DWORD dwOffset, BYTE* pbBuffer )
{
    CACHEBUFFER* pstCacheBuffer;
    
    // 캐시에 해당 데이터 클러스터가 있는지 확인
    pstCacheBuffer = kFindCacheBuffer( CACHE_DATAAREA, dwOffset );

    // 캐시 버퍼에 있다면 캐시의 내용을 복사
    if( pstCacheBuffer != NULL )
    {
        kMemCpy( pbBuffer, pstCacheBuffer->pbBuffer, FILESYSTEM_CLUSTERSIZE );
        return TRUE;
    }
    
    // 캐시 버퍼에 없다면 하드 디스크에서 직접 읽음
    if( kInternalReadClusterWithoutCache( dwOffset, pbBuffer ) == FALSE )
    {
        return FALSE;
    }
    
    // 캐시 버퍼를 할당 받아서 캐시 내용을 갱신
    pstCacheBuffer = kAllocateCacheBufferWithFlush( CACHE_DATAAREA );
    if( pstCacheBuffer == NULL )
    {
        return FALSE;
    }    

    // 캐시 버퍼에 읽은 내용을 복사한 후, 태그 정보를 갱신
    kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, FILESYSTEM_CLUSTERSIZE );
    pstCacheBuffer->dwTag = dwOffset;
    
    // 읽기를 수행했으므로 버퍼의 내용을 수정되지 않은 것으로 표시
    pstCacheBuffer->bChanged = FALSE;
    return TRUE;    
}
///////////////////////////////////////////////////////////////////

/**
 *  데이터 영역의 오프셋에 한 클러스터를 씀
 */
static BOOL kWriteCluster( DWORD dwOffset, BYTE* pbBuffer )
{
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 여부에 따라 다른 쓰기 함수 호출
    if( gs_stFileSystemManager.bCacheEnable == FALSE )
    {
        kInternalWriteClusterWithoutCache( dwOffset, pbBuffer );
    }
    else
    {
        kInternalWriteClusterWithCache( dwOffset, pbBuffer );
    }    
///////////////////////////////////////////////////////////////////
}

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    /**
 *  데이터 영역의 오프셋에 한 클러스터를 씀
 *      내부적으로 사용하는 함수, 캐시 사용 안 함
 */
static BOOL kInternalWriteClusterWithoutCache( DWORD dwOffset, BYTE* pbBuffer )
{
    // 데이터 영역의 시작 어드레스를 더함
    return  gs_pfWriteHDDSector( TRUE, TRUE, ( dwOffset * FILESYSTEM_SECTORSPERCLUSTER ) + 
              gs_stFileSystemManager.dwDataAreaStartAddress, 
              FILESYSTEM_SECTORSPERCLUSTER, pbBuffer );
}

/**
 *  데이터 영역의 오프셋에 한 클러스터를 씀
 *      내부적으로 사용하는 함수, 캐시 사용
 */
static BOOL kInternalWriteClusterWithCache( DWORD dwOffset, BYTE* pbBuffer )
{
    CACHEBUFFER* pstCacheBuffer;
    
    // 캐시 버퍼에 해당 데이터 클러스터가 있는지 확인
    pstCacheBuffer = kFindCacheBuffer( CACHE_DATAAREA, dwOffset );

    // 캐시 버퍼에 있다면 캐시에 씀
    if( pstCacheBuffer != NULL )
    {
        kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, FILESYSTEM_CLUSTERSIZE );

        // 쓰기를 수행했으므로 버퍼의 내용을 수정된 것으로 표시
        pstCacheBuffer->bChanged = TRUE;  

        return TRUE;
    }
    
    // 캐시 버퍼에 없다면 캐시를 할당 받아서 캐시 내용을 갱신
    pstCacheBuffer = kAllocateCacheBufferWithFlush( CACHE_DATAAREA );
    if( pstCacheBuffer == NULL )
    {
        return FALSE;
    } 

    // 캐시 버퍼에 쓰고, 태그 정보를 갱신
    kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, FILESYSTEM_CLUSTERSIZE );
    pstCacheBuffer->dwTag = dwOffset;
    
    // 쓰기를 수행했으므로 버퍼의 내용을 수정된 것으로 표시
    pstCacheBuffer->bChanged = TRUE;  

    return TRUE;
}
///////////////////////////////////////////////////////////////////

/**
 *  클러스터 링크 테이블 영역에서 빈 클러스터를 검색함
 */
static DWORD kFindFreeCluster( void )
{
    DWORD dwLinkCountInSector;
    DWORD dwLastSectorOffset, dwCurrentSectorOffset;
    DWORD i, j;
    
    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return FILESYSTEM_LASTCLUSTER;
    }
    
    // 마지막으로 클러스터를 할당한 클러스터 링크 테이블의 섹터 오프셋을 가져옴
    dwLastSectorOffset = gs_stFileSystemManager.dwLastAllocatedClusterLinkSectorOffset;

    // 마지막으로 할당한 위치부터 루프를 돌면서 빈 클러스터를 검색
    for( i = 0 ; i < gs_stFileSystemManager.dwClusterLinkAreaSize ; i++ )
    {
        // 클러스터 링크 테이블의 마지막 섹터이면 전체 섹터만큼 도는 것이 아니라
        // 남은 클러스터의 수만큼 루프를 돌아야 함
        if( ( dwLastSectorOffset + i ) == 
            ( gs_stFileSystemManager.dwClusterLinkAreaSize - 1 ) )
        {
            dwLinkCountInSector = gs_stFileSystemManager.dwTotalClusterCount % 128; 
        }
        else
        {
            dwLinkCountInSector = 128;
        }
        
        // 이번에 읽어야 할 클러스터 링크 테이블의 섹터 오프셋을 구해서 읽음
        dwCurrentSectorOffset = ( dwLastSectorOffset + i ) % 
            gs_stFileSystemManager.dwClusterLinkAreaSize;
        if( kReadClusterLinkTable( dwCurrentSectorOffset, gs_vbTempBuffer ) == FALSE )
        {
            return FILESYSTEM_LASTCLUSTER;
        }
        
        // 섹터 내에서 루프를 돌면서 빈 클러스터를 검색
        for( j = 0 ; j < dwLinkCountInSector ; j++ )
        {
            if( ( ( DWORD* ) gs_vbTempBuffer )[ j ] == FILESYSTEM_FREECLUSTER )
            {
                break;
            }
        }
            
        // 찾았다면 클러스터 인덱스를 반환
        if( j != dwLinkCountInSector )
        {
            // 마지막으로 클러스터를 할당한 클러스터 링크 내의 섹터 오프셋을 저장
            gs_stFileSystemManager.dwLastAllocatedClusterLinkSectorOffset = 
                dwCurrentSectorOffset;
            
            // 현재 클러스터 링크 테이블의 오프셋을 감안하여 클러스터 인덱스를 계산
            return ( dwCurrentSectorOffset * 128 ) + j;
        }
    }
    
    return FILESYSTEM_LASTCLUSTER;
}

/**
 *  클러스터 링크 테이블에 값을 설정
 */
static BOOL kSetClusterLinkData( DWORD dwClusterIndex, DWORD dwData )
{
    DWORD dwSectorOffset;
    
    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return FALSE;
    }
    
    // 한 섹터에 128개의 클러스터 링크가 들어가므로 128로 나누면 섹터 오프셋을 
    // 구할 수 있음
    dwSectorOffset = dwClusterIndex / 128;

    // 해당 섹터를 읽어서 링크 정보를 설정한 후, 다시 저장
    if( kReadClusterLinkTable( dwSectorOffset, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    
    ( ( DWORD* ) gs_vbTempBuffer )[ dwClusterIndex % 128 ] = dwData;

    if( kWriteClusterLinkTable( dwSectorOffset, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }

    return TRUE;
}

/**
 *  클러스터 링크 테이블의 값을 반환
 */
static BOOL kGetClusterLinkData( DWORD dwClusterIndex, DWORD* pdwData )
{
    DWORD dwSectorOffset;
    
    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return FALSE;
    }
    
    // 한 섹터에 128개의 클러스터 링크가 들어가므로 128로 나누면 섹터 오프셋을 
    // 구할 수 있음
    dwSectorOffset = dwClusterIndex / 128;
    
    if( dwSectorOffset > gs_stFileSystemManager.dwClusterLinkAreaSize )
    {
        return FALSE;
    }
    
    
    // 해당 섹터를 읽어서 링크 정보를 반환
    if( kReadClusterLinkTable( dwSectorOffset, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    

    *pdwData = ( ( DWORD* ) gs_vbTempBuffer )[ dwClusterIndex % 128 ];
    return TRUE;
}


/**
 *  루트 디렉터리에서 빈 디렉터리 엔트리를 반환
 */
static int kFindFreeDirectoryEntry( void )
{
    DIRECTORYENTRY* pstEntry;
    int i;

    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return -1;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return -1;
    }
    
    // 루트 디렉터리 안에서 루프를 돌면서 빈 엔트리, 즉 시작 클러스터 번호가 0인
    // 엔트리를 검색
    pstEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    for( i = 0 ; i < FILESYSTEM_MAXDIRECTORYENTRYCOUNT ; i++ )
    {
        if( pstEntry[ i ].dwStartClusterIndex == 0 )
        {
            return i;
        }
    }
    return -1;
}

/**
 *  루트 디렉터리의 해당 인덱스에 디렉터리 엔트리를 설정
 */
static BOOL kSetDirectoryEntryData( int iIndex, DIRECTORYENTRY* pstEntry )
{
    DIRECTORYENTRY* pstRootEntry;
    
    // 파일 시스템을 인식하지 못했거나 인덱스가 올바르지 않으면 실패
    if( ( gs_stFileSystemManager.bMounted == FALSE ) ||
        ( iIndex < 0 ) || ( iIndex >= FILESYSTEM_MAXDIRECTORYENTRYCOUNT ) )
    {
        return FALSE;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    
    // 루트 디렉터리에 있는 해당 데이터를 갱신
    pstRootEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    kMemCpy( pstRootEntry + iIndex, pstEntry, sizeof( DIRECTORYENTRY ) );

    // 루트 디렉터리에 씀
    if( kWriteCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    return TRUE;
}

/**
 *  루트 디렉터리의 해당 인덱스에 위치하는 디렉터리 엔트리를 반환
 */
static BOOL kGetDirectoryEntryData( int iIndex, DIRECTORYENTRY* pstEntry )
{
    DIRECTORYENTRY* pstRootEntry;
    
    // 파일 시스템을 인식하지 못했거나 인덱스가 올바르지 않으면 실패
    if( ( gs_stFileSystemManager.bMounted == FALSE ) ||
        ( iIndex < 0 ) || ( iIndex >= FILESYSTEM_MAXDIRECTORYENTRYCOUNT ) )
    {
        return FALSE;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    
    // 루트 디렉터리에 있는 해당 데이터를 갱신
    pstRootEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    kMemCpy( pstEntry, pstRootEntry + iIndex, sizeof( DIRECTORYENTRY ) );
    return TRUE;
}

/**
 *  루트 디렉터리에서 파일 이름이 일치하는 엔트리를 찾아서 인덱스를 반환
 */
static int kFindDirectoryEntry( const char* pcFileName, DIRECTORYENTRY* pstEntry )
{
    DIRECTORYENTRY* pstRootEntry;
    int i;
    int iLength;

    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return -1;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return -1;
    }
    
    iLength = kStrLen( pcFileName );
    // 루트 디렉터리 안에서 루프를 돌면서 파일 이름이 일치하는 엔트리를 반환
    pstRootEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    for( i = 0 ; i < FILESYSTEM_MAXDIRECTORYENTRYCOUNT ; i++ )
    {
        if( kMemCmp( pstRootEntry[ i ].vcFileName, pcFileName, iLength ) == 0 )
        {
            kMemCpy( pstEntry, pstRootEntry + i, sizeof( DIRECTORYENTRY ) );
            return i;
        }
    }
    return -1;
}

/**
 *  파일 시스템의 정보를 반환
 */
void kGetFileSystemInformation( FILESYSTEMMANAGER* pstManager )
{
    kMemCpy( pstManager, &gs_stFileSystemManager, sizeof( gs_stFileSystemManager ) );
}

//==============================================================================
//  고수준 함수(High Level Function)
//==============================================================================
/**
 *  비어있는 핸들을 할당
 */
static void* kAllocateFileDirectoryHandle( void )
{
    int i;
    FILE* pstFile;
    
    // 핸들 풀(Handle Pool)을 모두 검색하여 비어있는 핸들을 반환
    pstFile = gs_stFileSystemManager.pstHandlePool;
    for( i = 0 ; i < FILESYSTEM_HANDLE_MAXCOUNT ; i++ )
    {
        // 비어있다면 반환
        if( pstFile->bType == FILESYSTEM_TYPE_FREE )
        {
            pstFile->bType = FILESYSTEM_TYPE_FILE;
            return pstFile;
        }
        
        // 다음으로 이동
        pstFile++;
    }
    
    return NULL;
}

/**
 *  사용한 핸들을 반환
 */
static void kFreeFileDirectoryHandle( FILE* pstFile )
{
    // 전체 영역을 초기화
    kMemSet( pstFile, 0, sizeof( FILE ) );
    
    // 비어있는 타입으로 설정
    pstFile->bType = FILESYSTEM_TYPE_FREE;
}

/**
 *  파일을 생성
 */
static BOOL kCreateFile( const char* pcFileName, DIRECTORYENTRY* pstEntry, 
        int* piDirectoryEntryIndex )
{
    DWORD dwCluster;
    
    // 빈 클러스터를 찾아서 할당된 것으로 설정
    dwCluster = kFindFreeCluster();
    if( ( dwCluster == FILESYSTEM_LASTCLUSTER ) ||
        ( kSetClusterLinkData( dwCluster, FILESYSTEM_LASTCLUSTER ) == FALSE ) )
    {
        return FALSE;
    }

    // 빈 디렉터리 엔트리를 검색
    *piDirectoryEntryIndex = kFindFreeDirectoryEntry();
    if( *piDirectoryEntryIndex == -1 )
    {
        // 실패할 경우 할당 받은 클러스터를 반환해야 함
        kSetClusterLinkData( dwCluster, FILESYSTEM_FREECLUSTER );
        return FALSE;
    }
    
    // 디렉터리 엔트리를 설정
    kMemCpy( pstEntry->vcFileName, pcFileName, kStrLen( pcFileName ) + 1 );
    pstEntry->dwStartClusterIndex = dwCluster;
    pstEntry->dwFileSize = 0;
    
    // 디렉터리 엔트리를 등록
    if( kSetDirectoryEntryData( *piDirectoryEntryIndex, pstEntry ) == FALSE )
    {
        // 실패할 경우 할당 받은 클러스터를 반환해야 함
        kSetClusterLinkData( dwCluster, FILESYSTEM_FREECLUSTER );
        return FALSE;
    }
    return TRUE;
}

/**
 *  파라미터로 넘어온 클러스터부터 파일의 끝까지 연결된 클러스터를 모두 반환
 */
static BOOL kFreeClusterUntilEnd( DWORD dwClusterIndex )
{
    DWORD dwCurrentClusterIndex;
    DWORD dwNextClusterIndex;
    
    // 클러스터 인덱스를 초기화
    dwCurrentClusterIndex = dwClusterIndex;
    
    while( dwCurrentClusterIndex != FILESYSTEM_LASTCLUSTER )
    {
        // 다음 클러스터의 인덱스를 가져옴
        if( kGetClusterLinkData( dwCurrentClusterIndex, &dwNextClusterIndex )
                == FALSE )
        {
            return FALSE;
        }
        
        // 현재 클러스터를 빈 것으로 설정하여 해제
        if( kSetClusterLinkData( dwCurrentClusterIndex, FILESYSTEM_FREECLUSTER )
                == FALSE )
        {
            return FALSE;
        }
        
        // 현재 클러스터 인덱스를 다음 클러스터의 인덱스로 바꿈
        dwCurrentClusterIndex = dwNextClusterIndex;
    }
    
    return TRUE;
}

/**
 *  파일을 열거나 생성 
 */
FILE* kOpenFile( const char* pcFileName, const char* pcMode )
{
    DIRECTORYENTRY stEntry;
    int iDirectoryEntryOffset;
    int iFileNameLength;
    DWORD dwSecondCluster;
    FILE* pstFile;

    // 파일 이름 검사
    iFileNameLength = kStrLen( pcFileName );
    if( ( iFileNameLength > ( sizeof( stEntry.vcFileName ) - 1 ) ) || 
        ( iFileNameLength == 0 ) )
    {
        return NULL;
    }
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    //==========================================================================
    // 파일이 먼저 존재하는가 확인하고, 없다면 옵션을 보고 파일을 생성
    //==========================================================================
    iDirectoryEntryOffset = kFindDirectoryEntry( pcFileName, &stEntry );
    if( iDirectoryEntryOffset == -1 )
    {
        // 파일이 없다면 읽기(r, r+) 옵션은 실패
        if( pcMode[ 0 ] == 'r' )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
        
        // 나머지 옵션들은 파일을 생성
        if( kCreateFile( pcFileName, &stEntry, &iDirectoryEntryOffset ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
    }    
    //==========================================================================
    // 파일의 내용을 비워야 하는 옵션이면 파일에 연결된 클러스터를 모두 제거하고
    // 파일 크기를 0으로 설정
    //==========================================================================
    else if( pcMode[ 0 ] == 'w' )
    {
        // 시작 클러스터의 다음 클러스터를 찾음
        if( kGetClusterLinkData( stEntry.dwStartClusterIndex, &dwSecondCluster )
                == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
        
        // 시작 클러스터를 마지막 클러스터로 만듦
        if( kSetClusterLinkData( stEntry.dwStartClusterIndex, 
               FILESYSTEM_LASTCLUSTER ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
        
        // 다음 클러스터부터 마지막 클러스터까지 모두 해제
        if( kFreeClusterUntilEnd( dwSecondCluster ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
       
        // 파일의 내용이 모두 비워졌으므로, 크기를 0으로 설정
        stEntry.dwFileSize = 0;
        if( kSetDirectoryEntryData( iDirectoryEntryOffset, &stEntry ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
    }
    
    //==========================================================================
    // 파일 핸들을 할당 받아 데이터를 설정한 후 반환
    //==========================================================================
    // 파일 핸들을 할당 받아 데이터 설정
    pstFile = kAllocateFileDirectoryHandle();
    if( pstFile == NULL )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
    }
    
    // 파일 핸들에 파일 정보를 설정
    pstFile->bType = FILESYSTEM_TYPE_FILE;
    pstFile->stFileHandle.iDirectoryEntryOffset = iDirectoryEntryOffset;
    pstFile->stFileHandle.dwFileSize = stEntry.dwFileSize;
    pstFile->stFileHandle.dwStartClusterIndex = stEntry.dwStartClusterIndex;
    pstFile->stFileHandle.dwCurrentClusterIndex = stEntry.dwStartClusterIndex;
    pstFile->stFileHandle.dwPreviousClusterIndex = stEntry.dwStartClusterIndex;
    pstFile->stFileHandle.dwCurrentOffset = 0;
       
    // 만약 추가 옵션(a)이 설정되어 있으면, 파일의 끝으로 이동
    if( pcMode[ 0 ] == 'a' )
    {
        kSeekFile( pstFile, 0, FILESYSTEM_SEEK_END );
    }

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return pstFile;
}

/**
 *  파일을 읽어 버퍼로 복사
 */
DWORD kReadFile( void* pvBuffer, DWORD dwSize, DWORD dwCount, FILE* pstFile )
{
    DWORD dwTotalCount;
    DWORD dwReadCount;
    DWORD dwOffsetInCluster;
    DWORD dwCopySize;
    FILEHANDLE* pstFileHandle;
    DWORD dwNextClusterIndex;    

    // 핸들이 파일 타입이 아니면 실패
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return 0;
    }
    pstFileHandle = &( pstFile->stFileHandle );
    
    // 파일의 끝이거나 마지막 클러스터이면 종료
    if( ( pstFileHandle->dwCurrentOffset == pstFileHandle->dwFileSize ) ||
        ( pstFileHandle->dwCurrentClusterIndex == FILESYSTEM_LASTCLUSTER ) )
    {
        return 0;
    }

    // 파일 끝과 비교해서 실제로 읽을 수 있는 값을 계산
    dwTotalCount = MIN( dwSize * dwCount, pstFileHandle->dwFileSize - 
                        pstFileHandle->dwCurrentOffset );
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 계산된 값만큼 다 읽을 때까지 반복
    dwReadCount = 0;
    while( dwReadCount != dwTotalCount )
    {
        //======================================================================
        // 클러스터를 읽어서 버퍼에 복사
        //======================================================================
        // 현재 클러스터를 읽음
        if( kReadCluster( pstFileHandle->dwCurrentClusterIndex, gs_vbTempBuffer )
                == FALSE )
        {
            break;
        }

        // 클러스터 내에서 파일 포인터가 존재하는 오프셋을 계산
        dwOffsetInCluster = pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE;
        
        // 여러 클러스터에 걸쳐져 있다면 현재 클러스터에서 남은 만큼 읽고 다음 
        // 클러스터로 이동
        dwCopySize = MIN( FILESYSTEM_CLUSTERSIZE - dwOffsetInCluster, 
                          dwTotalCount - dwReadCount );
        kMemCpy( ( char* ) pvBuffer + dwReadCount, 
                gs_vbTempBuffer + dwOffsetInCluster, dwCopySize );

        // 읽은 바이트 수와 파일 포인터의 위치를 갱신
        dwReadCount += dwCopySize;
        pstFileHandle->dwCurrentOffset += dwCopySize;

        //======================================================================
        // 현재 클러스터를 끝까지 다 읽었으면 다음 클러스터로 이동
        //======================================================================
        if( ( pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE ) == 0 )
        {
            // 현재 클러스터의 링크 데이터를 찾아 다음 클러스터를 얻음
            if( kGetClusterLinkData( pstFileHandle->dwCurrentClusterIndex, 
                                     &dwNextClusterIndex ) == FALSE )
            {
                break;
            }
            
            // 클러스터 정보를 갱신
            pstFileHandle->dwPreviousClusterIndex = 
                pstFileHandle->dwCurrentClusterIndex;
            pstFileHandle->dwCurrentClusterIndex = dwNextClusterIndex;
        }
    }
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    
    // 읽은 레코드 수를 반환
    return ( dwReadCount / dwSize );
}

/**
 *  루트 디렉터리에서 디렉터리 엔트리 값을 갱신
 */
static BOOL kUpdateDirectoryEntry( FILEHANDLE* pstFileHandle )
{
    DIRECTORYENTRY stEntry;
    
    // 디렉터리 엔트리 검색
    if( ( pstFileHandle == NULL ) ||
        ( kGetDirectoryEntryData( pstFileHandle->iDirectoryEntryOffset, &stEntry)
            == FALSE ) )
    {
        return FALSE;
    }
    
    // 파일 크기와 시작 클러스터를 변경
    stEntry.dwFileSize = pstFileHandle->dwFileSize;
    stEntry.dwStartClusterIndex = pstFileHandle->dwStartClusterIndex;

    // 변경된 디렉터리 엔트리를 설정
    if( kSetDirectoryEntryData( pstFileHandle->iDirectoryEntryOffset, &stEntry )
            == FALSE )
    {
        return FALSE;
    }
    return TRUE;
}

/**
 *  버퍼의 데이터를 파일에 씀
 */
DWORD kWriteFile( const void* pvBuffer, DWORD dwSize, DWORD dwCount, FILE* pstFile )
{
    DWORD dwWriteCount;
    DWORD dwTotalCount;
    DWORD dwOffsetInCluster;
    DWORD dwCopySize;
    DWORD dwAllocatedClusterIndex;
    DWORD dwNextClusterIndex;
    FILEHANDLE* pstFileHandle;

    // 핸들이 파일 타입이 아니면 실패
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return 0;
    }
    pstFileHandle = &( pstFile->stFileHandle );

    // 총 바이트 수
    dwTotalCount = dwSize * dwCount;
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );

    // 다 쓸 때까지 반복
    dwWriteCount = 0;
    while( dwWriteCount != dwTotalCount )
    {
        //======================================================================
        // 현재 클러스터가 파일의 끝이면 클러스터를 할당하여 연결
        //======================================================================
        if( pstFileHandle->dwCurrentClusterIndex == FILESYSTEM_LASTCLUSTER )
        {
            // 빈 클러스터 검색
            dwAllocatedClusterIndex = kFindFreeCluster();
            if( dwAllocatedClusterIndex == FILESYSTEM_LASTCLUSTER )
            {
                break;
            }
            
            // 검색된 클러스터를 마지막 클러스터로 설정
            if( kSetClusterLinkData( dwAllocatedClusterIndex, FILESYSTEM_LASTCLUSTER )
                    == FALSE )
            {
                break;
            }
            
            // 파일의 마지막 클러스터에 할당된 클러스터를 연결
            if( kSetClusterLinkData( pstFileHandle->dwPreviousClusterIndex, 
                                     dwAllocatedClusterIndex ) == FALSE )
            {
                // 실패할 경우 할당된 클러스터를 해제
                kSetClusterLinkData( dwAllocatedClusterIndex, FILESYSTEM_FREECLUSTER );
                break;
            }
            
            // 현재 클러스터를 할당된 것으로 변경
            pstFileHandle->dwCurrentClusterIndex = dwAllocatedClusterIndex;
            
            // 새로 할당받았으니 임시 클러스터 버퍼를 0으로 채움
            kMemSet( gs_vbTempBuffer, 0, FILESYSTEM_LASTCLUSTER );
        }        
        //======================================================================
        // 한 클러스터를 채우지 못하면 클러스터를 읽어서 임시 클러스터 버퍼로 복사
        //======================================================================
        else if( ( ( pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE ) != 0 ) ||
                 ( ( dwTotalCount - dwWriteCount ) < FILESYSTEM_CLUSTERSIZE ) )
        {
            // 전체 클러스터를 덮어쓰는 경우가 아니면 부분만 덮어써야 하므로 
            // 현재 클러스터를 읽음
            if( kReadCluster( pstFileHandle->dwCurrentClusterIndex, 
                              gs_vbTempBuffer ) == FALSE )
            {
                break;
            }
        }

        // 클러스터 내에서 파일 포인터가 존재하는 오프셋을 계산
        dwOffsetInCluster = pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE;
        
        // 여러 클러스터에 걸쳐져 있다면 현재 클러스터에서 남은 만큼 쓰고 다음 
        // 클러스터로 이동
        dwCopySize = MIN( FILESYSTEM_CLUSTERSIZE - dwOffsetInCluster, 
                          dwTotalCount - dwWriteCount );
        kMemCpy( gs_vbTempBuffer + dwOffsetInCluster, ( char* ) pvBuffer + 
                 dwWriteCount, dwCopySize );
        
        // 임시 버퍼에 삽입된 값을 디스크에 씀
        if( kWriteCluster( pstFileHandle->dwCurrentClusterIndex, gs_vbTempBuffer ) 
                == FALSE )
        {
            break;
        }
        
        // 쓴 바이트 수와 파일 포인터의 위치를 갱신
        dwWriteCount += dwCopySize;
        pstFileHandle->dwCurrentOffset += dwCopySize;

        //======================================================================
        // 현재 클러스터의 끝까지 다 썼으면 다음 클러스터로 이동
        //======================================================================
        if( ( pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE ) == 0 )
        {
            // 현재 클러스터의 링크 데이터로 다음 클러스터를 얻음
            if( kGetClusterLinkData( pstFileHandle->dwCurrentClusterIndex, 
                                     &dwNextClusterIndex ) == FALSE )
            {
                break;
            }
            
            // 클러스터 정보를 갱신
            pstFileHandle->dwPreviousClusterIndex = 
                pstFileHandle->dwCurrentClusterIndex;
            pstFileHandle->dwCurrentClusterIndex = dwNextClusterIndex;
        }
    }

    //==========================================================================
    // 파일 크기가 변했다면 루트 디렉터리에 있는 디렉터리 엔트리 정보를 갱신
    //==========================================================================
    if( pstFileHandle->dwFileSize < pstFileHandle->dwCurrentOffset )
    {
        pstFileHandle->dwFileSize = pstFileHandle->dwCurrentOffset;
        kUpdateDirectoryEntry( pstFileHandle );
    }
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    
    // 쓴 레코드 수를 반환
    return ( dwWriteCount / dwSize );
}

/**
 *  파일을 Count만큼 0으로 채움
 */
BOOL kWriteZero( FILE* pstFile, DWORD dwCount )
{
    BYTE* pbBuffer;
    DWORD dwRemainCount;
    DWORD dwWriteCount;
    
    // 핸들이 NULL이면 실패
    if( pstFile == NULL )
    {
        return FALSE;
    }
    
    // 속도 향상을 위해 메모리를 할당 받아 클러스터 단위로 쓰기 수행
    // 메모리를 할당
    pbBuffer = ( BYTE* ) kAllocateMemory( FILESYSTEM_CLUSTERSIZE );
    if( pbBuffer == NULL )
    {
        return FALSE;
    }
    
    // 0으로 채움
    kMemSet( pbBuffer, 0, FILESYSTEM_CLUSTERSIZE );
    dwRemainCount = dwCount;
    
    // 클러스터 단위로 반복해서 쓰기 수행
    while( dwRemainCount != 0 )
    {
        dwWriteCount = MIN( dwRemainCount , FILESYSTEM_CLUSTERSIZE );
        if( kWriteFile( pbBuffer, 1, dwWriteCount, pstFile ) != dwWriteCount )
        {
            kFreeMemory( pbBuffer );
            return FALSE;
        }
        dwRemainCount -= dwWriteCount;
    }
    kFreeMemory( pbBuffer );
    return TRUE;
}

/**
 *  파일 포인터의 위치를 이동
 */
int kSeekFile( FILE* pstFile, int iOffset, int iOrigin )
{
    DWORD dwRealOffset;
    DWORD dwClusterOffsetToMove;
    DWORD dwCurrentClusterOffset;
    DWORD dwLastClusterOffset;
    DWORD dwMoveCount;
    DWORD i;
    DWORD dwStartClusterIndex;
    DWORD dwPreviousClusterIndex;
    DWORD dwCurrentClusterIndex;
    FILEHANDLE* pstFileHandle;

    // 핸들이 파일 타입이 아니면 나감
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return 0;
    }
    pstFileHandle = &( pstFile->stFileHandle );
    
    //==========================================================================
    // Origin과 Offset을 조합하여 파일 시작을 기준으로 파일 포인터를 옮겨야 할 위치를 
    // 계산
    //==========================================================================
    // 옵션에 따라서 실제 위치를 계산
    // 음수이면 파일의 시작 방향으로 이동하며 양수이면 파일의 끝 방향으로 이동
    switch( iOrigin )
    {
    // 파일의 시작을 기준으로 이동
    case FILESYSTEM_SEEK_SET:
        // 파일의 처음이므로 이동할 오프셋이 음수이면 0으로 설정
        if( iOffset <= 0 )
        {
            dwRealOffset = 0;
        }
        else
        {
            dwRealOffset = iOffset;
        }
        break;

    // 현재 위치를 기준으로 이동
    case FILESYSTEM_SEEK_CUR:
        // 이동할 오프셋이 음수이고 현재 파일 포인터의 값보다 크다면
        // 더 이상 갈 수 없으므로 파일의 처음으로 이동
        if( ( iOffset < 0 ) && 
            ( pstFileHandle->dwCurrentOffset <= ( DWORD ) -iOffset ) )
        {
            dwRealOffset = 0;
        }
        else
        {
            dwRealOffset = pstFileHandle->dwCurrentOffset + iOffset;
        }
        break;

    // 파일의 끝부분을 기준으로 이동
    case FILESYSTEM_SEEK_END:
        // 이동할 오프셋이 음수이고 현재 파일 포인터의 값보다 크다면 
        // 더 이상 갈 수 없으므로 파일의 처음으로 이동
        if( ( iOffset < 0 ) && 
            ( pstFileHandle->dwFileSize <= ( DWORD ) -iOffset ) )
        {
            dwRealOffset = 0;
        }
        else
        {
            dwRealOffset = pstFileHandle->dwFileSize + iOffset;
        }
        break;
    }

    //==========================================================================
    // 파일을 구성하는 클러스터의 개수와 현재 파일 포인터의 위치를 고려하여
    // 옮겨질 파일 포인터가 위치하는 클러스터까지 클러스터 링크를 탐색
    //==========================================================================
    // 파일의 마지막 클러스터의 오프셋
    dwLastClusterOffset = pstFileHandle->dwFileSize / FILESYSTEM_CLUSTERSIZE;
    // 파일 포인터가 옮겨질 위치의 클러스터 오프셋
    dwClusterOffsetToMove = dwRealOffset / FILESYSTEM_CLUSTERSIZE;
    // 현재 파일 포인터가 있는 클러스터의 오프셋
    dwCurrentClusterOffset = pstFileHandle->dwCurrentOffset / FILESYSTEM_CLUSTERSIZE;

    // 이동하는 클러스터의 위치가 파일의 마지막 클러스터의 오프셋을 넘어서면
    // 현재 클러스터에서 마지막까지 이동한 후, Write 함수를 이용해서 공백으로 나머지를
    // 채움
    if( dwLastClusterOffset < dwClusterOffsetToMove )
    {
        dwMoveCount = dwLastClusterOffset - dwCurrentClusterOffset;
        dwStartClusterIndex = pstFileHandle->dwCurrentClusterIndex;
    }
    // 이동하는 클러스터의 위치가 현재 클러스터와 같거나 다음에 위치해
    // 있다면 현재 클러스터를 기준으로 차이만큼만 이동하면 된다.
    else if( dwCurrentClusterOffset <= dwClusterOffsetToMove )
    {
        dwMoveCount = dwClusterOffsetToMove - dwCurrentClusterOffset;
        dwStartClusterIndex = pstFileHandle->dwCurrentClusterIndex;
    }
    // 이동하는 클러스터의 위치가 현재 클러스터 이전에 있다면, 첫 번째 클러스터부터
    // 이동하면서 검색
    else
    {
        dwMoveCount = dwClusterOffsetToMove;
        dwStartClusterIndex = pstFileHandle->dwStartClusterIndex;
    }

    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );

    // 클러스터를 이동
    dwCurrentClusterIndex = dwStartClusterIndex;
    for( i = 0 ; i < dwMoveCount ; i++ )
    {
        // 값을 보관
        dwPreviousClusterIndex = dwCurrentClusterIndex;
        
        // 다음 클러스터의 인덱스를 읽음
        if( kGetClusterLinkData( dwPreviousClusterIndex, &dwCurrentClusterIndex ) ==
            FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return -1;
        }
    }

    // 클러스터를 이동했으면 클러스터 정보를 갱신
    if( dwMoveCount > 0 )
    {
        pstFileHandle->dwPreviousClusterIndex = dwPreviousClusterIndex;
        pstFileHandle->dwCurrentClusterIndex = dwCurrentClusterIndex;
    }
    // 첫 번째 클러스터로 이동하는 경우는 핸들의 클러스터 값을 시작 클러스터로 설정
    else if( dwStartClusterIndex == pstFileHandle->dwStartClusterIndex )
    {
        pstFileHandle->dwPreviousClusterIndex = pstFileHandle->dwStartClusterIndex;
        pstFileHandle->dwCurrentClusterIndex = pstFileHandle->dwStartClusterIndex;
    }
    
    //==========================================================================
    // 파일 포인터를 갱신하고 파일 오프셋이 파일의 크기를 넘었다면 나머지 부분을
    // 0으로 채워서 파일의 크기를 늘림
    //==========================================================================
    // 실제 파일의 크기를 넘어서 파일 포인터가 이동했다면, 파일 끝에서부터 
    // 남은 크기만큼 0으로 채워줌
    if( dwLastClusterOffset < dwClusterOffsetToMove )
    {
        pstFileHandle->dwCurrentOffset = pstFileHandle->dwFileSize;
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );

        // 남은 크기만큼 0으로 채움
        if( kWriteZero( pstFile, dwRealOffset - pstFileHandle->dwFileSize )
                == FALSE )
        {
            return 0;
        }
    }

    pstFileHandle->dwCurrentOffset = dwRealOffset;

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );

    return 0;    
}

/**
 *  파일을 닫음
 */
int kCloseFile( FILE* pstFile )
{
    // 핸들 타입이 파일이 아니면 실패
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return -1;
    }
    
    // 핸들을 반환
    kFreeFileDirectoryHandle( pstFile );
    return 0;
}

/**
 *  핸들 풀을 검사하여 파일이 열려있는지를 확인
 */
BOOL kIsFileOpened( const DIRECTORYENTRY* pstEntry )
{
    int i;
    FILE* pstFile;
    
    // 핸들 풀의 시작 어드레스부터 끝까지 열린 파일만 검색
    pstFile = gs_stFileSystemManager.pstHandlePool;
    for( i = 0 ; i < FILESYSTEM_HANDLE_MAXCOUNT ; i++ )
    {
        // 파일 타입 중에서 시작 클러스터가 일치하면 반환
        if( ( pstFile[ i ].bType == FILESYSTEM_TYPE_FILE ) &&
            ( pstFile[ i ].stFileHandle.dwStartClusterIndex == 
              pstEntry->dwStartClusterIndex ) )
        {
            return TRUE;
        }
    }
    return FALSE;
}

/**
 *  파일을 삭제
 */
int kRemoveFile( const char* pcFileName )
{
    DIRECTORYENTRY stEntry;
    int iDirectoryEntryOffset;
    int iFileNameLength;

    // 파일 이름 검사
    iFileNameLength = kStrLen( pcFileName );
    if( ( iFileNameLength > ( sizeof( stEntry.vcFileName ) - 1 ) ) || 
        ( iFileNameLength == 0 ) )
    {
        return NULL;
    }
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 파일이 존재하는가 확인
    iDirectoryEntryOffset = kFindDirectoryEntry( pcFileName, &stEntry );
    if( iDirectoryEntryOffset == -1 ) 
    { 
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }
    
    // 다른 태스크에서 해당 파일을 열고 있는지 핸들 풀을 검색하여 확인
    // 파일이 열려 있으면 삭제할 수 없음
    if( kIsFileOpened( &stEntry ) == TRUE )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }
    
    // 파일을 구성하는 클러스터를 모두 해제
    if( kFreeClusterUntilEnd( stEntry.dwStartClusterIndex ) == FALSE )
    { 
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }

    // 디렉터리 엔트리를 빈 것으로 설정
    kMemSet( &stEntry, 0, sizeof( stEntry ) );
    if( kSetDirectoryEntryData( iDirectoryEntryOffset, &stEntry ) == FALSE )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return 0;
}

/**
 *  디렉터리를 엶
 */
DIR* kOpenDirectory( const char* pcDirectoryName )
{
    DIR* pstDirectory;
    DIRECTORYENTRY* pstDirectoryBuffer;
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 루트 디렉터리 밖에 없으므로 디렉터리 이름은 무시하고 핸들만 할당받아서 반환
    pstDirectory = kAllocateFileDirectoryHandle();
    if( pstDirectory == NULL )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
    }
    
    // 루트 디렉터리를 저장할 버퍼를 할당
    pstDirectoryBuffer = ( DIRECTORYENTRY* ) kAllocateMemory( FILESYSTEM_CLUSTERSIZE );
    if( pstDirectory == NULL )
    {
        // 실패하면 핸들을 반환해야 함
        kFreeFileDirectoryHandle( pstDirectory );
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
    }
    
    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, ( BYTE* ) pstDirectoryBuffer ) == FALSE )
    {
        // 실패하면 핸들과 메모리를 모두 반환해야 함
        kFreeFileDirectoryHandle( pstDirectory );
        kFreeMemory( pstDirectoryBuffer );
        
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
        
    }
    
    // 디렉터리 타입으로 설정하고 현재 디렉터리 엔트리의 오프셋을 초기화
    pstDirectory->bType = FILESYSTEM_TYPE_DIRECTORY;
    pstDirectory->stDirectoryHandle.iCurrentOffset = 0;
    pstDirectory->stDirectoryHandle.pstDirectoryBuffer = pstDirectoryBuffer;

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return pstDirectory;
}

/**
 *  디렉터리 엔트리를 반환하고 다음으로 이동
 */
struct kDirectoryEntryStruct* kReadDirectory( DIR* pstDirectory )
{
    DIRECTORYHANDLE* pstDirectoryHandle;
    DIRECTORYENTRY* pstEntry;
    
    // 핸들 타입이 디렉터리가 아니면 실패
    if( ( pstDirectory == NULL ) ||
        ( pstDirectory->bType != FILESYSTEM_TYPE_DIRECTORY ) )
    {
        return NULL;
    }
    pstDirectoryHandle = &( pstDirectory->stDirectoryHandle );
    
    // 오프셋의 범위가 클러스터에 존재하는 최댓값을 넘어서면 실패
    if( ( pstDirectoryHandle->iCurrentOffset < 0 ) ||
        ( pstDirectoryHandle->iCurrentOffset >= FILESYSTEM_MAXDIRECTORYENTRYCOUNT ) )
    {
        return NULL;
    }

    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 루트 디렉터리에 있는 최대 디렉터리 엔트리의 개수만큼 검색
    pstEntry = pstDirectoryHandle->pstDirectoryBuffer;
    while( pstDirectoryHandle->iCurrentOffset < FILESYSTEM_MAXDIRECTORYENTRYCOUNT )
    {
        // 파일이 존재하면 해당 디렉터리 엔트리를 반환
        if( pstEntry[ pstDirectoryHandle->iCurrentOffset ].dwStartClusterIndex
                != 0 )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return &( pstEntry[ pstDirectoryHandle->iCurrentOffset++ ] );
        }
        
        pstDirectoryHandle->iCurrentOffset++;
    }

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return NULL;
}

/**
 *  디렉터리 포인터를 디렉터리의 처음으로 이동
 */
void kRewindDirectory( DIR* pstDirectory )
{
    DIRECTORYHANDLE* pstDirectoryHandle;
    
    // 핸들 타입이 디렉터리가 아니면 실패
    if( ( pstDirectory == NULL ) ||
        ( pstDirectory->bType != FILESYSTEM_TYPE_DIRECTORY ) )
    {
        return ;
    }
    pstDirectoryHandle = &( pstDirectory->stDirectoryHandle );
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 디렉터리 엔트리의 포인터만 0으로 바꿔줌
    pstDirectoryHandle->iCurrentOffset = 0;
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
}


/**
 *  열린 디렉터리를 닫음
 */
int kCloseDirectory( DIR* pstDirectory )
{
    DIRECTORYHANDLE* pstDirectoryHandle;
    
    // 핸들 타입이 디렉터리가 아니면 실패
    if( ( pstDirectory == NULL ) ||
        ( pstDirectory->bType != FILESYSTEM_TYPE_DIRECTORY ) )
    {
        return -1;
    }
    pstDirectoryHandle = &( pstDirectory->stDirectoryHandle );

    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 루트 디렉터리의 버퍼를 해제하고 핸들을 반환
    kFreeMemory( pstDirectoryHandle->pstDirectoryBuffer );
    kFreeFileDirectoryHandle( pstDirectory );    
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );

    return 0;
}

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
/**
 *  파일 시스템 캐시를 모두 하드 디스크에 씀
 */
BOOL kFlushFileSystemCache( void )
{
    CACHEBUFFER* pstCacheBuffer;
    int iCacheCount;
    int i;
    
    // 캐시가 비활성화 되었다면 함수를 수행할 필요가 없음
    if( gs_stFileSystemManager.bCacheEnable == FALSE )
    {
        return TRUE;
    }
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 클러스터 링크 테이블 영역의 캐시 정보를 얻어서 내용이 변한 캐시 버퍼를 모두
    // 디스크에 씀
    kGetCacheBufferAndCount( CACHE_CLUSTERLINKTABLEAREA, &pstCacheBuffer, 
            &iCacheCount );
    for( i = 0 ; i < iCacheCount ; i++ )
    {
        // 캐시의 내용이 변했다면 태그에 저장된 위치에 직접 씀
        if( pstCacheBuffer[ i ].bChanged == TRUE )
        {
            if( kInternalWriteClusterLinkTableWithoutCache( 
                pstCacheBuffer[ i ].dwTag, pstCacheBuffer[ i ].pbBuffer ) == FALSE )
            {
                return FALSE;
            }
            // 버퍼의 내용을 하드 디스크에 썼으므로, 변경되지 않은 것으로 설정
            pstCacheBuffer[ i ].bChanged = FALSE;
        }
    }
    
    // 데이터 영역의 캐시 정보를 얻어서 내용이 변한 캐시 버퍼를 모두 디스크에 씀
    kGetCacheBufferAndCount( CACHE_DATAAREA, &pstCacheBuffer, &iCacheCount );
    for( i = 0 ; i < iCacheCount ; i++ )
    {
        // 캐시의 내용이 변했다면 태그에 저장된 위치에 직접 씀
        if( pstCacheBuffer[ i ].bChanged == TRUE )
        {
            if( kInternalWriteClusterWithoutCache( pstCacheBuffer[ i ].dwTag, 
                pstCacheBuffer[ i ].pbBuffer ) == FALSE )
            {
                return FALSE;
            }
            // 버퍼의 내용을 하드 디스크에 썼으므로, 변경되지 않은 것으로 설정
            pstCacheBuffer[ i ].bChanged = FALSE;
        }
    }
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return TRUE;
}

///////////////////////////////////////////////////////////////////
```

#### 02.Kernel64/Source/FileSystem.c

```c
#include "FileSystem.h"
#include "HardDisk.h"
#include "DynamicMemory.h"
#include "Task.h"
#include "Utility.h"
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
#include "CacheManager.h"
#include "RAMDisk.h"
///////////////////////////////////////////////////////////////////

// 파일 시스템 자료구조
static FILESYSTEMMANAGER   gs_stFileSystemManager;
// 파일 시스템 임시 버퍼
static BYTE gs_vbTempBuffer[ FILESYSTEM_SECTORSPERCLUSTER * 512 ];

// 하드 디스크 제어에 관련된 함수 포인터 선언
fReadHDDInformation gs_pfReadHDDInformation = NULL;
fReadHDDSector gs_pfReadHDDSector = NULL;
fWriteHDDSector gs_pfWriteHDDSector = NULL;

/**
 *  파일 시스템을 초기화
 */
BOOL kInitializeFileSystem( void )
{
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    BOOL bCacheEnable = FALSE;
///////////////////////////////////////////////////////////////////

    // 자료구조 초기화와 동기화 객체 초기화
    kMemSet( &gs_stFileSystemManager, 0, sizeof( gs_stFileSystemManager ) );
    kInitializeMutex( &( gs_stFileSystemManager.stMutex ) );
    
    // 하드 디스크를 초기화
    if( kInitializeHDD() == TRUE )
    {
        // 초기화가 성공하면 함수 포인터를 하드 디스크용 함수로 설정
        gs_pfReadHDDInformation = kReadHDDInformation;
        gs_pfReadHDDSector = kReadHDDSector;
        gs_pfWriteHDDSector = kWriteHDDSector;

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
        // 캐시를 활성화한다.
        bCacheEnable = TRUE;
///////////////////////////////////////////////////////////////////
    }
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 하드 디스크 초기화가 실패하면 8MB 크기의 램 디스크를 생성
    else if(kInitializeRDD(RDD_TOTALSECTORCOUNT) == TRUE)
    {
        // 초기화가 성공하면 함수 포인터를 램 디스크용 함수로 설정
        gs_pfReadHDDInformation = kReadRDDInformation;
        gs_pfReadHDDSector = kReadRDDSector;
        gs_pfWriteHDDSector = kWriteRDDSector;
        
        // 램 디스크는 데이터가 남아있지 않으므로 매번 파일 시스템을 생성함
        if( kFormat() == FALSE )
        {
            return FALSE;
        }   
    }
///////////////////////////////////////////////////////////////////
    else
    {
        return FALSE;
    }
    
    // 파일 시스템 연결
    if( kMount() == FALSE )
    {
        return FALSE;
    }
    
    // 핸들을 위한 공간을 할당
    gs_stFileSystemManager.pstHandlePool = ( FILE* ) kAllocateMemory( 
        FILESYSTEM_HANDLE_MAXCOUNT * sizeof( FILE ) );
    
    // 메모리 할당이 실패하면 하드 디스크가 인식되지 않은 것으로 설정
    if( gs_stFileSystemManager.pstHandlePool == NULL )
    {
        gs_stFileSystemManager.bMounted = FALSE;
        return FALSE;
    }
    
    // 핸들 풀을 모두 0으로 설정하여 초기화
    kMemSet( gs_stFileSystemManager.pstHandlePool, 0, 
            FILESYSTEM_HANDLE_MAXCOUNT * sizeof( FILE ) );    
    
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 활성화
    if( bCacheEnable == TRUE )
    {
        gs_stFileSystemManager.bCacheEnable = kInitializeCacheManager();    
    }
///////////////////////////////////////////////////////////////////

    return TRUE;
}

//==============================================================================
//  저수준 함수(Low Level Function)
//==============================================================================
/**
 *  하드 디스크의 MBR을 읽어서 MINT 파일 시스템인지 확인
 *      MINT 파일 시스템이라면 파일 시스템에 관련된 각종 정보를 읽어서
 *      자료구조에 삽입
 */
BOOL kMount( void )
{
    MBR* pstMBR;
    
    // 동기화 처리
    kLock( &( gs_stFileSystemManager.stMutex ) );

    // MBR을 읽음
    if( gs_pfReadHDDSector( TRUE, TRUE, 0, 1, gs_vbTempBuffer ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }
    
    // 시그너처를 확인하여 같다면 자료구조에 각 영역에 대한 정보 삽입
    pstMBR = ( MBR* ) gs_vbTempBuffer;
    if( pstMBR->dwSignature != FILESYSTEM_SIGNATURE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }
    
    // 파일 시스템 인식 성공
    gs_stFileSystemManager.bMounted = TRUE;
    
    // 각 영역의 시작 LBA 어드레스와 섹터 수를 계산
    gs_stFileSystemManager.dwReservedSectorCount = pstMBR->dwReservedSectorCount;
    gs_stFileSystemManager.dwClusterLinkAreaStartAddress =
        pstMBR->dwReservedSectorCount + 1;
    gs_stFileSystemManager.dwClusterLinkAreaSize = pstMBR->dwClusterLinkSectorCount;
    gs_stFileSystemManager.dwDataAreaStartAddress = 
        pstMBR->dwReservedSectorCount + pstMBR->dwClusterLinkSectorCount + 1;
    gs_stFileSystemManager.dwTotalClusterCount = pstMBR->dwTotalClusterCount;

    // 동기화 처리
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return TRUE;
}

/**
 *  하드 디스크에 파일 시스템을 생성
 */
BOOL kFormat( void )
{
    HDDINFORMATION* pstHDD;
    MBR* pstMBR;
    DWORD dwTotalSectorCount, dwRemainSectorCount;
    DWORD dwMaxClusterCount, dwClsuterCount;
    DWORD dwClusterLinkSectorCount;
    DWORD i;
    
    // 동기화 처리
    kLock( &( gs_stFileSystemManager.stMutex ) );

    //==========================================================================
    //  하드 디스크 정보를 읽어서 메타 영역의 크기와 클러스터의 개수를 계산
    //==========================================================================
    // 하드 디스크의 정보를 얻어서 하드 디스크의 총 섹터 수를 구함
    pstHDD = ( HDDINFORMATION* ) gs_vbTempBuffer;
    if( gs_pfReadHDDInformation( TRUE, TRUE, pstHDD ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }    
    dwTotalSectorCount = pstHDD->dwTotalSectors;
    
    // 전체 섹터 수를 4Kbyte, 즉 클러스터 크기로 나누어 최대 클러스터 수를 계산
    dwMaxClusterCount = dwTotalSectorCount / FILESYSTEM_SECTORSPERCLUSTER;
    
    // 최대 클러스터의 수에 맞추어 클러스터 링크 테이블의 섹터 수를 계산
    // 링크 데이터는 4바이트이므로, 한 섹터에는 128개가 들어감. 따라서 총 개수를
    // 128로 나눈 후 올림하여 클러스터 링크의 섹터 수를 구함
    dwClusterLinkSectorCount = ( dwMaxClusterCount + 127 ) / 128;
    
    // 예약된 영역은 현재 사용하지 않으므로, 디스크 전체 영역에서 MBR 영역과 클러스터
    // 링크 테이블 영역의 크기를 뺀 나머지가 실제 데이터 영역이 됨
    // 해당 영역을 클러스터 크기로 나누어 실제 클러스터의 개수를 구함
    dwRemainSectorCount = dwTotalSectorCount - dwClusterLinkSectorCount - 1;
    dwClsuterCount = dwRemainSectorCount / FILESYSTEM_SECTORSPERCLUSTER;
    
    // 실제 사용 가능한 클러스터 수에 맞추어 다시 한번 계산
    dwClusterLinkSectorCount = ( dwClsuterCount + 127 ) / 128;

    //==========================================================================
    // 계산된 정보를 MBR에 덮어 쓰고, 루트 디렉터리 영역까지 모두 0으로 초기화하여
    // 파일 시스템을 생성
    //==========================================================================
    // MBR 영역 읽기
    if( gs_pfReadHDDSector( TRUE, TRUE, 0, 1, gs_vbTempBuffer ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }        
    
    // 파티션 정보와 파일 시스템 정보 설정    
    pstMBR = ( MBR* ) gs_vbTempBuffer;
    kMemSet( pstMBR->vstPartition, 0, sizeof( pstMBR->vstPartition ) );
    pstMBR->dwSignature = FILESYSTEM_SIGNATURE;
    pstMBR->dwReservedSectorCount = 0;
    pstMBR->dwClusterLinkSectorCount = dwClusterLinkSectorCount;
    pstMBR->dwTotalClusterCount = dwClsuterCount;
    
    // MBR 영역에 1 섹터를 씀
    if( gs_pfWriteHDDSector( TRUE, TRUE, 0, 1, gs_vbTempBuffer ) == FALSE )
    {
        // 동기화 처리
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return FALSE;
    }
    
    // MBR 이후부터 루트 디렉터리까지 모두 0으로 초기화
    kMemSet( gs_vbTempBuffer, 0, 512 );
    for( i = 0 ; i < ( dwClusterLinkSectorCount + FILESYSTEM_SECTORSPERCLUSTER );
         i++ )
    {
        // 루트 디렉터리(클러스터 0)는 이미 파일 시스템이 사용하고 있으므로,
        // 할당된 것으로 표시
        if( i == 0 )
        {
            ( ( DWORD* ) ( gs_vbTempBuffer ) )[ 0 ] = FILESYSTEM_LASTCLUSTER;
        }
        else
        {
            ( ( DWORD* ) ( gs_vbTempBuffer ) )[ 0 ] = FILESYSTEM_FREECLUSTER;
        }
        
        // 1 섹터씩 씀
        if( gs_pfWriteHDDSector( TRUE, TRUE, i + 1, 1, gs_vbTempBuffer ) == FALSE )
        {
            // 동기화 처리
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return FALSE;
        }
    }    

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 버퍼를 모두 버림
    if( gs_stFileSystemManager.bCacheEnable == TRUE )
    {
        kDiscardAllCacheBuffer( CACHE_CLUSTERLINKTABLEAREA );
        kDiscardAllCacheBuffer( CACHE_DATAAREA );
    }
///////////////////////////////////////////////////////////////////
    
    // 동기화 처리
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return TRUE;
}

/**
 *  파일 시스템에 연결된 하드 디스크의 정보를 반환
 */
BOOL kGetHDDInformation( HDDINFORMATION* pstInformation)
{
    BOOL bResult;
    
    // 동기화 처리
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    bResult = gs_pfReadHDDInformation( TRUE, TRUE, pstInformation );
    
    // 동기화 처리
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    
    return bResult;
}

/**
 *  클러스터 링크 테이블 내의 오프셋에서 한 섹터를 읽음
 */
static BOOL kReadClusterLinkTable( DWORD dwOffset, BYTE* pbBuffer )
{
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 여부에 따라 다른 읽기 함수 호출
    if( gs_stFileSystemManager.bCacheEnable == FALSE )
    {
        kInternalReadClusterLinkTableWithoutCache( dwOffset, pbBuffer );
    }
    else
    {
        kInternalReadClusterLinkTableWithCache( dwOffset, pbBuffer );
    }
///////////////////////////////////////////////////////////////////
}

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
/**
 *  클러스터 링크 테이블 내의 오프셋에서 한 섹터를 읽음
 *      내부적으로 사용하는 함수, 캐시 사용 안함
 */
static BOOL kInternalReadClusterLinkTableWithoutCache( DWORD dwOffset, 
        BYTE* pbBuffer )
{
    // 클러스터 링크 테이블 영역의 시작 어드레스를 더함
    return gs_pfReadHDDSector( TRUE, TRUE, dwOffset + 
              gs_stFileSystemManager.dwClusterLinkAreaStartAddress, 1, pbBuffer );
}

/**
 *  클러스터 링크 테이블 내의 오프셋에서 한 섹터를 읽음
 *      내부적으로 사용하는 함수, 캐시 사용
 */
static BOOL kInternalReadClusterLinkTableWithCache( DWORD dwOffset, 
        BYTE* pbBuffer )
{
    CACHEBUFFER* pstCacheBuffer;
    
    // 먼저 캐시에 해당 클러스터 링크 테이블이 있는지 확인
    pstCacheBuffer = kFindCacheBuffer( CACHE_CLUSTERLINKTABLEAREA, dwOffset );

    // 캐시 버퍼에 있다면 캐시의 내용을 복사
    if( pstCacheBuffer != NULL )
    {
        kMemCpy( pbBuffer, pstCacheBuffer->pbBuffer, 512 );
        return TRUE;
    }
    
    // 캐시 버퍼에 없다면 하드 디스크에서 직접 읽음
    if( kInternalReadClusterLinkTableWithoutCache( dwOffset, pbBuffer ) == FALSE )
    {
        return FALSE;
    }
    
    // 캐시를 할당 받아서 캐시 내용을 갱신
    pstCacheBuffer = kAllocateCacheBufferWithFlush( CACHE_CLUSTERLINKTABLEAREA );
    if( pstCacheBuffer == NULL )
    {
        return FALSE;
    }    

    // 캐시 버퍼에 읽은 내용을 복사한 후, 태그 정보를 갱신
    kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, 512 );
    pstCacheBuffer->dwTag = dwOffset;
    
    // 읽기를 수행했으므로 버퍼의 내용을 수정되지 않은 것으로 표시
    pstCacheBuffer->bChanged = FALSE;
    return TRUE;
}

/**
 *  클러스터 링크 테이블 영역의 캐시 버퍼 또는 데이터 영역의 캐시 버퍼에서 할당
 *      빈 캐시 버퍼가 없는 경우 오래된 것 중에 하나를 골라서 비운 후 사용
 */
static CACHEBUFFER* kAllocateCacheBufferWithFlush( int iCacheTableIndex )
{
    CACHEBUFFER* pstCacheBuffer;
    
    // 캐시 버퍼에 없다면 캐시를 할당 받아서 캐시 내용을 갱신
    pstCacheBuffer = kAllocateCacheBuffer( iCacheTableIndex );
    // 캐시를 할당 받을 수 없다면 캐시 버퍼에서 오래된 것을 찾아 버린 후 사용
    if( pstCacheBuffer == NULL )
    {
        pstCacheBuffer = kGetVictimInCacheBuffer( iCacheTableIndex );
        // 오래된 캐시 버퍼도 할당 받을 수 없으면 오류
        if( pstCacheBuffer == NULL )
        {
            kPrintf( "Cache Allocate Fail~!!!!\n" );
            return NULL;
        }

        // 캐시 버퍼의 데이터가 수정되었다면 하드 디스크로 옮겨야 함
        if( pstCacheBuffer->bChanged == TRUE )
        {
            switch( iCacheTableIndex )
            {
                // 클러스터 링크 테이블 영역의 캐시인 경우
            case CACHE_CLUSTERLINKTABLEAREA:
                // 쓰기가 실패한다면 오류
                if( kInternalWriteClusterLinkTableWithoutCache( 
                    pstCacheBuffer->dwTag, pstCacheBuffer->pbBuffer ) == FALSE )
                {
                    kPrintf( "Cache Buffer Write Fail~!!!!\n" );
                    return NULL;
                }
                break;
                
                // 데이터 영역의 캐시인 경우
            case CACHE_DATAAREA:
                // 쓰기가 실패한다면 오류
                if( kInternalWriteClusterWithoutCache( 
                    pstCacheBuffer->dwTag, pstCacheBuffer->pbBuffer ) == FALSE )
                {
                    kPrintf( "Cache Buffer Write Fail~!!!!\n" );
                    return NULL;
                }
                break;
                
                // 기타는 오류
            default:
                kPrintf( "kAllocateCacheBufferWithFlush Fail\n" );
                return NULL;
                break;
            }
        }
    }    
    return pstCacheBuffer;
}
///////////////////////////////////////////////////////////////////

/**
 *  클러스터 링크 테이블 내의 오프셋에 한 섹터를 씀
 */
static BOOL kWriteClusterLinkTable( DWORD dwOffset, BYTE* pbBuffer )
{
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 여부에 따라 다른 쓰기 함수 호출
    if( gs_stFileSystemManager.bCacheEnable == FALSE )
    {
        return kInternalWriteClusterLinkTableWithoutCache( dwOffset, pbBuffer );
    }
    else
    {
        return kInternalWriteClusterLinkTableWithCache( dwOffset, pbBuffer );
    }
///////////////////////////////////////////////////////////////////
}

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
/**
 *  클러스터 링크 테이블 내의 오프셋에 한 섹터를 씀
 *      내부적으로 사용하는 함수, 캐시 사용 안 함
 */
static BOOL kInternalWriteClusterLinkTableWithoutCache( DWORD dwOffset, 
        BYTE* pbBuffer )
{
    // 클러스터 링크 테이블 영역의 시작 어드레스를 더함
    return gs_pfWriteHDDSector( TRUE, TRUE, dwOffset + 
               gs_stFileSystemManager.dwClusterLinkAreaStartAddress, 1, pbBuffer );
}

/**
 *  클러스터 링크 테이블 내의 오프셋에 한 섹터를 씀
 *      내부적으로 사용하는 함수, 캐시 사용
 */
static BOOL kInternalWriteClusterLinkTableWithCache( DWORD dwOffset, 
        BYTE* pbBuffer )
{
    CACHEBUFFER* pstCacheBuffer;
    
    // 캐시에 해당 클러스터 링크 테이블이 있는지 확인
    pstCacheBuffer = kFindCacheBuffer( CACHE_CLUSTERLINKTABLEAREA, dwOffset );

    // 캐시 버퍼에 있다면 캐시에 씀
    if( pstCacheBuffer != NULL )
    {
        kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, 512 );

        // 쓰기를 수행했으므로 버퍼의 내용을 수정된 것으로 표시
        pstCacheBuffer->bChanged = TRUE;  
        return TRUE;
    }
    
    // 캐시 버퍼에 없다면 캐시 버퍼를 할당 받아서 캐시 내용을 갱신
    pstCacheBuffer = kAllocateCacheBufferWithFlush( CACHE_CLUSTERLINKTABLEAREA );
    if( pstCacheBuffer == NULL )
    {
        return FALSE;
    } 

    // 캐시 버퍼에 쓰고, 태그 정보를 갱신
    kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, 512 );
    pstCacheBuffer->dwTag = dwOffset;
    
    // 쓰기를 수행했으므로 버퍼의 내용을 수정된 것으로 표시
    pstCacheBuffer->bChanged = TRUE;  

    return TRUE;
}
///////////////////////////////////////////////////////////////////

/**
 *  데이터 영역의 오프셋에서 한 클러스터를 읽음
 */
static BOOL kReadCluster( DWORD dwOffset, BYTE* pbBuffer )
{
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 여부에 따라 다른 읽기 함수 호출
    if( gs_stFileSystemManager.bCacheEnable == FALSE )
    {
        kInternalReadClusterWithoutCache( dwOffset, pbBuffer );
    }
    else
    {
        kInternalReadClusterWithCache( dwOffset, pbBuffer );
    }
///////////////////////////////////////////////////////////////////
}

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
/**
 *  데이터 영역의 오프셋에서 한 클러스터를 읽음
 *      내부적으로 사용하는 함수, 캐시 사용 안 함
 */
static BOOL kInternalReadClusterWithoutCache( DWORD dwOffset, BYTE* pbBuffer )
{
    // 데이터 영역의 시작 어드레스를 더함
    return gs_pfReadHDDSector( TRUE, TRUE, ( dwOffset * FILESYSTEM_SECTORSPERCLUSTER ) + 
              gs_stFileSystemManager.dwDataAreaStartAddress, 
              FILESYSTEM_SECTORSPERCLUSTER, pbBuffer );
}

/**
 *  데이터 영역의 오프셋에서 한 클러스터를 읽음
 *      내부적으로 사용하는 함수, 캐시 사용
 */
static BOOL kInternalReadClusterWithCache( DWORD dwOffset, BYTE* pbBuffer )
{
    CACHEBUFFER* pstCacheBuffer;
    
    // 캐시에 해당 데이터 클러스터가 있는지 확인
    pstCacheBuffer = kFindCacheBuffer( CACHE_DATAAREA, dwOffset );

    // 캐시 버퍼에 있다면 캐시의 내용을 복사
    if( pstCacheBuffer != NULL )
    {
        kMemCpy( pbBuffer, pstCacheBuffer->pbBuffer, FILESYSTEM_CLUSTERSIZE );
        return TRUE;
    }
    
    // 캐시 버퍼에 없다면 하드 디스크에서 직접 읽음
    if( kInternalReadClusterWithoutCache( dwOffset, pbBuffer ) == FALSE )
    {
        return FALSE;
    }
    
    // 캐시 버퍼를 할당 받아서 캐시 내용을 갱신
    pstCacheBuffer = kAllocateCacheBufferWithFlush( CACHE_DATAAREA );
    if( pstCacheBuffer == NULL )
    {
        return FALSE;
    }    

    // 캐시 버퍼에 읽은 내용을 복사한 후, 태그 정보를 갱신
    kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, FILESYSTEM_CLUSTERSIZE );
    pstCacheBuffer->dwTag = dwOffset;
    
    // 읽기를 수행했으므로 버퍼의 내용을 수정되지 않은 것으로 표시
    pstCacheBuffer->bChanged = FALSE;
    return TRUE;    
}
///////////////////////////////////////////////////////////////////

/**
 *  데이터 영역의 오프셋에 한 클러스터를 씀
 */
static BOOL kWriteCluster( DWORD dwOffset, BYTE* pbBuffer )
{
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 캐시 여부에 따라 다른 쓰기 함수 호출
    if( gs_stFileSystemManager.bCacheEnable == FALSE )
    {
        kInternalWriteClusterWithoutCache( dwOffset, pbBuffer );
    }
    else
    {
        kInternalWriteClusterWithCache( dwOffset, pbBuffer );
    }    
///////////////////////////////////////////////////////////////////
}

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    /**
 *  데이터 영역의 오프셋에 한 클러스터를 씀
 *      내부적으로 사용하는 함수, 캐시 사용 안 함
 */
static BOOL kInternalWriteClusterWithoutCache( DWORD dwOffset, BYTE* pbBuffer )
{
    // 데이터 영역의 시작 어드레스를 더함
    return  gs_pfWriteHDDSector( TRUE, TRUE, ( dwOffset * FILESYSTEM_SECTORSPERCLUSTER ) + 
              gs_stFileSystemManager.dwDataAreaStartAddress, 
              FILESYSTEM_SECTORSPERCLUSTER, pbBuffer );
}

/**
 *  데이터 영역의 오프셋에 한 클러스터를 씀
 *      내부적으로 사용하는 함수, 캐시 사용
 */
static BOOL kInternalWriteClusterWithCache( DWORD dwOffset, BYTE* pbBuffer )
{
    CACHEBUFFER* pstCacheBuffer;
    
    // 캐시 버퍼에 해당 데이터 클러스터가 있는지 확인
    pstCacheBuffer = kFindCacheBuffer( CACHE_DATAAREA, dwOffset );

    // 캐시 버퍼에 있다면 캐시에 씀
    if( pstCacheBuffer != NULL )
    {
        kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, FILESYSTEM_CLUSTERSIZE );

        // 쓰기를 수행했으므로 버퍼의 내용을 수정된 것으로 표시
        pstCacheBuffer->bChanged = TRUE;  

        return TRUE;
    }
    
    // 캐시 버퍼에 없다면 캐시를 할당 받아서 캐시 내용을 갱신
    pstCacheBuffer = kAllocateCacheBufferWithFlush( CACHE_DATAAREA );
    if( pstCacheBuffer == NULL )
    {
        return FALSE;
    } 

    // 캐시 버퍼에 쓰고, 태그 정보를 갱신
    kMemCpy( pstCacheBuffer->pbBuffer, pbBuffer, FILESYSTEM_CLUSTERSIZE );
    pstCacheBuffer->dwTag = dwOffset;
    
    // 쓰기를 수행했으므로 버퍼의 내용을 수정된 것으로 표시
    pstCacheBuffer->bChanged = TRUE;  

    return TRUE;
}
///////////////////////////////////////////////////////////////////

/**
 *  클러스터 링크 테이블 영역에서 빈 클러스터를 검색함
 */
static DWORD kFindFreeCluster( void )
{
    DWORD dwLinkCountInSector;
    DWORD dwLastSectorOffset, dwCurrentSectorOffset;
    DWORD i, j;
    
    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return FILESYSTEM_LASTCLUSTER;
    }
    
    // 마지막으로 클러스터를 할당한 클러스터 링크 테이블의 섹터 오프셋을 가져옴
    dwLastSectorOffset = gs_stFileSystemManager.dwLastAllocatedClusterLinkSectorOffset;

    // 마지막으로 할당한 위치부터 루프를 돌면서 빈 클러스터를 검색
    for( i = 0 ; i < gs_stFileSystemManager.dwClusterLinkAreaSize ; i++ )
    {
        // 클러스터 링크 테이블의 마지막 섹터이면 전체 섹터만큼 도는 것이 아니라
        // 남은 클러스터의 수만큼 루프를 돌아야 함
        if( ( dwLastSectorOffset + i ) == 
            ( gs_stFileSystemManager.dwClusterLinkAreaSize - 1 ) )
        {
            dwLinkCountInSector = gs_stFileSystemManager.dwTotalClusterCount % 128; 
        }
        else
        {
            dwLinkCountInSector = 128;
        }
        
        // 이번에 읽어야 할 클러스터 링크 테이블의 섹터 오프셋을 구해서 읽음
        dwCurrentSectorOffset = ( dwLastSectorOffset + i ) % 
            gs_stFileSystemManager.dwClusterLinkAreaSize;
        if( kReadClusterLinkTable( dwCurrentSectorOffset, gs_vbTempBuffer ) == FALSE )
        {
            return FILESYSTEM_LASTCLUSTER;
        }
        
        // 섹터 내에서 루프를 돌면서 빈 클러스터를 검색
        for( j = 0 ; j < dwLinkCountInSector ; j++ )
        {
            if( ( ( DWORD* ) gs_vbTempBuffer )[ j ] == FILESYSTEM_FREECLUSTER )
            {
                break;
            }
        }
            
        // 찾았다면 클러스터 인덱스를 반환
        if( j != dwLinkCountInSector )
        {
            // 마지막으로 클러스터를 할당한 클러스터 링크 내의 섹터 오프셋을 저장
            gs_stFileSystemManager.dwLastAllocatedClusterLinkSectorOffset = 
                dwCurrentSectorOffset;
            
            // 현재 클러스터 링크 테이블의 오프셋을 감안하여 클러스터 인덱스를 계산
            return ( dwCurrentSectorOffset * 128 ) + j;
        }
    }
    
    return FILESYSTEM_LASTCLUSTER;
}

/**
 *  클러스터 링크 테이블에 값을 설정
 */
static BOOL kSetClusterLinkData( DWORD dwClusterIndex, DWORD dwData )
{
    DWORD dwSectorOffset;
    
    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return FALSE;
    }
    
    // 한 섹터에 128개의 클러스터 링크가 들어가므로 128로 나누면 섹터 오프셋을 
    // 구할 수 있음
    dwSectorOffset = dwClusterIndex / 128;

    // 해당 섹터를 읽어서 링크 정보를 설정한 후, 다시 저장
    if( kReadClusterLinkTable( dwSectorOffset, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    
    ( ( DWORD* ) gs_vbTempBuffer )[ dwClusterIndex % 128 ] = dwData;

    if( kWriteClusterLinkTable( dwSectorOffset, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }

    return TRUE;
}

/**
 *  클러스터 링크 테이블의 값을 반환
 */
static BOOL kGetClusterLinkData( DWORD dwClusterIndex, DWORD* pdwData )
{
    DWORD dwSectorOffset;
    
    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return FALSE;
    }
    
    // 한 섹터에 128개의 클러스터 링크가 들어가므로 128로 나누면 섹터 오프셋을 
    // 구할 수 있음
    dwSectorOffset = dwClusterIndex / 128;
    
    if( dwSectorOffset > gs_stFileSystemManager.dwClusterLinkAreaSize )
    {
        return FALSE;
    }
    
    
    // 해당 섹터를 읽어서 링크 정보를 반환
    if( kReadClusterLinkTable( dwSectorOffset, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    

    *pdwData = ( ( DWORD* ) gs_vbTempBuffer )[ dwClusterIndex % 128 ];
    return TRUE;
}


/**
 *  루트 디렉터리에서 빈 디렉터리 엔트리를 반환
 */
static int kFindFreeDirectoryEntry( void )
{
    DIRECTORYENTRY* pstEntry;
    int i;

    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return -1;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return -1;
    }
    
    // 루트 디렉터리 안에서 루프를 돌면서 빈 엔트리, 즉 시작 클러스터 번호가 0인
    // 엔트리를 검색
    pstEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    for( i = 0 ; i < FILESYSTEM_MAXDIRECTORYENTRYCOUNT ; i++ )
    {
        if( pstEntry[ i ].dwStartClusterIndex == 0 )
        {
            return i;
        }
    }
    return -1;
}

/**
 *  루트 디렉터리의 해당 인덱스에 디렉터리 엔트리를 설정
 */
static BOOL kSetDirectoryEntryData( int iIndex, DIRECTORYENTRY* pstEntry )
{
    DIRECTORYENTRY* pstRootEntry;
    
    // 파일 시스템을 인식하지 못했거나 인덱스가 올바르지 않으면 실패
    if( ( gs_stFileSystemManager.bMounted == FALSE ) ||
        ( iIndex < 0 ) || ( iIndex >= FILESYSTEM_MAXDIRECTORYENTRYCOUNT ) )
    {
        return FALSE;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    
    // 루트 디렉터리에 있는 해당 데이터를 갱신
    pstRootEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    kMemCpy( pstRootEntry + iIndex, pstEntry, sizeof( DIRECTORYENTRY ) );

    // 루트 디렉터리에 씀
    if( kWriteCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    return TRUE;
}

/**
 *  루트 디렉터리의 해당 인덱스에 위치하는 디렉터리 엔트리를 반환
 */
static BOOL kGetDirectoryEntryData( int iIndex, DIRECTORYENTRY* pstEntry )
{
    DIRECTORYENTRY* pstRootEntry;
    
    // 파일 시스템을 인식하지 못했거나 인덱스가 올바르지 않으면 실패
    if( ( gs_stFileSystemManager.bMounted == FALSE ) ||
        ( iIndex < 0 ) || ( iIndex >= FILESYSTEM_MAXDIRECTORYENTRYCOUNT ) )
    {
        return FALSE;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return FALSE;
    }    
    
    // 루트 디렉터리에 있는 해당 데이터를 갱신
    pstRootEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    kMemCpy( pstEntry, pstRootEntry + iIndex, sizeof( DIRECTORYENTRY ) );
    return TRUE;
}

/**
 *  루트 디렉터리에서 파일 이름이 일치하는 엔트리를 찾아서 인덱스를 반환
 */
static int kFindDirectoryEntry( const char* pcFileName, DIRECTORYENTRY* pstEntry )
{
    DIRECTORYENTRY* pstRootEntry;
    int i;
    int iLength;

    // 파일 시스템을 인식하지 못했으면 실패
    if( gs_stFileSystemManager.bMounted == FALSE )
    {
        return -1;
    }

    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, gs_vbTempBuffer ) == FALSE )
    {
        return -1;
    }
    
    iLength = kStrLen( pcFileName );
    // 루트 디렉터리 안에서 루프를 돌면서 파일 이름이 일치하는 엔트리를 반환
    pstRootEntry = ( DIRECTORYENTRY* ) gs_vbTempBuffer;
    for( i = 0 ; i < FILESYSTEM_MAXDIRECTORYENTRYCOUNT ; i++ )
    {
        if( kMemCmp( pstRootEntry[ i ].vcFileName, pcFileName, iLength ) == 0 )
        {
            kMemCpy( pstEntry, pstRootEntry + i, sizeof( DIRECTORYENTRY ) );
            return i;
        }
    }
    return -1;
}

/**
 *  파일 시스템의 정보를 반환
 */
void kGetFileSystemInformation( FILESYSTEMMANAGER* pstManager )
{
    kMemCpy( pstManager, &gs_stFileSystemManager, sizeof( gs_stFileSystemManager ) );
}

//==============================================================================
//  고수준 함수(High Level Function)
//==============================================================================
/**
 *  비어있는 핸들을 할당
 */
static void* kAllocateFileDirectoryHandle( void )
{
    int i;
    FILE* pstFile;
    
    // 핸들 풀(Handle Pool)을 모두 검색하여 비어있는 핸들을 반환
    pstFile = gs_stFileSystemManager.pstHandlePool;
    for( i = 0 ; i < FILESYSTEM_HANDLE_MAXCOUNT ; i++ )
    {
        // 비어있다면 반환
        if( pstFile->bType == FILESYSTEM_TYPE_FREE )
        {
            pstFile->bType = FILESYSTEM_TYPE_FILE;
            return pstFile;
        }
        
        // 다음으로 이동
        pstFile++;
    }
    
    return NULL;
}

/**
 *  사용한 핸들을 반환
 */
static void kFreeFileDirectoryHandle( FILE* pstFile )
{
    // 전체 영역을 초기화
    kMemSet( pstFile, 0, sizeof( FILE ) );
    
    // 비어있는 타입으로 설정
    pstFile->bType = FILESYSTEM_TYPE_FREE;
}

/**
 *  파일을 생성
 */
static BOOL kCreateFile( const char* pcFileName, DIRECTORYENTRY* pstEntry, 
        int* piDirectoryEntryIndex )
{
    DWORD dwCluster;
    
    // 빈 클러스터를 찾아서 할당된 것으로 설정
    dwCluster = kFindFreeCluster();
    if( ( dwCluster == FILESYSTEM_LASTCLUSTER ) ||
        ( kSetClusterLinkData( dwCluster, FILESYSTEM_LASTCLUSTER ) == FALSE ) )
    {
        return FALSE;
    }

    // 빈 디렉터리 엔트리를 검색
    *piDirectoryEntryIndex = kFindFreeDirectoryEntry();
    if( *piDirectoryEntryIndex == -1 )
    {
        // 실패할 경우 할당 받은 클러스터를 반환해야 함
        kSetClusterLinkData( dwCluster, FILESYSTEM_FREECLUSTER );
        return FALSE;
    }
    
    // 디렉터리 엔트리를 설정
    kMemCpy( pstEntry->vcFileName, pcFileName, kStrLen( pcFileName ) + 1 );
    pstEntry->dwStartClusterIndex = dwCluster;
    pstEntry->dwFileSize = 0;
    
    // 디렉터리 엔트리를 등록
    if( kSetDirectoryEntryData( *piDirectoryEntryIndex, pstEntry ) == FALSE )
    {
        // 실패할 경우 할당 받은 클러스터를 반환해야 함
        kSetClusterLinkData( dwCluster, FILESYSTEM_FREECLUSTER );
        return FALSE;
    }
    return TRUE;
}

/**
 *  파라미터로 넘어온 클러스터부터 파일의 끝까지 연결된 클러스터를 모두 반환
 */
static BOOL kFreeClusterUntilEnd( DWORD dwClusterIndex )
{
    DWORD dwCurrentClusterIndex;
    DWORD dwNextClusterIndex;
    
    // 클러스터 인덱스를 초기화
    dwCurrentClusterIndex = dwClusterIndex;
    
    while( dwCurrentClusterIndex != FILESYSTEM_LASTCLUSTER )
    {
        // 다음 클러스터의 인덱스를 가져옴
        if( kGetClusterLinkData( dwCurrentClusterIndex, &dwNextClusterIndex )
                == FALSE )
        {
            return FALSE;
        }
        
        // 현재 클러스터를 빈 것으로 설정하여 해제
        if( kSetClusterLinkData( dwCurrentClusterIndex, FILESYSTEM_FREECLUSTER )
                == FALSE )
        {
            return FALSE;
        }
        
        // 현재 클러스터 인덱스를 다음 클러스터의 인덱스로 바꿈
        dwCurrentClusterIndex = dwNextClusterIndex;
    }
    
    return TRUE;
}

/**
 *  파일을 열거나 생성 
 */
FILE* kOpenFile( const char* pcFileName, const char* pcMode )
{
    DIRECTORYENTRY stEntry;
    int iDirectoryEntryOffset;
    int iFileNameLength;
    DWORD dwSecondCluster;
    FILE* pstFile;

    // 파일 이름 검사
    iFileNameLength = kStrLen( pcFileName );
    if( ( iFileNameLength > ( sizeof( stEntry.vcFileName ) - 1 ) ) || 
        ( iFileNameLength == 0 ) )
    {
        return NULL;
    }
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    //==========================================================================
    // 파일이 먼저 존재하는가 확인하고, 없다면 옵션을 보고 파일을 생성
    //==========================================================================
    iDirectoryEntryOffset = kFindDirectoryEntry( pcFileName, &stEntry );
    if( iDirectoryEntryOffset == -1 )
    {
        // 파일이 없다면 읽기(r, r+) 옵션은 실패
        if( pcMode[ 0 ] == 'r' )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
        
        // 나머지 옵션들은 파일을 생성
        if( kCreateFile( pcFileName, &stEntry, &iDirectoryEntryOffset ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
    }    
    //==========================================================================
    // 파일의 내용을 비워야 하는 옵션이면 파일에 연결된 클러스터를 모두 제거하고
    // 파일 크기를 0으로 설정
    //==========================================================================
    else if( pcMode[ 0 ] == 'w' )
    {
        // 시작 클러스터의 다음 클러스터를 찾음
        if( kGetClusterLinkData( stEntry.dwStartClusterIndex, &dwSecondCluster )
                == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
        
        // 시작 클러스터를 마지막 클러스터로 만듦
        if( kSetClusterLinkData( stEntry.dwStartClusterIndex, 
               FILESYSTEM_LASTCLUSTER ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
        
        // 다음 클러스터부터 마지막 클러스터까지 모두 해제
        if( kFreeClusterUntilEnd( dwSecondCluster ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
       
        // 파일의 내용이 모두 비워졌으므로, 크기를 0으로 설정
        stEntry.dwFileSize = 0;
        if( kSetDirectoryEntryData( iDirectoryEntryOffset, &stEntry ) == FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return NULL;
        }
    }
    
    //==========================================================================
    // 파일 핸들을 할당 받아 데이터를 설정한 후 반환
    //==========================================================================
    // 파일 핸들을 할당 받아 데이터 설정
    pstFile = kAllocateFileDirectoryHandle();
    if( pstFile == NULL )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
    }
    
    // 파일 핸들에 파일 정보를 설정
    pstFile->bType = FILESYSTEM_TYPE_FILE;
    pstFile->stFileHandle.iDirectoryEntryOffset = iDirectoryEntryOffset;
    pstFile->stFileHandle.dwFileSize = stEntry.dwFileSize;
    pstFile->stFileHandle.dwStartClusterIndex = stEntry.dwStartClusterIndex;
    pstFile->stFileHandle.dwCurrentClusterIndex = stEntry.dwStartClusterIndex;
    pstFile->stFileHandle.dwPreviousClusterIndex = stEntry.dwStartClusterIndex;
    pstFile->stFileHandle.dwCurrentOffset = 0;
       
    // 만약 추가 옵션(a)이 설정되어 있으면, 파일의 끝으로 이동
    if( pcMode[ 0 ] == 'a' )
    {
        kSeekFile( pstFile, 0, FILESYSTEM_SEEK_END );
    }

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return pstFile;
}

/**
 *  파일을 읽어 버퍼로 복사
 */
DWORD kReadFile( void* pvBuffer, DWORD dwSize, DWORD dwCount, FILE* pstFile )
{
    DWORD dwTotalCount;
    DWORD dwReadCount;
    DWORD dwOffsetInCluster;
    DWORD dwCopySize;
    FILEHANDLE* pstFileHandle;
    DWORD dwNextClusterIndex;    

    // 핸들이 파일 타입이 아니면 실패
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return 0;
    }
    pstFileHandle = &( pstFile->stFileHandle );
    
    // 파일의 끝이거나 마지막 클러스터이면 종료
    if( ( pstFileHandle->dwCurrentOffset == pstFileHandle->dwFileSize ) ||
        ( pstFileHandle->dwCurrentClusterIndex == FILESYSTEM_LASTCLUSTER ) )
    {
        return 0;
    }

    // 파일 끝과 비교해서 실제로 읽을 수 있는 값을 계산
    dwTotalCount = MIN( dwSize * dwCount, pstFileHandle->dwFileSize - 
                        pstFileHandle->dwCurrentOffset );
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 계산된 값만큼 다 읽을 때까지 반복
    dwReadCount = 0;
    while( dwReadCount != dwTotalCount )
    {
        //======================================================================
        // 클러스터를 읽어서 버퍼에 복사
        //======================================================================
        // 현재 클러스터를 읽음
        if( kReadCluster( pstFileHandle->dwCurrentClusterIndex, gs_vbTempBuffer )
                == FALSE )
        {
            break;
        }

        // 클러스터 내에서 파일 포인터가 존재하는 오프셋을 계산
        dwOffsetInCluster = pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE;
        
        // 여러 클러스터에 걸쳐져 있다면 현재 클러스터에서 남은 만큼 읽고 다음 
        // 클러스터로 이동
        dwCopySize = MIN( FILESYSTEM_CLUSTERSIZE - dwOffsetInCluster, 
                          dwTotalCount - dwReadCount );
        kMemCpy( ( char* ) pvBuffer + dwReadCount, 
                gs_vbTempBuffer + dwOffsetInCluster, dwCopySize );

        // 읽은 바이트 수와 파일 포인터의 위치를 갱신
        dwReadCount += dwCopySize;
        pstFileHandle->dwCurrentOffset += dwCopySize;

        //======================================================================
        // 현재 클러스터를 끝까지 다 읽었으면 다음 클러스터로 이동
        //======================================================================
        if( ( pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE ) == 0 )
        {
            // 현재 클러스터의 링크 데이터를 찾아 다음 클러스터를 얻음
            if( kGetClusterLinkData( pstFileHandle->dwCurrentClusterIndex, 
                                     &dwNextClusterIndex ) == FALSE )
            {
                break;
            }
            
            // 클러스터 정보를 갱신
            pstFileHandle->dwPreviousClusterIndex = 
                pstFileHandle->dwCurrentClusterIndex;
            pstFileHandle->dwCurrentClusterIndex = dwNextClusterIndex;
        }
    }
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    
    // 읽은 레코드 수를 반환
    return ( dwReadCount / dwSize );
}

/**
 *  루트 디렉터리에서 디렉터리 엔트리 값을 갱신
 */
static BOOL kUpdateDirectoryEntry( FILEHANDLE* pstFileHandle )
{
    DIRECTORYENTRY stEntry;
    
    // 디렉터리 엔트리 검색
    if( ( pstFileHandle == NULL ) ||
        ( kGetDirectoryEntryData( pstFileHandle->iDirectoryEntryOffset, &stEntry)
            == FALSE ) )
    {
        return FALSE;
    }
    
    // 파일 크기와 시작 클러스터를 변경
    stEntry.dwFileSize = pstFileHandle->dwFileSize;
    stEntry.dwStartClusterIndex = pstFileHandle->dwStartClusterIndex;

    // 변경된 디렉터리 엔트리를 설정
    if( kSetDirectoryEntryData( pstFileHandle->iDirectoryEntryOffset, &stEntry )
            == FALSE )
    {
        return FALSE;
    }
    return TRUE;
}

/**
 *  버퍼의 데이터를 파일에 씀
 */
DWORD kWriteFile( const void* pvBuffer, DWORD dwSize, DWORD dwCount, FILE* pstFile )
{
    DWORD dwWriteCount;
    DWORD dwTotalCount;
    DWORD dwOffsetInCluster;
    DWORD dwCopySize;
    DWORD dwAllocatedClusterIndex;
    DWORD dwNextClusterIndex;
    FILEHANDLE* pstFileHandle;

    // 핸들이 파일 타입이 아니면 실패
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return 0;
    }
    pstFileHandle = &( pstFile->stFileHandle );

    // 총 바이트 수
    dwTotalCount = dwSize * dwCount;
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );

    // 다 쓸 때까지 반복
    dwWriteCount = 0;
    while( dwWriteCount != dwTotalCount )
    {
        //======================================================================
        // 현재 클러스터가 파일의 끝이면 클러스터를 할당하여 연결
        //======================================================================
        if( pstFileHandle->dwCurrentClusterIndex == FILESYSTEM_LASTCLUSTER )
        {
            // 빈 클러스터 검색
            dwAllocatedClusterIndex = kFindFreeCluster();
            if( dwAllocatedClusterIndex == FILESYSTEM_LASTCLUSTER )
            {
                break;
            }
            
            // 검색된 클러스터를 마지막 클러스터로 설정
            if( kSetClusterLinkData( dwAllocatedClusterIndex, FILESYSTEM_LASTCLUSTER )
                    == FALSE )
            {
                break;
            }
            
            // 파일의 마지막 클러스터에 할당된 클러스터를 연결
            if( kSetClusterLinkData( pstFileHandle->dwPreviousClusterIndex, 
                                     dwAllocatedClusterIndex ) == FALSE )
            {
                // 실패할 경우 할당된 클러스터를 해제
                kSetClusterLinkData( dwAllocatedClusterIndex, FILESYSTEM_FREECLUSTER );
                break;
            }
            
            // 현재 클러스터를 할당된 것으로 변경
            pstFileHandle->dwCurrentClusterIndex = dwAllocatedClusterIndex;
            
            // 새로 할당받았으니 임시 클러스터 버퍼를 0으로 채움
            kMemSet( gs_vbTempBuffer, 0, FILESYSTEM_LASTCLUSTER );
        }        
        //======================================================================
        // 한 클러스터를 채우지 못하면 클러스터를 읽어서 임시 클러스터 버퍼로 복사
        //======================================================================
        else if( ( ( pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE ) != 0 ) ||
                 ( ( dwTotalCount - dwWriteCount ) < FILESYSTEM_CLUSTERSIZE ) )
        {
            // 전체 클러스터를 덮어쓰는 경우가 아니면 부분만 덮어써야 하므로 
            // 현재 클러스터를 읽음
            if( kReadCluster( pstFileHandle->dwCurrentClusterIndex, 
                              gs_vbTempBuffer ) == FALSE )
            {
                break;
            }
        }

        // 클러스터 내에서 파일 포인터가 존재하는 오프셋을 계산
        dwOffsetInCluster = pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE;
        
        // 여러 클러스터에 걸쳐져 있다면 현재 클러스터에서 남은 만큼 쓰고 다음 
        // 클러스터로 이동
        dwCopySize = MIN( FILESYSTEM_CLUSTERSIZE - dwOffsetInCluster, 
                          dwTotalCount - dwWriteCount );
        kMemCpy( gs_vbTempBuffer + dwOffsetInCluster, ( char* ) pvBuffer + 
                 dwWriteCount, dwCopySize );
        
        // 임시 버퍼에 삽입된 값을 디스크에 씀
        if( kWriteCluster( pstFileHandle->dwCurrentClusterIndex, gs_vbTempBuffer ) 
                == FALSE )
        {
            break;
        }
        
        // 쓴 바이트 수와 파일 포인터의 위치를 갱신
        dwWriteCount += dwCopySize;
        pstFileHandle->dwCurrentOffset += dwCopySize;

        //======================================================================
        // 현재 클러스터의 끝까지 다 썼으면 다음 클러스터로 이동
        //======================================================================
        if( ( pstFileHandle->dwCurrentOffset % FILESYSTEM_CLUSTERSIZE ) == 0 )
        {
            // 현재 클러스터의 링크 데이터로 다음 클러스터를 얻음
            if( kGetClusterLinkData( pstFileHandle->dwCurrentClusterIndex, 
                                     &dwNextClusterIndex ) == FALSE )
            {
                break;
            }
            
            // 클러스터 정보를 갱신
            pstFileHandle->dwPreviousClusterIndex = 
                pstFileHandle->dwCurrentClusterIndex;
            pstFileHandle->dwCurrentClusterIndex = dwNextClusterIndex;
        }
    }

    //==========================================================================
    // 파일 크기가 변했다면 루트 디렉터리에 있는 디렉터리 엔트리 정보를 갱신
    //==========================================================================
    if( pstFileHandle->dwFileSize < pstFileHandle->dwCurrentOffset )
    {
        pstFileHandle->dwFileSize = pstFileHandle->dwCurrentOffset;
        kUpdateDirectoryEntry( pstFileHandle );
    }
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    
    // 쓴 레코드 수를 반환
    return ( dwWriteCount / dwSize );
}

/**
 *  파일을 Count만큼 0으로 채움
 */
BOOL kWriteZero( FILE* pstFile, DWORD dwCount )
{
    BYTE* pbBuffer;
    DWORD dwRemainCount;
    DWORD dwWriteCount;
    
    // 핸들이 NULL이면 실패
    if( pstFile == NULL )
    {
        return FALSE;
    }
    
    // 속도 향상을 위해 메모리를 할당 받아 클러스터 단위로 쓰기 수행
    // 메모리를 할당
    pbBuffer = ( BYTE* ) kAllocateMemory( FILESYSTEM_CLUSTERSIZE );
    if( pbBuffer == NULL )
    {
        return FALSE;
    }
    
    // 0으로 채움
    kMemSet( pbBuffer, 0, FILESYSTEM_CLUSTERSIZE );
    dwRemainCount = dwCount;
    
    // 클러스터 단위로 반복해서 쓰기 수행
    while( dwRemainCount != 0 )
    {
        dwWriteCount = MIN( dwRemainCount , FILESYSTEM_CLUSTERSIZE );
        if( kWriteFile( pbBuffer, 1, dwWriteCount, pstFile ) != dwWriteCount )
        {
            kFreeMemory( pbBuffer );
            return FALSE;
        }
        dwRemainCount -= dwWriteCount;
    }
    kFreeMemory( pbBuffer );
    return TRUE;
}

/**
 *  파일 포인터의 위치를 이동
 */
int kSeekFile( FILE* pstFile, int iOffset, int iOrigin )
{
    DWORD dwRealOffset;
    DWORD dwClusterOffsetToMove;
    DWORD dwCurrentClusterOffset;
    DWORD dwLastClusterOffset;
    DWORD dwMoveCount;
    DWORD i;
    DWORD dwStartClusterIndex;
    DWORD dwPreviousClusterIndex;
    DWORD dwCurrentClusterIndex;
    FILEHANDLE* pstFileHandle;

    // 핸들이 파일 타입이 아니면 나감
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return 0;
    }
    pstFileHandle = &( pstFile->stFileHandle );
    
    //==========================================================================
    // Origin과 Offset을 조합하여 파일 시작을 기준으로 파일 포인터를 옮겨야 할 위치를 
    // 계산
    //==========================================================================
    // 옵션에 따라서 실제 위치를 계산
    // 음수이면 파일의 시작 방향으로 이동하며 양수이면 파일의 끝 방향으로 이동
    switch( iOrigin )
    {
    // 파일의 시작을 기준으로 이동
    case FILESYSTEM_SEEK_SET:
        // 파일의 처음이므로 이동할 오프셋이 음수이면 0으로 설정
        if( iOffset <= 0 )
        {
            dwRealOffset = 0;
        }
        else
        {
            dwRealOffset = iOffset;
        }
        break;

    // 현재 위치를 기준으로 이동
    case FILESYSTEM_SEEK_CUR:
        // 이동할 오프셋이 음수이고 현재 파일 포인터의 값보다 크다면
        // 더 이상 갈 수 없으므로 파일의 처음으로 이동
        if( ( iOffset < 0 ) && 
            ( pstFileHandle->dwCurrentOffset <= ( DWORD ) -iOffset ) )
        {
            dwRealOffset = 0;
        }
        else
        {
            dwRealOffset = pstFileHandle->dwCurrentOffset + iOffset;
        }
        break;

    // 파일의 끝부분을 기준으로 이동
    case FILESYSTEM_SEEK_END:
        // 이동할 오프셋이 음수이고 현재 파일 포인터의 값보다 크다면 
        // 더 이상 갈 수 없으므로 파일의 처음으로 이동
        if( ( iOffset < 0 ) && 
            ( pstFileHandle->dwFileSize <= ( DWORD ) -iOffset ) )
        {
            dwRealOffset = 0;
        }
        else
        {
            dwRealOffset = pstFileHandle->dwFileSize + iOffset;
        }
        break;
    }

    //==========================================================================
    // 파일을 구성하는 클러스터의 개수와 현재 파일 포인터의 위치를 고려하여
    // 옮겨질 파일 포인터가 위치하는 클러스터까지 클러스터 링크를 탐색
    //==========================================================================
    // 파일의 마지막 클러스터의 오프셋
    dwLastClusterOffset = pstFileHandle->dwFileSize / FILESYSTEM_CLUSTERSIZE;
    // 파일 포인터가 옮겨질 위치의 클러스터 오프셋
    dwClusterOffsetToMove = dwRealOffset / FILESYSTEM_CLUSTERSIZE;
    // 현재 파일 포인터가 있는 클러스터의 오프셋
    dwCurrentClusterOffset = pstFileHandle->dwCurrentOffset / FILESYSTEM_CLUSTERSIZE;

    // 이동하는 클러스터의 위치가 파일의 마지막 클러스터의 오프셋을 넘어서면
    // 현재 클러스터에서 마지막까지 이동한 후, Write 함수를 이용해서 공백으로 나머지를
    // 채움
    if( dwLastClusterOffset < dwClusterOffsetToMove )
    {
        dwMoveCount = dwLastClusterOffset - dwCurrentClusterOffset;
        dwStartClusterIndex = pstFileHandle->dwCurrentClusterIndex;
    }
    // 이동하는 클러스터의 위치가 현재 클러스터와 같거나 다음에 위치해
    // 있다면 현재 클러스터를 기준으로 차이만큼만 이동하면 된다.
    else if( dwCurrentClusterOffset <= dwClusterOffsetToMove )
    {
        dwMoveCount = dwClusterOffsetToMove - dwCurrentClusterOffset;
        dwStartClusterIndex = pstFileHandle->dwCurrentClusterIndex;
    }
    // 이동하는 클러스터의 위치가 현재 클러스터 이전에 있다면, 첫 번째 클러스터부터
    // 이동하면서 검색
    else
    {
        dwMoveCount = dwClusterOffsetToMove;
        dwStartClusterIndex = pstFileHandle->dwStartClusterIndex;
    }

    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );

    // 클러스터를 이동
    dwCurrentClusterIndex = dwStartClusterIndex;
    for( i = 0 ; i < dwMoveCount ; i++ )
    {
        // 값을 보관
        dwPreviousClusterIndex = dwCurrentClusterIndex;
        
        // 다음 클러스터의 인덱스를 읽음
        if( kGetClusterLinkData( dwPreviousClusterIndex, &dwCurrentClusterIndex ) ==
            FALSE )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return -1;
        }
    }

    // 클러스터를 이동했으면 클러스터 정보를 갱신
    if( dwMoveCount > 0 )
    {
        pstFileHandle->dwPreviousClusterIndex = dwPreviousClusterIndex;
        pstFileHandle->dwCurrentClusterIndex = dwCurrentClusterIndex;
    }
    // 첫 번째 클러스터로 이동하는 경우는 핸들의 클러스터 값을 시작 클러스터로 설정
    else if( dwStartClusterIndex == pstFileHandle->dwStartClusterIndex )
    {
        pstFileHandle->dwPreviousClusterIndex = pstFileHandle->dwStartClusterIndex;
        pstFileHandle->dwCurrentClusterIndex = pstFileHandle->dwStartClusterIndex;
    }
    
    //==========================================================================
    // 파일 포인터를 갱신하고 파일 오프셋이 파일의 크기를 넘었다면 나머지 부분을
    // 0으로 채워서 파일의 크기를 늘림
    //==========================================================================
    // 실제 파일의 크기를 넘어서 파일 포인터가 이동했다면, 파일 끝에서부터 
    // 남은 크기만큼 0으로 채워줌
    if( dwLastClusterOffset < dwClusterOffsetToMove )
    {
        pstFileHandle->dwCurrentOffset = pstFileHandle->dwFileSize;
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );

        // 남은 크기만큼 0으로 채움
        if( kWriteZero( pstFile, dwRealOffset - pstFileHandle->dwFileSize )
                == FALSE )
        {
            return 0;
        }
    }

    pstFileHandle->dwCurrentOffset = dwRealOffset;

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );

    return 0;    
}

/**
 *  파일을 닫음
 */
int kCloseFile( FILE* pstFile )
{
    // 핸들 타입이 파일이 아니면 실패
    if( ( pstFile == NULL ) ||
        ( pstFile->bType != FILESYSTEM_TYPE_FILE ) )
    {
        return -1;
    }
    
    // 핸들을 반환
    kFreeFileDirectoryHandle( pstFile );
    return 0;
}

/**
 *  핸들 풀을 검사하여 파일이 열려있는지를 확인
 */
BOOL kIsFileOpened( const DIRECTORYENTRY* pstEntry )
{
    int i;
    FILE* pstFile;
    
    // 핸들 풀의 시작 어드레스부터 끝까지 열린 파일만 검색
    pstFile = gs_stFileSystemManager.pstHandlePool;
    for( i = 0 ; i < FILESYSTEM_HANDLE_MAXCOUNT ; i++ )
    {
        // 파일 타입 중에서 시작 클러스터가 일치하면 반환
        if( ( pstFile[ i ].bType == FILESYSTEM_TYPE_FILE ) &&
            ( pstFile[ i ].stFileHandle.dwStartClusterIndex == 
              pstEntry->dwStartClusterIndex ) )
        {
            return TRUE;
        }
    }
    return FALSE;
}

/**
 *  파일을 삭제
 */
int kRemoveFile( const char* pcFileName )
{
    DIRECTORYENTRY stEntry;
    int iDirectoryEntryOffset;
    int iFileNameLength;

    // 파일 이름 검사
    iFileNameLength = kStrLen( pcFileName );
    if( ( iFileNameLength > ( sizeof( stEntry.vcFileName ) - 1 ) ) || 
        ( iFileNameLength == 0 ) )
    {
        return NULL;
    }
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 파일이 존재하는가 확인
    iDirectoryEntryOffset = kFindDirectoryEntry( pcFileName, &stEntry );
    if( iDirectoryEntryOffset == -1 ) 
    { 
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }
    
    // 다른 태스크에서 해당 파일을 열고 있는지 핸들 풀을 검색하여 확인
    // 파일이 열려 있으면 삭제할 수 없음
    if( kIsFileOpened( &stEntry ) == TRUE )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }
    
    // 파일을 구성하는 클러스터를 모두 해제
    if( kFreeClusterUntilEnd( stEntry.dwStartClusterIndex ) == FALSE )
    { 
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }

    // 디렉터리 엔트리를 빈 것으로 설정
    kMemSet( &stEntry, 0, sizeof( stEntry ) );
    if( kSetDirectoryEntryData( iDirectoryEntryOffset, &stEntry ) == FALSE )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return -1;
    }
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return 0;
}

/**
 *  디렉터리를 엶
 */
DIR* kOpenDirectory( const char* pcDirectoryName )
{
    DIR* pstDirectory;
    DIRECTORYENTRY* pstDirectoryBuffer;
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 루트 디렉터리 밖에 없으므로 디렉터리 이름은 무시하고 핸들만 할당받아서 반환
    pstDirectory = kAllocateFileDirectoryHandle();
    if( pstDirectory == NULL )
    {
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
    }
    
    // 루트 디렉터리를 저장할 버퍼를 할당
    pstDirectoryBuffer = ( DIRECTORYENTRY* ) kAllocateMemory( FILESYSTEM_CLUSTERSIZE );
    if( pstDirectory == NULL )
    {
        // 실패하면 핸들을 반환해야 함
        kFreeFileDirectoryHandle( pstDirectory );
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
    }
    
    // 루트 디렉터리를 읽음
    if( kReadCluster( 0, ( BYTE* ) pstDirectoryBuffer ) == FALSE )
    {
        // 실패하면 핸들과 메모리를 모두 반환해야 함
        kFreeFileDirectoryHandle( pstDirectory );
        kFreeMemory( pstDirectoryBuffer );
        
        // 동기화
        kUnlock( &( gs_stFileSystemManager.stMutex ) );
        return NULL;
        
    }
    
    // 디렉터리 타입으로 설정하고 현재 디렉터리 엔트리의 오프셋을 초기화
    pstDirectory->bType = FILESYSTEM_TYPE_DIRECTORY;
    pstDirectory->stDirectoryHandle.iCurrentOffset = 0;
    pstDirectory->stDirectoryHandle.pstDirectoryBuffer = pstDirectoryBuffer;

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return pstDirectory;
}

/**
 *  디렉터리 엔트리를 반환하고 다음으로 이동
 */
struct kDirectoryEntryStruct* kReadDirectory( DIR* pstDirectory )
{
    DIRECTORYHANDLE* pstDirectoryHandle;
    DIRECTORYENTRY* pstEntry;
    
    // 핸들 타입이 디렉터리가 아니면 실패
    if( ( pstDirectory == NULL ) ||
        ( pstDirectory->bType != FILESYSTEM_TYPE_DIRECTORY ) )
    {
        return NULL;
    }
    pstDirectoryHandle = &( pstDirectory->stDirectoryHandle );
    
    // 오프셋의 범위가 클러스터에 존재하는 최댓값을 넘어서면 실패
    if( ( pstDirectoryHandle->iCurrentOffset < 0 ) ||
        ( pstDirectoryHandle->iCurrentOffset >= FILESYSTEM_MAXDIRECTORYENTRYCOUNT ) )
    {
        return NULL;
    }

    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 루트 디렉터리에 있는 최대 디렉터리 엔트리의 개수만큼 검색
    pstEntry = pstDirectoryHandle->pstDirectoryBuffer;
    while( pstDirectoryHandle->iCurrentOffset < FILESYSTEM_MAXDIRECTORYENTRYCOUNT )
    {
        // 파일이 존재하면 해당 디렉터리 엔트리를 반환
        if( pstEntry[ pstDirectoryHandle->iCurrentOffset ].dwStartClusterIndex
                != 0 )
        {
            // 동기화
            kUnlock( &( gs_stFileSystemManager.stMutex ) );
            return &( pstEntry[ pstDirectoryHandle->iCurrentOffset++ ] );
        }
        
        pstDirectoryHandle->iCurrentOffset++;
    }

    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return NULL;
}

/**
 *  디렉터리 포인터를 디렉터리의 처음으로 이동
 */
void kRewindDirectory( DIR* pstDirectory )
{
    DIRECTORYHANDLE* pstDirectoryHandle;
    
    // 핸들 타입이 디렉터리가 아니면 실패
    if( ( pstDirectory == NULL ) ||
        ( pstDirectory->bType != FILESYSTEM_TYPE_DIRECTORY ) )
    {
        return ;
    }
    pstDirectoryHandle = &( pstDirectory->stDirectoryHandle );
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 디렉터리 엔트리의 포인터만 0으로 바꿔줌
    pstDirectoryHandle->iCurrentOffset = 0;
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
}


/**
 *  열린 디렉터리를 닫음
 */
int kCloseDirectory( DIR* pstDirectory )
{
    DIRECTORYHANDLE* pstDirectoryHandle;
    
    // 핸들 타입이 디렉터리가 아니면 실패
    if( ( pstDirectory == NULL ) ||
        ( pstDirectory->bType != FILESYSTEM_TYPE_DIRECTORY ) )
    {
        return -1;
    }
    pstDirectoryHandle = &( pstDirectory->stDirectoryHandle );

    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 루트 디렉터리의 버퍼를 해제하고 핸들을 반환
    kFreeMemory( pstDirectoryHandle->pstDirectoryBuffer );
    kFreeFileDirectoryHandle( pstDirectory );    
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );

    return 0;
}

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
/**
 *  파일 시스템 캐시를 모두 하드 디스크에 씀
 */
BOOL kFlushFileSystemCache( void )
{
    CACHEBUFFER* pstCacheBuffer;
    int iCacheCount;
    int i;
    
    // 캐시가 비활성화 되었다면 함수를 수행할 필요가 없음
    if( gs_stFileSystemManager.bCacheEnable == FALSE )
    {
        return TRUE;
    }
    
    // 동기화
    kLock( &( gs_stFileSystemManager.stMutex ) );
    
    // 클러스터 링크 테이블 영역의 캐시 정보를 얻어서 내용이 변한 캐시 버퍼를 모두
    // 디스크에 씀
    kGetCacheBufferAndCount( CACHE_CLUSTERLINKTABLEAREA, &pstCacheBuffer, 
            &iCacheCount );
    for( i = 0 ; i < iCacheCount ; i++ )
    {
        // 캐시의 내용이 변했다면 태그에 저장된 위치에 직접 씀
        if( pstCacheBuffer[ i ].bChanged == TRUE )
        {
            if( kInternalWriteClusterLinkTableWithoutCache( 
                pstCacheBuffer[ i ].dwTag, pstCacheBuffer[ i ].pbBuffer ) == FALSE )
            {
                return FALSE;
            }
            // 버퍼의 내용을 하드 디스크에 썼으므로, 변경되지 않은 것으로 설정
            pstCacheBuffer[ i ].bChanged = FALSE;
        }
    }
    
    // 데이터 영역의 캐시 정보를 얻어서 내용이 변한 캐시 버퍼를 모두 디스크에 씀
    kGetCacheBufferAndCount( CACHE_DATAAREA, &pstCacheBuffer, &iCacheCount );
    for( i = 0 ; i < iCacheCount ; i++ )
    {
        // 캐시의 내용이 변했다면 태그에 저장된 위치에 직접 씀
        if( pstCacheBuffer[ i ].bChanged == TRUE )
        {
            if( kInternalWriteClusterWithoutCache( pstCacheBuffer[ i ].dwTag, 
                pstCacheBuffer[ i ].pbBuffer ) == FALSE )
            {
                return FALSE;
            }
            // 버퍼의 내용을 하드 디스크에 썼으므로, 변경되지 않은 것으로 설정
            pstCacheBuffer[ i ].bChanged = FALSE;
        }
    }
    
    // 동기화
    kUnlock( &( gs_stFileSystemManager.stMutex ) );
    return TRUE;
}

///////////////////////////////////////////////////////////////////
```

## 콘솔 셸 파일 수정

#### 02.Kernel64/Source/ConsoleShell.h

```c
#ifndef __CONSOLESHELL_H__
#define __CONSOLESHELL_H__

#include "Types.h"

////////////////////////////////////////////////////////////////////////////////
//
// 매크로
//
////////////////////////////////////////////////////////////////////////////////
#define CONSOLESHELL_MAXCOMMANDBUFFERCOUNT  300
#define CONSOLESHELL_PROMPTMESSAGE          "CYNOS64! >"

// 문자열 포인터를 파라미터로 받는 함수 포인터 타입 정의
typedef void ( * CommandFunction ) ( const char* pcParameter );


////////////////////////////////////////////////////////////////////////////////
//
// 구조체
//
////////////////////////////////////////////////////////////////////////////////
// 1바이트로 정렬
#pragma pack( push, 1 )

// 셸의 커맨드를 저장하는 자료구조
typedef struct kShellCommandEntryStruct
{
    // 커맨드 문자열
    char* pcCommand;
    // 커맨드의 도움말
    char* pcHelp;
    // 커맨드를 수행하는 함수의 포인터
    CommandFunction pfFunction;
} SHELLCOMMANDENTRY;

// 파라미터를 처리하기위해 정보를 저장하는 자료구조
typedef struct kParameterListStruct
{
    // 파라미터 버퍼의 어드레스
    const char* pcBuffer;
    // 파라미터의 길이
    int iLength;
    // 현재 처리할 파라미터가 시작하는 위치
    int iCurrentPosition;
} PARAMETERLIST;

#pragma pack( pop )

////////////////////////////////////////////////////////////////////////////////
//
// 함수
//
////////////////////////////////////////////////////////////////////////////////
// 실제 셸 코드
void kStartConsoleShell( void );
void kExecuteCommand( const char* pcCommandBuffer );
void kInitializeParameter( PARAMETERLIST* pstList, const char* pcParameter );
int kGetNextParameter( PARAMETERLIST* pstList, char* pcParameter );

// 커맨드를 처리하는 함수
static void kHelp( const char* pcParameterBuffer );
static void kCls( const char* pcParameterBuffer );
static void kShowTotalRAMSize( const char* pcParameterBuffer );
static void kStringToDecimalHexTest( const char* pcParameterBuffer );
static void kShutdown( const char* pcParameterBuffer );

////////////////////////////////////////////////////////////////////////////////
//
// 타이머 디바이스 드라이버 추가
//
////////////////////////////////////////////////////////////////////////////////
static void kSetTimer(const char* pcParameterBuffer);
static void kWaitUsingPIT(const char* pcParameterBuffer);
static void kReadTimeStampCounter(const char* pcParameterBuffer);
static void kMeasureProcessorSpeed(const char* pcParameterBuffer);
static void kShowDateAndTime(const char* pcParameterBuffer);
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 태스크 개념을 추가해 멀티태스킹을 구현하자
//
////////////////////////////////////////////////////////////////////////////////
static void kCreateTestTask(const char* pcParameterBuffer);
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 멀티레벨 큐 스케줄러와 태스크 종료기능 추가
//
////////////////////////////////////////////////////////////////////////////////
static void kChangeTaskPriority( const char* pcParameterBuffer );
static void kShowTaskList( const char* pcParameterBuffer );
static void kKillTask( const char* pcParameterBuffer );
static void kCPULoad( const char* pcParameterBuffer );
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 멀티 스레딩 기능을 추가하자.
//
////////////////////////////////////////////////////////////////////////////////
static void kTestMutex( const char* pcParameterBuffer );
static void kCreateThreadTask( void );
static void kTestThread( const char* pcParameterBuffer );
static void kShowMatrix( const char* pcParameterBuffer );
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 실수 연산 기능 통합과 빌드
//
////////////////////////////////////////////////////////////////////////////////
static void kTestPIE(const char* pcParameterBuffer);
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 동적 메모리 할당
//
//////////////////////////////////////////////////////////////////////////////// 
static void kShowDyanmicMemoryInformation( const char* pcParameterBuffer );
static void kTestSequentialAllocation(const char* pcParameterBuffer);
static void kTestRandomAllocation(const char* pcParameterBuffer);
static void kRandomAllocationTask(void);
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
//
// 하드디스크 디바이스 드라이버 추가 
//
////////////////////////////////////////////////////////////////
static void kShowHDDInformation( const char* pcParameterBuffer );
static void kReadSector( const char* pcParameterBuffer );
static void kWriteSector( const char* pcParameterBuffer );
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
//
// 간단한 파일 시스템 구현
//
////////////////////////////////////////////////////////////////
static void kMountHDD(const char* pcParameterBuffer);
static void kFormatHDD(const char* pcParameterBuffer);
static void kShowFileSystemInformation(const char* pcParameterBuffer);
static void kCreateFileInRootDirectory(const char* pcParameterBuffer);
static void kDeleteFileInRootDirectory(const char* pcParameterBuffer);
static void kShowRootDirectory(const char* pcParameterBuffer);
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
static void kWriteDataToFile( const char* pcParameterBuffer );
static void kReadDataFromFile( const char* pcParameterBuffer );
static void kTestFileIO( const char* pcParameterBuffer );
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
static void kFlushCache( const char* pcParameterBuffer );
static void kTestPerformance( const char* pcParameterBuffer );
///////////////////////////////////////////////////////////////////
#endif /*__CONSOLESHELL_H__*/

```

#### 02.Kernel64/Source/ConsoleShell.c

```c
#include "ConsoleShell.h"
#include "Console.h"
#include "Keyboard.h"
#include "Utility.h"
#include "PIT.h"
#include "RTC.h"
#include "AssemblyUtility.h"
////////////////////////////////////////////////////////////////////////////////
//
// 멀티레벨 큐 스케줄러와 태스크 종료기능 추가
//
////////////////////////////////////////////////////////////////////////////////
#include "Task.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// 멀티 스레딩 기능을 추가하자.
//
////////////////////////////////////////////////////////////////////////////////
#include "Synchronization.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// 동적 메모리 할당
//
//////////////////////////////////////////////////////////////////////////////// 
#include "DynamicMemory.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// 하드디스크 디바이스 드라이버 추가 
//
////////////////////////////////////////////////////////////////
#include "HardDisk.h"
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// 간단한 파일 시스템 구현
//
////////////////////////////////////////////////////////////////
#include "FileSystem.h"
////////////////////////////////////////////////////////////////

// 커맨드 테이블 정의
SHELLCOMMANDENTRY gs_vstCommandTable[] =
{
        { "help", "Show Help", kHelp },
        { "cls", "Clear Screen", kCls },
        { "totalram", "Show Total RAM Size", kShowTotalRAMSize },
        { "strtod", "String To Decial/Hex Convert", kStringToDecimalHexTest },
        { "shutdown", "Shutdown And Reboot OS", kShutdown },
        
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 타이머 디바이스 드라이버 추가
        //
        ////////////////////////////////////////////////////////////////////////////////
        { "settimer", "Set PIT Controller Counter0, ex)settimer 10(ms) 1(periodic)", 
                kSetTimer },
        { "wait", "Wait ms Using PIT, ex)wait 100(ms)", kWaitUsingPIT },
        { "rdtsc", "Read Time Stamp Counter", kReadTimeStampCounter },
        { "cpuspeed", "Measure Processor Speed", kMeasureProcessorSpeed },
        { "date", "Show Date And Time", kShowDateAndTime },
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 라운드 로빈 스케줄러를 추가하자
        //
        ////////////////////////////////////////////////////////////////////////////////
        {"createtask","Create Task, ex)createtask 1(type) 10(count)", kCreateTestTask},
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 멀티레벨 큐 스케줄러와 태스크 종료기능 추가
        //
        ////////////////////////////////////////////////////////////////////////////////
        { "changepriority", "Change Task Priority, ex)changepriority 1(ID) 2(Priority)",
                kChangeTaskPriority },
        { "tasklist", "Show Task List", kShowTaskList },
        { "killtask", "End Task, ex)killtask 1(ID)", kKillTask },
        { "cpuload", "Show Processor Load", kCPULoad },
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 멀티 스레딩 기능을 추가하자.
        //
        ////////////////////////////////////////////////////////////////////////////////
        { "testmutex", "Test Mutex Function", kTestMutex },
        { "testthread", "Test Thread And Process Function", kTestThread },
        { "showmatrix", "Show Matrix Screen", kShowMatrix },
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 실수 연산 기능 통합과 빌드
        //
        ////////////////////////////////////////////////////////////////////////////////
        { "testpie", "Test PIE Calculation", kTestPIE },      
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // 동적 메모리 할당
        //
        //////////////////////////////////////////////////////////////////////////////// 
        { "dynamicmeminfo", "Show Dyanmic Memory Information", kShowDyanmicMemoryInformation },
        { "testseqalloc", "Test Sequential Allocation & Free", kTestSequentialAllocation },
        { "testranalloc", "Test Random Allocation & Free", kTestRandomAllocation },
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////
        //
        // 하드디스크 디바이스 드라이버 추가 
        //
        ////////////////////////////////////////////////////////////////
        { "hddinfo", "Show HDD Information", kShowHDDInformation },
        { "readsector", "Read HDD Sector, ex)readsector 0(LBA) 10(count)", 
                kReadSector },
        { "writesector", "Write HDD Sector, ex)writesector 0(LBA) 10(count)", 
                kWriteSector },
        ////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////
        //
        // 간단한 파일 시스템 구현
        //
        ////////////////////////////////////////////////////////////////
        { "mounthdd", "Mount HDD", kMountHDD },
        { "formathdd", "Format HDD", kFormatHDD },
        { "filesysteminfo", "Show File System Information", kShowFileSystemInformation },
        { "createfile", "Create File, ex)createfile a.txt", kCreateFileInRootDirectory },
        { "deletefile", "Delete File, ex)deletefile a.txt", kDeleteFileInRootDirectory },
        { "dir", "Show Directory", kShowRootDirectory },
        ////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //
        // C 표준 입출력 함수 추가
        //
        ////////////////////////////////////////////////////////////////////////////////
        { "writefile", "Write Data To File, ex) writefile a.txt", kWriteDataToFile },
        { "readfile", "Read Data From File, ex) readfile a.txt", kReadDataFromFile },
        { "testfileio", "Test File I/O Function", kTestFileIO },
        ////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////
        //
        // 파일 시스템 캐시와 램 디스크 추가
        //
        ///////////////////////////////////////////////////////////////////
        { "testperformance", "Test File Read/WritePerformance", kTestPerformance },
        { "flush", "Flush File System Cache", kFlushCache },
        ///////////////////////////////////////////////////////////////////
};                                     

//==============================================================================
//  실제 셸을 구성하는 코드
//==============================================================================
/**
 *  셸의 메인 루프
 */
void kStartConsoleShell( void )
{
    char vcCommandBuffer[ CONSOLESHELL_MAXCOMMANDBUFFERCOUNT ];
    int iCommandBufferIndex = 0;
    BYTE bKey;
    int iCursorX, iCursorY;
    
    // 프롬프트 출력
    kPrintf( CONSOLESHELL_PROMPTMESSAGE );
    
    while( 1 )
    {
        // 키가 수신될 때까지 대기
        bKey = kGetCh();
        // Backspace 키 처리
        if( bKey == KEY_BACKSPACE )
        {
            if( iCommandBufferIndex > 0 )
            {
                // 현재 커서 위치를 얻어서 한 문자 앞으로 이동한 다음 공백을 출력하고 
                // 커맨드 버퍼에서 마지막 문자 삭제
                kGetCursor( &iCursorX, &iCursorY );
                kPrintStringXY( iCursorX - 1, iCursorY, " " );
                kSetCursor( iCursorX - 1, iCursorY );
                iCommandBufferIndex--;
            }
        }
        // 엔터 키 처리
        else if( bKey == KEY_ENTER )
        {
            kPrintf( "\n" );
            
            if( iCommandBufferIndex > 0 )
            {
                // 커맨드 버퍼에 있는 명령을 실행
                vcCommandBuffer[ iCommandBufferIndex ] = '\0';
                kExecuteCommand( vcCommandBuffer );
            }
            
            // 프롬프트 출력 및 커맨드 버퍼 초기화
            kPrintf( "%s", CONSOLESHELL_PROMPTMESSAGE );            
            kMemSet( vcCommandBuffer, '\0', CONSOLESHELL_MAXCOMMANDBUFFERCOUNT );
            iCommandBufferIndex = 0;
        }
        // 시프트 키, CAPS Lock, NUM Lock, Scroll Lock은 무시
        else if( ( bKey == KEY_LSHIFT ) || ( bKey == KEY_RSHIFT ) ||
                 ( bKey == KEY_CAPSLOCK ) || ( bKey == KEY_NUMLOCK ) ||
                 ( bKey == KEY_SCROLLLOCK ) )
        {
            ;
        }
        else
        {
            // TAB은 공백으로 전환
            if( bKey == KEY_TAB )
            {
                bKey = ' ';
            }
            
            // 버퍼에 공간이 남아있을 때만 가능
            if( iCommandBufferIndex < CONSOLESHELL_MAXCOMMANDBUFFERCOUNT )
            {
                if(bKey > 31 && bKey <127)
                {
                    vcCommandBuffer[ iCommandBufferIndex++ ] = bKey;
                    kPrintf( "%c", bKey );
                }
            }
        }
    }
}

/*
 *  커맨드 버퍼에 있는 커맨드를 비교하여 해당 커맨드를 처리하는 함수를 수행
 */
void kExecuteCommand( const char* pcCommandBuffer )
{
    int i, iSpaceIndex;
    int iCommandBufferLength, iCommandLength;
    int iCount;
    
    // 공백으로 구분된 커맨드를 추출
    iCommandBufferLength = kStrLen( pcCommandBuffer );
    for( iSpaceIndex = 0 ; iSpaceIndex < iCommandBufferLength ; iSpaceIndex++ )
    {
        if( pcCommandBuffer[ iSpaceIndex ] == ' ' )
        {
            break;
        }
    }
    
    // 커맨드 테이블을 검사해서 동일한 이름의 커맨드가 있는지 확인
    iCount = sizeof( gs_vstCommandTable ) / sizeof( SHELLCOMMANDENTRY );
    for( i = 0 ; i < iCount ; i++ )
    {
        iCommandLength = kStrLen( gs_vstCommandTable[ i ].pcCommand );
        // 커맨드의 길이와 내용이 완전히 일치하는지 검사
        if( ( iCommandLength == iSpaceIndex ) &&
            ( kMemCmp( gs_vstCommandTable[ i ].pcCommand, pcCommandBuffer,
                       iSpaceIndex ) == 0 ) )
        {
            gs_vstCommandTable[ i ].pfFunction( pcCommandBuffer + iSpaceIndex + 1 );
            break;
        }
    }

    // 리스트에서 찾을 수 없다면 에러 출력
    if( i >= iCount )
    {
        kPrintf( "'%s' is not found.\n", pcCommandBuffer );
    }
}

/**
 *  파라미터 자료구조를 초기화
 */
void kInitializeParameter( PARAMETERLIST* pstList, const char* pcParameter )
{
    pstList->pcBuffer = pcParameter;
    pstList->iLength = kStrLen( pcParameter );
    pstList->iCurrentPosition = 0;
}

/**
 *  공백으로 구분된 파라미터의 내용과 길이를 반환
 */
int kGetNextParameter( PARAMETERLIST* pstList, char* pcParameter )
{
    int i;
    int iLength;

    // 더 이상 파라미터가 없으면 나감
    if( pstList->iLength <= pstList->iCurrentPosition )
    {
        return 0;
    }
    
    // 버퍼의 길이만큼 이동하면서 공백을 검색
    for( i = pstList->iCurrentPosition ; i < pstList->iLength ; i++ )
    {
        if( pstList->pcBuffer[ i ] == ' ' )
        {
            break;
        }
    }
    
    // 파라미터를 복사하고 길이를 반환
    kMemCpy( pcParameter, pstList->pcBuffer + pstList->iCurrentPosition, i );
    iLength = i - pstList->iCurrentPosition;
    pcParameter[ iLength ] = '\0';

    // 파라미터의 위치 업데이트
    pstList->iCurrentPosition += iLength + 1;
    return iLength;
}
    
//==============================================================================
//  커맨드를 처리하는 코드
//==============================================================================
/**
 *  셸 도움말을 출력
 */
static void kHelp( const char* pcCommandBuffer )
{
    int i;
    int iCount;
    int iCursorX, iCursorY;
    int iLength, iMaxCommandLength = 0;
    
    
    kPrintf( "=========================================================\n" );
    kPrintf( "                    MINT64 Shell Help                    \n" );
    kPrintf( "=========================================================\n" );
    
    iCount = sizeof( gs_vstCommandTable ) / sizeof( SHELLCOMMANDENTRY );

    // 가장 긴 커맨드의 길이를 계산
    for( i = 0 ; i < iCount ; i++ )
    {
        iLength = kStrLen( gs_vstCommandTable[ i ].pcCommand );
        if( iLength > iMaxCommandLength )
        {
            iMaxCommandLength = iLength;
        }
    }
    
    // 도움말 출력
    for( i = 0 ; i < iCount ; i++ )
    {
        kPrintf( "%s", gs_vstCommandTable[ i ].pcCommand );
        kGetCursor( &iCursorX, &iCursorY );
        kSetCursor( iMaxCommandLength, iCursorY );
        kPrintf( "  - %s\n", gs_vstCommandTable[ i ].pcHelp );

////////////////////////////////////////////////////////////////////////////////
//
// 동적 메모리 할당
//
//////////////////////////////////////////////////////////////////////////////// 
// 목록이 많을 경우 나눠서 보여줌
        if( ( i != 0 ) && ( ( i % 20 ) == 0 ) )
        {
            kPrintf( "Press any key to continue... ('q' is exit) : " );
            if( kGetCh() == 'q' )
            {
                kPrintf( "\n" );
                break;
            }        
            kPrintf( "\n" );
        }
////////////////////////////////////////////////////////////////////////////////
    }
}

/**
 *  화면을 지움 
 */
static void kCls( const char* pcParameterBuffer )
{
    // 맨 윗줄은 디버깅 용으로 사용하므로 화면을 지운 후, 라인 1로 커서 이동
    kClearScreen();
    kSetCursor( 0, 1 );
}

/**
 *  총 메모리 크기를 출력
 */
static void kShowTotalRAMSize( const char* pcParameterBuffer )
{
    kPrintf( "Total RAM Size = %d MB\n", kGetTotalRAMSize() );
}

/**
 *  문자열로 된 숫자를 숫자로 변환하여 화면에 출력
 */
static void kStringToDecimalHexTest( const char* pcParameterBuffer )
{
    char vcParameter[ 100 ];
    int iLength;
    PARAMETERLIST stList;
    int iCount = 0;
    long lValue;
    
    // 파라미터 초기화
    kInitializeParameter( &stList, pcParameterBuffer );
    
    while( 1 )
    {
        // 다음 파라미터를 구함, 파라미터의 길이가 0이면 파라미터가 없는 것이므로
        // 종료
        iLength = kGetNextParameter( &stList, vcParameter );
        if( iLength == 0 )
        {
            break;
        }

        // 파라미터에 대한 정보를 출력하고 16진수인지 10진수인지 판단하여 변환한 후
        // 결과를 printf로 출력
        kPrintf( "Param %d = '%s', Length = %d, ", iCount + 1, 
                 vcParameter, iLength );

        // 0x로 시작하면 16진수, 그외는 10진수로 판단
        if( kMemCmp( vcParameter, "0x", 2 ) == 0 )
        {
            lValue = kAToI( vcParameter + 2, 16 );
            kPrintf( "HEX Value = %q\n", lValue );
        }
        else
        {
            lValue = kAToI( vcParameter, 10 );
            kPrintf( "Decimal Value = %d\n", lValue );
        }
        
        iCount++;
    }
}

/**
 *  PC를 재시작(Reboot)
 */
static void kShutdown( const char* pcParamegerBuffer )
{
    kPrintf( "System Shutdown Start...\n" );
    
///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 파일 시스템 캐시에 들어있는 내용을 하드 디스크로 옮김
    kPrintf( "Cache Flush... ");
    if( kFlushFileSystemCache() == TRUE )
    {
        kPrintf( "Pass\n" );
    }
    else
    {
        kPrintf( "Fail\n" );
    }
///////////////////////////////////////////////////////////////////

    // 키보드 컨트롤러를 통해 PC를 재시작
    kPrintf( "Press Any Key To Reboot PC..." );
    kGetCh();
    kReboot();
}

////////////////////////////////////////////////////////////////////////////////
//
// 타이머 디바이스 드라이버 추가
//
////////////////////////////////////////////////////////////////////////////////
/**
 *  PIT 컨트롤러의 카운터 0 설정
 */
static void kSetTimer( const char* pcParameterBuffer )
{
    char vcParameter[ 100 ];
    PARAMETERLIST stList;
    long lValue;
    BOOL bPeriodic;

    // 파라미터 초기화
    kInitializeParameter( &stList, pcParameterBuffer );
    
    // milisecond 추출
    if( kGetNextParameter( &stList, vcParameter ) == 0 )
    {
        kPrintf( "ex)settimer 10(ms) 1(periodic)\n" );
        return ;
    }
    lValue = kAToI( vcParameter, 10 );

    // Periodic 추출
    if( kGetNextParameter( &stList, vcParameter ) == 0 )
    {
        kPrintf( "ex)settimer 10(ms) 1(periodic)\n" );
        return ;
    }    
    bPeriodic = kAToI( vcParameter, 10 );
    
    kInitializePIT( MSTOCOUNT( lValue ), bPeriodic );
    kPrintf( "Time = %d ms, Periodic = %d Change Complete\n", lValue, bPeriodic );
}

/**
 *  PIT 컨트롤러를 직접 사용하여 ms 동안 대기  
 */
static void kWaitUsingPIT( const char* pcParameterBuffer )
{
    char vcParameter[ 100 ];
    int iLength;
    PARAMETERLIST stList;
    long lMillisecond;
    int i;
    
    // 파라미터 초기화
    kInitializeParameter( &stList, pcParameterBuffer );
    if( kGetNextParameter( &stList, vcParameter ) == 0 )
    {
        kPrintf( "ex)wait 100(ms)\n" );
        return ;
    }
    
    lMillisecond = kAToI( pcParameterBuffer, 10 );
    kPrintf( "%d ms Sleep Start...\n", lMillisecond );
    
    // 인터럽트를 비활성화하고 PIT 컨트롤러를 통해 직접 시간을 측정
    kDisableInterrupt();
    for( i = 0 ; i < lMillisecond / 30 ; i++ )
    {
        kWaitUsingDirectPIT( MSTOCOUNT( 30 ) );
    }
    kWaitUsingDirectPIT( MSTOCOUNT( lMillisecond % 30 ) );   
    kEnableInterrupt();
    kPrintf( "%d ms Sleep Complete\n", lMillisecond );
    
    // 타이머 복원
    kInitializePIT( MSTOCOUNT( 1 ), TRUE );
}

/**
 *  타임 스탬프 카운터를 읽음  
 */
static void kReadTimeStampCounter( const char* pcParameterBuffer )
{
    QWORD qwTSC;
    
    qwTSC = kReadTSC();
    kPrintf( "Time Stamp Counter = %q\n", qwTSC );
}

/**
 *  프로세서의 속도를 측정
 */
static void kMeasureProcessorSpeed( const char* pcParameterBuffer )
{
    int i;
    QWORD qwLastTSC, qwTotalTSC = 0;
        
    kPrintf( "Now Measuring." );
    
    // 10초 동안 변화한 타임 스탬프 카운터를 이용하여 프로세서의 속도를 간접적으로 측정
    kDisableInterrupt();    
    for( i = 0 ; i < 200 ; i++ )
    {
        qwLastTSC = kReadTSC();
        kWaitUsingDirectPIT( MSTOCOUNT( 50 ) );
        qwTotalTSC += kReadTSC() - qwLastTSC;

        kPrintf( "." );
    }
    // 타이머 복원
    kInitializePIT( MSTOCOUNT( 1 ), TRUE );    
    kEnableInterrupt();
    
    kPrintf( "\nCPU Speed = %d MHz\n", qwTotalTSC / 10 / 1000 / 1000 );
}

/**
 *  RTC 컨트롤러에 저장된 일자 및 시간 정보를 표시
 */
static void kShowDateAndTime( const char* pcParameterBuffer )
{
    BYTE bSecond, bMinute, bHour;
    BYTE bDayOfWeek, bDayOfMonth, bMonth;
    WORD wYear;

    // RTC 컨트롤러에서 시간 및 일자를 읽음
    kReadRTCTime( &bHour, &bMinute, &bSecond );
    kReadRTCDate( &wYear, &bMonth, &bDayOfMonth, &bDayOfWeek );
    
    kPrintf( "Date: %d/%d/%d %s, ", wYear, bMonth, bDayOfMonth,
             kConvertDayOfWeekToString( bDayOfWeek ) );
    kPrintf( "Time: %d:%d:%d\n", bHour, bMinute, bSecond );
}
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 멀티레벨 큐 스케줄러와 태스크 종료기능 추가 ( kHelp까지 static 함수로 바꾸기)
//
////////////////////////////////////////////////////////////////////////////////
// 태스크 1
//  화면 테두리를 돌면서 문자를 출력
static void kTestTask1(void)
////////////////////////////////////////////////////////////////////////////////
{
    BYTE bData;
    int i = 0, iX = 0, iY = 0, iMargin;
////////////////////////////////////////////////////////////////////////////////
//
// 멀티레벨 큐 스케줄러와 태스크 종료기능 추가
//
////////////////////////////////////////////////////////////////////////////////
    int j;
////////////////////////////////////////////////////////////////////////////////
    CHARACTER* pstScreen = (CHARACTER*)CONSOLE_VIDEOMEMORYADDRESS;
    TCB* pstRunningTask;

    // 자신의 ID를 얻어서 화면 오프셋으로 사용
    pstRunningTask = kGetRunningTask();
    iMargin = (pstRunningTask->stLink.qwID & 0xFFFFFFFF)%10;

    // 화면 네 귀퉁이를 돌면서 문자 출력
////////////////////////////////////////////////////////////////////////////////
//
// 멀티레벨 큐 스케줄러와 태스크 종료기능 추가
//
////////////////////////////////////////////////////////////////////////////////
    for(j = 0; j< 20000; j++)
    {
        switch(i)
        {
            case 0:
                iX++;
                if(iX >= (CONSOLE_WIDTH - iMargin))
                {
                    i = 1;
                }
                break;
            case 1:
                iY++;
                if(iY >= (CONSOLE_HEIGHT - iMargin))
                {
                    i = 2;
                }
                break;
            case 2:
                iX--;
                if(iX < iMargin)
                {
                    i = 3;
                }
                break;
            case 3:
                iY--;
                if(iY < iMargin)
                {
                    i = 0;
                }
                break;
        }

        // 문자 및 색깔 지정
        pstScreen[iY * CONSOLE_WIDTH + iX].bCharactor = bData;
        pstScreen[iY*CONSOLE_WIDTH + iX].bAttribute = 0x70 | bData & 0x0F;
        bData++;

        // 다른 태스크로 전환
        //kSchedule();
    }
    kExitTask();
////////////////////////////////////////////////////////////////////////////////
}

////////////////////////////////////////////////////////////////////////////////
//
// 멀티레벨 큐 스케줄러와 태스크 종료기능 추가
//
////////////////////////////////////////////////////////////////////////////////
//태스크 2
//     자신의 ID를 참고하여 특정 위치에 회전하는 바람개비를 출력
static void kTestTask2( void )
////////////////////////////////////////////////////////////////////////////////
{
    int i = 0, iOffset;
    CHARACTER* pstScreen = ( CHARACTER* ) CONSOLE_VIDEOMEMORYADDRESS;
    TCB* pstRunningTask;
    char vcData[ 4 ] = { '-', '\\', '|', '/' };
    
    // 자신의 ID를 얻어서 화면 오프셋으로 사용
    pstRunningTask = kGetRunningTask();
    iOffset = ( pstRunningTask->stLink.qwID & 0xFFFFFFFF ) * 2;
    iOffset = CONSOLE_WIDTH * CONSOLE_HEIGHT - 
        ( iOffset % ( CONSOLE_WIDTH * CONSOLE_HEIGHT ) );

    while( 1 )
    {
        // 회전하는 바람개비를 표시
        pstScreen[ iOffset ].bCharactor = vcData[ i % 4 ];
        // 색깔 지정
        pstScreen[ iOffset ].bAttribute = 0x70 |( iOffset % 15 ) + 1;
        i++;
        
////////////////////////////////////////////////////////////////////////////////
//
// 멀티레벨 큐 스케줄러와 태스크 종료기능 추가
//
////////////////////////////////////////////////////////////////////////////////
        // 다른 태스크로 전환
        //kSchedule();
////////////////////////////////////////////////////////////////////////////////
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// 멀티레벨 큐 스케줄러와 태스크 종료기능 추가
//
////////////////////////////////////////////////////////////////////////////////
// 태스크를 생성해서 멀티 태스킹 수행
static void kCreateTestTask( const char* pcParameterBuffer )
////////////////////////////////////////////////////////////////////////////////
{
    PARAMETERLIST stList;
    char vcType[ 30 ];
    char vcCount[ 30 ];
    int i;
    
    // 파라미터를 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    kGetNextParameter( &stList, vcType );
    kGetNextParameter( &stList, vcCount );

    switch( kAToI( vcType, 10 ) )
    {
    // 타입 1 태스크 생성
    case 1:
        for( i = 0 ; i < kAToI( vcCount, 10 ) ; i++ )
        {    
            ////////////////////////////////////////////////////////////////////////////////
            //
            // 멀티 스레딩 기능을 추가하자.
            //
            ////////////////////////////////////////////////////////////////////////////////
            if( kCreateTask( TASK_FLAGS_LOW | TASK_FLAGS_THREAD, 0, 0, ( QWORD ) kTestTask1 ) == NULL )
            {
                break;
            }
            ////////////////////////////////////////////////////////////////////////////////
        }
        
        kPrintf( "Task1 %d Created\n", i );
        break;
        
    // 타입 2 태스크 생성
    case 2:
    default:
        for( i = 0 ; i < kAToI( vcCount, 10 ) ; i++ )
        {    
            ////////////////////////////////////////////////////////////////////////////////
            //
            // 멀티 스레딩 기능을 추가하자.
            //
            ////////////////////////////////////////////////////////////////////////////////
            if( kCreateTask( TASK_FLAGS_LOW | TASK_FLAGS_THREAD, 0, 0, ( QWORD ) kTestTask2 ) == NULL )
            {
                break;
            }
            ////////////////////////////////////////////////////////////////////////////////
        }
        kPrintf( "Task2 %d Created\n", i );
        break;
    }    
}   

/**
 *  태스크의 우선 순위를 변경
 */
static void kChangeTaskPriority( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcID[ 30 ];
    char vcPriority[ 30 ];
    QWORD qwID;
    BYTE bPriority;
    
    // 파라미터를 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    kGetNextParameter( &stList, vcID );
    kGetNextParameter( &stList, vcPriority );
    
    // 태스크의 우선 순위를 변경
    if( kMemCmp( vcID, "0x", 2 ) == 0 )
    {
        qwID = kAToI( vcID + 2, 16 );
    }
    else
    {
        qwID = kAToI( vcID, 10 );
    }
    
    bPriority = kAToI( vcPriority, 10 );
    
    kPrintf( "Change Task Priority ID [0x%q] Priority[%d] ", qwID, bPriority );
    if( kChangePriority( qwID, bPriority ) == TRUE )
    {
        kPrintf( "Success\n" );
    }
    else
    {
        kPrintf( "Fail\n" );
    }
}

/**
 *  현재 생성된 모든 태스크의 정보를 출력
 */
static void kShowTaskList( const char* pcParameterBuffer )
{
    int i;
    TCB* pstTCB;
    int iCount = 0;
    
    kPrintf( "=========== Task Total Count [%d] ===========\n", kGetTaskCount() );
    for( i = 0 ; i < TASK_MAXCOUNT ; i++ )
    {
        // TCB를 구해서 TCB가 사용 중이면 ID를 출력
        pstTCB = kGetTCBInTCBPool( i );
        if( ( pstTCB->stLink.qwID >> 32 ) != 0 )
        {
            // 태스크가 10개 출력될 때마다, 계속 태스크 정보를 표시할지 여부를 확인
            if( ( iCount != 0 ) && ( ( iCount % 10 ) == 0 ) )
            {
                kPrintf( "Press any key to continue... ('q' is exit) : " );
                if( kGetCh() == 'q' )
                {
                    kPrintf( "\n" );
                    break;
                }
                kPrintf( "\n" );
            }
            
            ////////////////////////////////////////////////////////////////////////////////
            //
            // 멀티 스레딩 기능을 추가하자.
            //
            ////////////////////////////////////////////////////////////////////////////////
            kPrintf( "[%d] Task ID[0x%Q], Priority[%d], Flags[0x%Q], Thread[%d]\n", 1 + iCount++,
                     pstTCB->stLink.qwID, GETPRIORITY( pstTCB->qwFlags ), 
                     pstTCB->qwFlags, kGetListCount( &( pstTCB->stChildThreadList ) ) );
            kPrintf( "    Parent PID[0x%Q], Memory Address[0x%Q], Size[0x%Q]\n",
                    pstTCB->qwParentProcessID, pstTCB->pvMemoryAddress, pstTCB->qwMemorySize );
            ////////////////////////////////////////////////////////////////////////////////
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// 멀티 스레딩 기능을 추가하자.
//
////////////////////////////////////////////////////////////////////////////////
/**
 *  태스크를 종료
 */
static void kKillTask( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcID[ 30 ];
    QWORD qwID;
    TCB* pstTCB;
    int i;
    
    // 파라미터를 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    kGetNextParameter( &stList, vcID );
    
    // 태스크를 종료
    if( kMemCmp( vcID, "0x", 2 ) == 0 )
    {
        qwID = kAToI( vcID + 2, 16 );
    }
    else
    {
        qwID = kAToI( vcID, 10 );
    }
    
    // 특정 ID만 종료하는 경우
    if( qwID != 0xFFFFFFFF )
    {
        pstTCB = kGetTCBInTCBPool( GETTCBOFFSET( qwID ) );
        qwID = pstTCB->stLink.qwID;

        // 시스템 테스트는 제외
        if( ( ( qwID >> 32 ) != 0 ) && ( ( pstTCB->qwFlags & TASK_FLAGS_SYSTEM ) == 0x00 ) )
        {
            kPrintf( "Kill Task ID [0x%q] ", qwID );
            if( kEndTask( qwID ) == TRUE )
            {
                kPrintf( "Success\n" );
            }
            else
            {
                kPrintf( "Fail\n" );
            }
        }
        else
        {
            kPrintf( "Task does not exist or task is system task\n" );
        }
    }
    // 콘솔 셸과 유휴 태스크를 제외하고 모든 태스크 종료
    else
    {
        for( i = 0 ; i < TASK_MAXCOUNT ; i++ )
        {
            pstTCB = kGetTCBInTCBPool( i );
            qwID = pstTCB->stLink.qwID;

            // 시스템 테스트는 삭제 목록에서 제외
            if( ( ( qwID >> 32 ) != 0 ) && ( ( pstTCB->qwFlags & TASK_FLAGS_SYSTEM ) == 0x00 ) )
            {
                kPrintf( "Kill Task ID [0x%q] ", qwID );
                if( kEndTask( qwID ) == TRUE )
                {
                    kPrintf( "Success\n" );
                }
                else
                {
                    kPrintf( "Fail\n" );
                }
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////

/**
 *  프로세서의 사용률을 표시
 */
static void kCPULoad( const char* pcParameterBuffer )
{
    kPrintf( "Processor Load : %d%%\n", kGetProcessorLoad() );
}

////////////////////////////////////////////////////////////////////////////////
//
// 멀티 스레딩 기능을 추가하자.
//
////////////////////////////////////////////////////////////////////////////////
// 뮤텍스 테스트용 뮤텍스와 변수
static MUTEX gs_stMutex;
static volatile QWORD gs_qwAdder;

/**
 *  뮤텍스를 테스트하는 태스크
 */
static void kPrintNumberTask( void )
{
    int i;
    int j;
    QWORD qwTickCount;

    // 50ms 정도 대기하여 콘솔 셸이 출력하는 메시지와 겹치지 않도록 함
    qwTickCount = kGetTickCount();
    while( ( kGetTickCount() - qwTickCount ) < 50 )
    {
        kSchedule();
    }    
    
    // 루프를 돌면서 숫자를 출력
    for( i = 0 ; i < 5 ; i++ )
    {
        kLock( &( gs_stMutex ) );
        kPrintf( "Task ID [0x%Q] Value[%d]\n", kGetRunningTask()->stLink.qwID,
                gs_qwAdder );
        
        gs_qwAdder += 1;
        kUnlock( & ( gs_stMutex ) );
    
        // 프로세서 소모를 늘리려고 추가한 코드
        for( j = 0 ; j < 30000 ; j++ ) ;
    }
    
    // 모든 태스크가 종료할 때까지 1초(100ms) 정도 대기
    qwTickCount = kGetTickCount();
    while( ( kGetTickCount() - qwTickCount ) < 1000 )
    {
        kSchedule();
    }    
    
    // 태스크 종료
    //kExitTask();
}

/**
 *  뮤텍스를 테스트하는 태스크 생성
 */
static void kTestMutex( const char* pcParameterBuffer )
{
    int i;
    
    gs_qwAdder = 1;
    
    // 뮤텍스 초기화
    kInitializeMutex( &gs_stMutex );
    
    for( i = 0 ; i < 3 ; i++ )
    {
        // 뮤텍스를 테스트하는 태스크를 3개 생성
        kCreateTask( TASK_FLAGS_LOW | TASK_FLAGS_THREAD, 0, 0, ( QWORD ) kPrintNumberTask );
    }    
    kPrintf( "Wait Util %d Task End...\n", i );
    kGetCh();
}

/**
 *  태스크 2를 자신의 스레드로 생성하는 태스크
 */
static void kCreateThreadTask( void )
{
    int i;
    
    for( i = 0 ; i < 3 ; i++ )
    {
        kCreateTask( TASK_FLAGS_LOW | TASK_FLAGS_THREAD, 0, 0, ( QWORD ) kTestTask2 );
    }
    
    while( 1 )
    {
        kSleep( 1 );
    }
}

/**
 *  스레드를 테스트하는 태스크 생성
 */
static void kTestThread( const char* pcParameterBuffer )
{
    TCB* pstProcess;
    
    pstProcess = kCreateTask( TASK_FLAGS_LOW | TASK_FLAGS_PROCESS, ( void * )0xEEEEEEEE, 0x1000, 
                              ( QWORD ) kCreateThreadTask );
    if( pstProcess != NULL )
    {
        kPrintf( "Process [0x%Q] Create Success\n", pstProcess->stLink.qwID ); 
    }
    else
    {
        kPrintf( "Process Create Fail\n" );
    }
}

// 난수를 발생시키기 위한 변수
static volatile QWORD gs_qwRandomValue = 0;

/**
 *  임의의 난수를 반환
 */
QWORD kRandom( void )
{
    gs_qwRandomValue = ( gs_qwRandomValue * 412153 + 5571031 ) >> 16;
    return gs_qwRandomValue;
}

/**
 *  철자를 흘러내리게 하는 스레드
 */
static void kDropCharactorThread( void )
{
    int iX, iY;
    int i;
    char vcText[ 2 ] = { 0, };

    iX = kRandom() % CONSOLE_WIDTH;
    
    while( 1 )
    {
        // 잠시 대기함
        kSleep( kRandom() % 20 );
        
        if( ( kRandom() % 20 ) < 16 )
        {
            vcText[ 0 ] = ' ';
            for( i = 0 ; i < CONSOLE_HEIGHT - 1 ; i++ )
            {
                kPrintStringXY( iX, i , vcText );
                kSleep( 50 );
            }
        }        
        else
        {
            for( i = 0 ; i < CONSOLE_HEIGHT - 1 ; i++ )
            {
                vcText[ 0 ] = i + kRandom();
                kPrintStringXY( iX, i, vcText );
                kSleep( 50 );
            }
        }
    }
}

/**
 *  스레드를 생성하여 매트릭스 화면처럼 보여주는 프로세스
 */
static void kMatrixProcess( void )
{
    int i;
    
    for( i = 0 ; i < 300 ; i++ )
    {
        if( kCreateTask( TASK_FLAGS_THREAD | TASK_FLAGS_LOW, 0, 0, 
                         ( QWORD ) kDropCharactorThread ) == NULL )
        {
            break;
        }
        
        kSleep( kRandom() % 5 + 5 );
    }
    
    kPrintf( "%d Thread is created\n", i );

    // 키가 입력되면 프로세스 종료
    kGetCh();
}

/**
 *  매트릭스 화면을 보여줌
 */
static void kShowMatrix( const char* pcParameterBuffer )
{
    TCB* pstProcess;
    
    pstProcess = kCreateTask( TASK_FLAGS_PROCESS | TASK_FLAGS_LOW, ( void* ) 0xE00000, 0xE00000, 
                              ( QWORD ) kMatrixProcess );
    if( pstProcess != NULL )
    {
        kPrintf( "Matrix Process [0x%Q] Create Success\n" );

        // 태스크가 종료 될 때까지 대기
        while( ( pstProcess->stLink.qwID >> 32 ) != 0 )
        {
            kSleep( 100 );
        }
    }
    else
    {
        kPrintf( "Matrix Process Create Fail\n" );
    }
} 
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 실수 연산 기능 통합과 빌드
//
////////////////////////////////////////////////////////////////////////////////
/**
 *  FPU를 테스트하는 태스크
 */
static void kFPUTestTask( void )
{
    double dValue1;
    double dValue2;
    TCB* pstRunningTask;
    QWORD qwCount = 0;
    QWORD qwRandomValue;
    int i;
    int iOffset;
    char vcData[ 4 ] = { '-', '\\', '|', '/' };
    CHARACTER* pstScreen = ( CHARACTER* ) CONSOLE_VIDEOMEMORYADDRESS;

    pstRunningTask = kGetRunningTask();

    // 자신의 ID를 얻어서 화면 오프셋으로 사용
    iOffset = ( pstRunningTask->stLink.qwID & 0xFFFFFFFF ) * 2;
    iOffset = CONSOLE_WIDTH * CONSOLE_HEIGHT - 
        ( iOffset % ( CONSOLE_WIDTH * CONSOLE_HEIGHT ) );

    // 루프를 무한히 반복하면서 동일한 계산을 수행
    while( 1 )
    {
        dValue1 = 1;
        dValue2 = 1;
        
        // 테스트를 위해 동일한 계산을 2번 반복해서 실행
        for( i = 0 ; i < 10 ; i++ )
        {
            qwRandomValue = kRandom();
            dValue1 *= ( double ) qwRandomValue;
            dValue2 *= ( double ) qwRandomValue;

            kSleep( 1 );
            
            qwRandomValue = kRandom();
            dValue1 /= ( double ) qwRandomValue;
            dValue2 /= ( double ) qwRandomValue;
        }
        
        if( dValue1 != dValue2 )
        {
            kPrintf( "Value Is Not Same~!!! [%f] != [%f]\n", dValue1, dValue2 );
            break;
        }
        qwCount++;

        // 회전하는 바람개비를 표시
        pstScreen[ iOffset ].bCharactor = vcData[ qwCount % 4 ];

        // 색깔 지정
        pstScreen[ iOffset ].bAttribute = 0x70 |( iOffset % 15 ) + 1;
    }
}

/**
 *  원주율(PIE)를 계산
 */
static void kTestPIE( const char* pcParameterBuffer )
{
    double dResult;
    int i;
    
    kPrintf( "PIE Cacluation Test\n" );
    kPrintf( "Result: 355 / 113 = " );
    dResult = ( double ) 355 / 113;
    kPrintf( "%d.%d%d\n", ( QWORD ) dResult, ( ( QWORD ) ( dResult * 10 ) % 10 ),
             ( ( QWORD ) ( dResult * 100 ) % 10 ) );
    
    // 실수를 계산하는 태스크를 생성
    for( i = 0 ; i < 100 ; i++ )
    {
        kCreateTask( TASK_FLAGS_LOW | TASK_FLAGS_THREAD, 0, 0, ( QWORD ) kFPUTestTask );
    }
}
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 동적 메모리 할당
//
//////////////////////////////////////////////////////////////////////////////// 
/**
 *  동적 메모리 정보를 표시
 */
static void kShowDyanmicMemoryInformation( const char* pcParameterBuffer )
{
    QWORD qwStartAddress, qwTotalSize, qwMetaSize, qwUsedSize;
    
    kGetDynamicMemoryInformation( &qwStartAddress, &qwTotalSize, &qwMetaSize, 
            &qwUsedSize );

    kPrintf( "============ Dynamic Memory Information ============\n" );
    kPrintf( "Start Address: [0x%Q]\n", qwStartAddress );
    kPrintf( "Total Size:    [0x%Q]byte, [%d]MB\n", qwTotalSize, 
            qwTotalSize / 1024 / 1024 );
    kPrintf( "Meta Size:     [0x%Q]byte, [%d]KB\n", qwMetaSize, 
            qwMetaSize / 1024 );
    kPrintf( "Used Size:     [0x%Q]byte, [%d]KB\n", qwUsedSize, qwUsedSize / 1024 );
}

/**
 *  모든 블록 리스트의 블록을 순차적으로 할당하고 해제하는 테스트
 */
static void kTestSequentialAllocation( const char* pcParameterBuffer )
{
    DYNAMICMEMORY* pstMemory;
    long i, j, k;
    QWORD* pqwBuffer;
    
    kPrintf( "============ Dynamic Memory Test ============\n" );
    pstMemory = kGetDynamicMemoryManager();
    
    for( i = 0 ; i < pstMemory->iMaxLevelCount ; i++ )
    {
        kPrintf( "Block List [%d] Test Start\n", i );
        kPrintf( "Allocation And Compare: ");
        
        // 모든 블록을 할당 받아서 값을 채운 후 검사
        for( j = 0 ; j < ( pstMemory->iBlockCountOfSmallestBlock >> i ) ; j++ )
        {
            pqwBuffer = kAllocateMemory( DYNAMICMEMORY_MIN_SIZE << i );
            if( pqwBuffer == NULL )
            {
                kPrintf( "\nAllocation Fail\n" );
                return ;
            }

            // 값을 채운 후 다시 검사
            for( k = 0 ; k < ( DYNAMICMEMORY_MIN_SIZE << i ) / 8 ; k++ )
            {
                pqwBuffer[ k ] = k;
            }
            
            for( k = 0 ; k < ( DYNAMICMEMORY_MIN_SIZE << i ) / 8 ; k++ )
            {
                if( pqwBuffer[ k ] != k )
                {
                    kPrintf( "\nCompare Fail\n" );
                    return ;
                }
            }
            // 진행 과정을 . 으로 표시
            kPrintf( "." );
        }
        
        kPrintf( "\nFree: ");
        // 할당 받은 블록을 모두 반환
        for( j = 0 ; j < ( pstMemory->iBlockCountOfSmallestBlock >> i ) ; j++ )
        {
            if( kFreeMemory( ( void * ) ( pstMemory->qwStartAddress + 
                         ( DYNAMICMEMORY_MIN_SIZE << i ) * j ) ) == FALSE )
            {
                kPrintf( "\nFree Fail\n" );
                return ;
            }
            // 진행 과정을 . 으로 표시
            kPrintf( "." );
        }
        kPrintf( "\n" );
    }
    kPrintf( "Test Complete~!!!\n" );
}

/**
 *  임의로 메모리를 할당하고 해제하는 것을 반복하는 태스크
 */
static void kRandomAllocationTask( void )
{
    TCB* pstTask;
    QWORD qwMemorySize;
    char vcBuffer[ 200 ];
    BYTE* pbAllocationBuffer;
    int i, j;
    int iY;
    
    pstTask = kGetRunningTask();
    iY = ( pstTask->stLink.qwID ) % 15 + 9;

    for( j = 0 ; j < 10 ; j++ )
    {
        // 1KB ~ 32M까지 할당하도록 함
        do
        {
            qwMemorySize = ( ( kRandom() % ( 32 * 1024 ) ) + 1 ) * 1024;
            pbAllocationBuffer = kAllocateMemory( qwMemorySize );

            // 만일 버퍼를 할당 받지 못하면 다른 태스크가 메모리를 사용하고 
            // 있을 수 있으므로 잠시 대기한 후 다시 시도
            if( pbAllocationBuffer == 0 )
            {
                kSleep( 1 );
            }
        } while( pbAllocationBuffer == 0 );
            
        kSPrintf( vcBuffer, "|Address: [0x%Q] Size: [0x%Q] Allocation Success", 
                  pbAllocationBuffer, qwMemorySize );
        // 자신의 ID를 Y 좌표로 하여 데이터를 출력
        kPrintStringXY( 20, iY, vcBuffer );
        kSleep( 200 );
        
        // 버퍼를 반으로 나눠서 랜덤한 데이터를 똑같이 채움 
        kSPrintf( vcBuffer, "|Address: [0x%Q] Size: [0x%Q] Data Write...     ", 
                  pbAllocationBuffer, qwMemorySize );
        kPrintStringXY( 20, iY, vcBuffer );
        for( i = 0 ; i < qwMemorySize / 2 ; i++ )
        {
            pbAllocationBuffer[ i ] = kRandom() & 0xFF;
            pbAllocationBuffer[ i + ( qwMemorySize / 2 ) ] = pbAllocationBuffer[ i ];
        }
        kSleep( 200 );
        
        // 채운 데이터가 정상적인지 다시 확인
        kSPrintf( vcBuffer, "|Address: [0x%Q] Size: [0x%Q] Data Verify...   ", 
                  pbAllocationBuffer, qwMemorySize );
        kPrintStringXY( 20, iY, vcBuffer );
        for( i = 0 ; i < qwMemorySize / 2 ; i++ )
        {
            if( pbAllocationBuffer[ i ] != pbAllocationBuffer[ i + ( qwMemorySize / 2 ) ] )
            {
                kPrintf( "Task ID[0x%Q] Verify Fail\n", pstTask->stLink.qwID );
                kExitTask();
            }
        }
        kFreeMemory( pbAllocationBuffer );
        kSleep( 200 );
    }
    
    kExitTask();
}

/**
 *  태스크를 여러 개 생성하여 임의의 메모리를 할당하고 해제하는 것을 반복하는 테스트
 */
static void kTestRandomAllocation( const char* pcParameterBuffer )
{
    int i;
    
    for( i = 0 ; i < 1000 ; i++ )
    {
        kCreateTask( TASK_FLAGS_LOWEST | TASK_FLAGS_THREAD, 0, 0, ( QWORD ) kRandomAllocationTask );
    }
}

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
//
// 하드디스크 디바이스 드라이버 추가 
//
////////////////////////////////////////////////////////////////
/**
 *  하드 디스크의 정보를 표시
 */
static void kShowHDDInformation( const char* pcParameterBuffer )
{
    HDDINFORMATION stHDD;
    char vcBuffer[ 100 ];
    
    // 하드 디스크의 정보를 읽음
    if( kGetHDDInformation(&stHDD)== FALSE )
    {
        kPrintf( "HDD Information Read Fail\n" );
        return ;
    }        
    
    kPrintf( "============ Primary Master HDD Information ============\n" );
    
    // 모델 번호 출력
    kMemCpy( vcBuffer, stHDD.vwModelNumber, sizeof( stHDD.vwModelNumber ) );
    vcBuffer[ sizeof( stHDD.vwModelNumber ) - 1 ] = '\0';
    kPrintf( "Model Number:\t %s\n", vcBuffer );
    
    // 시리얼 번호 출력
    kMemCpy( vcBuffer, stHDD.vwSerialNumber, sizeof( stHDD.vwSerialNumber ) );
    vcBuffer[ sizeof( stHDD.vwSerialNumber ) - 1 ] = '\0';
    kPrintf( "Serial Number:\t %s\n", vcBuffer );

    // 헤드, 실린더, 실린더 당 섹터 수를 출력
    kPrintf( "Head Count:\t %d\n", stHDD.wNumberOfHead );
    kPrintf( "Cylinder Count:\t %d\n", stHDD.wNumberOfCylinder );
    kPrintf( "Sector Count:\t %d\n", stHDD.wNumberOfSectorPerCylinder );
    
    // 총 섹터 수 출력
    kPrintf( "Total Sector:\t %d Sector, %dMB\n", stHDD.dwTotalSectors, 
            stHDD.dwTotalSectors / 2 / 1024 );
}

/**
 *  하드 디스크에 파라미터로 넘어온 LBA 어드레스에서 섹터 수 만큼 읽음
 */
static void kReadSector( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcLBA[ 50 ], vcSectorCount[ 50 ];
    DWORD dwLBA;
    int iSectorCount;
    char* pcBuffer;
    int i, j;
    BYTE bData;
    BOOL bExit = FALSE;
    
    // 파라미터 리스트를 초기화하여 LBA 어드레스와 섹터 수 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    if( ( kGetNextParameter( &stList, vcLBA ) == 0 ) ||
        ( kGetNextParameter( &stList, vcSectorCount ) == 0 ) )
    {
        kPrintf( "ex) readsector 0(LBA) 10(count)\n" );
        return ;
    }
    dwLBA = kAToI( vcLBA, 10 );
    iSectorCount = kAToI( vcSectorCount, 10 );
    
    // 섹터 수만큼 메모리를 할당 받아 읽기 수행
    pcBuffer = kAllocateMemory( iSectorCount * 512 );
    if( kReadHDDSector( TRUE, TRUE, dwLBA, iSectorCount, pcBuffer ) == iSectorCount )
    {
        kPrintf( "LBA [%d], [%d] Sector Read Success~!!", dwLBA, iSectorCount );
        // 데이터 버퍼의 내용을 출력
        for( j = 0 ; j < iSectorCount ; j++ )
        {
            for( i = 0 ; i < 512 ; i++ )
            {
                if( !( ( j == 0 ) && ( i == 0 ) ) && ( ( i % 256 ) == 0 ) )
                {
                    kPrintf( "\nPress any key to continue... ('q' is exit) : " );
                    if( kGetCh() == 'q' )
                    {
                        bExit = TRUE;
                        break;
                    }
                }                

                if( ( i % 16 ) == 0 )
                {
                    kPrintf( "\n[LBA:%d, Offset:%d]\t| ", dwLBA + j, i ); 
                }

                // 모두 두 자리로 표시하려고 16보다 작은 경우 0을 추가해줌
                bData = pcBuffer[ j * 512 + i ] & 0xFF;
                if( bData < 16 )
                {
                    kPrintf( "0" );
                }
                kPrintf( "%X ", bData );
            }
            
            if( bExit == TRUE )
            {
                break;
            }
        }
        kPrintf( "\n" );
    }
    else
    {
        kPrintf( "Read Fail\n" );
    }
    
    kFreeMemory( pcBuffer );
}

/**
 *  하드 디스크에 파라미터로 넘어온 LBA 어드레스에서 섹터 수 만큼 씀
 */
static void kWriteSector( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcLBA[ 50 ], vcSectorCount[ 50 ];
    DWORD dwLBA;
    int iSectorCount;
    char* pcBuffer;
    int i, j;
    BOOL bExit = FALSE;
    BYTE bData;
    static DWORD s_dwWriteCount = 0;

    // 파라미터 리스트를 초기화하여 LBA 어드레스와 섹터 수 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    if( ( kGetNextParameter( &stList, vcLBA ) == 0 ) ||
        ( kGetNextParameter( &stList, vcSectorCount ) == 0 ) )
    {
        kPrintf( "ex) writesector 0(LBA) 10(count)\n" );
        return ;
    }
    dwLBA = kAToI( vcLBA, 10 );
    iSectorCount = kAToI( vcSectorCount, 10 );

    s_dwWriteCount++;
    
    // 버퍼를 할당 받아 데이터를 채움. 
    // 패턴은 4 바이트의 LBA 어드레스와 4 바이트의 쓰기가 수행된 횟수로 생성
    pcBuffer = kAllocateMemory( iSectorCount * 512 );
    for( j = 0 ; j < iSectorCount ; j++ )
    {
        for( i = 0 ; i < 512 ; i += 8 )
        {
            *( DWORD* ) &( pcBuffer[ j * 512 + i ] ) = dwLBA + j;
            *( DWORD* ) &( pcBuffer[ j * 512 + i + 4 ] ) = s_dwWriteCount;            
        }
    }
    
    // 쓰기 수행
    if( kWriteHDDSector( TRUE, TRUE, dwLBA, iSectorCount, pcBuffer ) != iSectorCount )
    {
        kPrintf( "Write Fail\n" );
        return ;
    }
    kPrintf( "LBA [%d], [%d] Sector Write Success~!!", dwLBA, iSectorCount );

    // 데이터 버퍼의 내용을 출력
    for( j = 0 ; j < iSectorCount ; j++ )
    {
        for( i = 0 ; i < 512 ; i++ )
        {
            if( !( ( j == 0 ) && ( i == 0 ) ) && ( ( i % 256 ) == 0 ) )
            {
                kPrintf( "\nPress any key to continue... ('q' is exit) : " );
                if( kGetCh() == 'q' )
                {
                    bExit = TRUE;
                    break;
                }
            }                

            if( ( i % 16 ) == 0 )
            {
                kPrintf( "\n[LBA:%d, Offset:%d]\t| ", dwLBA + j, i ); 
            }

            // 모두 두 자리로 표시하려고 16보다 작은 경우 0을 추가해줌
            bData = pcBuffer[ j * 512 + i ] & 0xFF;
            if( bData < 16 )
            {
                kPrintf( "0" );
            }
            kPrintf( "%X ", bData );
        }
        
        if( bExit == TRUE )
        {
            break;
        }
    }
    kPrintf( "\n" );    
    kFreeMemory( pcBuffer );    
}
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
//
// 간단한 파일 시스템 구현
//
////////////////////////////////////////////////////////////////
/**
 *  하드 디스크를 연결
 */
static void kMountHDD( const char* pcParameterBuffer )
{
    if( kMount() == FALSE )
    {
        kPrintf( "HDD Mount Fail\n" );
        return ;
    }
    kPrintf( "HDD Mount Success\n" );
}

/**
 *  하드 디스크에 파일 시스템을 생성(포맷)
 */
static void kFormatHDD( const char* pcParameterBuffer )
{
    if( kFormat() == FALSE )
    {
        kPrintf( "HDD Format Fail\n" );
        return ;
    }
    kPrintf( "HDD Format Success\n" );
}

/**
 *  파일 시스템 정보를 표시
 */
static void kShowFileSystemInformation( const char* pcParameterBuffer )
{
    FILESYSTEMMANAGER stManager;
    
    kGetFileSystemInformation( &stManager );
    
    kPrintf( "================== File System Information ==================\n" );
    kPrintf( "Mouted:\t\t\t\t\t %d\n", stManager.bMounted );
    kPrintf( "Reserved Sector Count:\t\t\t %d Sector\n", stManager.dwReservedSectorCount );
    kPrintf( "Cluster Link Table Start Address:\t %d Sector\n", 
            stManager.dwClusterLinkAreaStartAddress );
    kPrintf( "Cluster Link Table Size:\t\t %d Sector\n", stManager.dwClusterLinkAreaSize );
    kPrintf( "Data Area Start Address:\t\t %d Sector\n", stManager.dwDataAreaStartAddress );
    kPrintf( "Total Cluster Count:\t\t\t %d Cluster\n", stManager.dwTotalClusterCount );
}


////////////////////////////////////////////////////////////////////////////////
//
// C 표준 입출력 함수 추가
//
////////////////////////////////////////////////////////////////////////////////
/**
 *  루트 디렉터리에 빈 파일을 생성
 */
static void kCreateFileInRootDirectory( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcFileName[ 50 ];
    int iLength;
    DWORD dwCluster;
    int i;
    FILE* pstFile;
    
    // 파라미터 리스트를 초기화하여 파일 이름을 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    iLength = kGetNextParameter( &stList, vcFileName );
    vcFileName[ iLength ] = '\0';
    if( ( iLength > ( FILESYSTEM_MAXFILENAMELENGTH - 1 ) ) || ( iLength == 0 ) )
    {
        kPrintf( "Too Long or Too Short File Name\n" );
        return ;
    }

    pstFile = fopen( vcFileName, "w" );
    if( pstFile == NULL )
    {
        kPrintf( "File Create Fail\n" );
        return;
    }
    fclose( pstFile );
    kPrintf( "File Create Success\n" );
}

/**
 *  루트 디렉터리에서 파일을 삭제
 */
static void kDeleteFileInRootDirectory( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcFileName[ 50 ];
    int iLength;
    
    // 파라미터 리스트를 초기화하여 파일 이름을 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    iLength = kGetNextParameter( &stList, vcFileName );
    vcFileName[ iLength ] = '\0';
    if( ( iLength > ( FILESYSTEM_MAXFILENAMELENGTH - 1 ) ) || ( iLength == 0 ) )
    {
        kPrintf( "Too Long or Too Short File Name\n" );
        return ;
    }

    if( remove( vcFileName ) != 0 )
    {
        kPrintf( "File Not Found or File Opened\n" );
        return ;
    }
    
    kPrintf( "File Delete Success\n" );
}

/**
 *  루트 디렉터리의 파일 목록을 표시
 */
static void kShowRootDirectory( const char* pcParameterBuffer )
{
    DIR* pstDirectory;
    int i, iCount, iTotalCount;
    struct dirent* pstEntry;
    char vcBuffer[ 400 ];
    char vcTempValue[ 50 ];
    DWORD dwTotalByte;
    DWORD dwUsedClusterCount;
    FILESYSTEMMANAGER stManager;
    
    // 파일 시스템 정보를 얻음
    kGetFileSystemInformation( &stManager );
     
    // 루트 디렉터리를 엶
    pstDirectory = opendir( "/" );
    if( pstDirectory == NULL )
    {
        kPrintf( "Root Directory Open Fail\n" );
        return ;
    }
    
    // 먼저 루프를 돌면서 디렉터리에 있는 파일의 개수와 전체 파일이 사용한 크기를 계산
    iTotalCount = 0;
    dwTotalByte = 0;
    dwUsedClusterCount = 0;
    while( 1 )
    {
        // 디렉터리에서 엔트리 하나를 읽음
        pstEntry = readdir( pstDirectory );
        // 더이상 파일이 없으면 나감
        if( pstEntry == NULL )
        {
            break;
        }
        iTotalCount++;
        dwTotalByte += pstEntry->dwFileSize;

        // 실제로 사용된 클러스터의 개수를 계산
        if( pstEntry->dwFileSize == 0 )
        {
            // 크기가 0이라도 클러스터 1개는 할당되어 있음
            dwUsedClusterCount++;
        }
        else
        {
            // 클러스터 개수를 올림하여 더함
            dwUsedClusterCount += ( pstEntry->dwFileSize + 
                ( FILESYSTEM_CLUSTERSIZE - 1 ) ) / FILESYSTEM_CLUSTERSIZE;
        }
    }
    
    // 실제 파일의 내용을 표시하는 루프
    rewinddir( pstDirectory );
    iCount = 0;
    while( 1 )
    {
        // 디렉터리에서 엔트리 하나를 읽음
        pstEntry = readdir( pstDirectory );
        // 더이상 파일이 없으면 나감
        if( pstEntry == NULL )
        {
            break;
        }
        
        // 전부 공백으로 초기화 한 후 각 위치에 값을 대입
        kMemSet( vcBuffer, ' ', sizeof( vcBuffer ) - 1 );
        vcBuffer[ sizeof( vcBuffer ) - 1 ] = '\0';
        
        // 파일 이름 삽입
        kMemCpy( vcBuffer, pstEntry->d_name, 
                 kStrLen( pstEntry->d_name ) );

        // 파일 길이 삽입
        kSPrintf( vcTempValue, "%d Byte", pstEntry->dwFileSize );
        kMemCpy( vcBuffer + 30, vcTempValue, kStrLen( vcTempValue ) );

        // 파일의 시작 클러스터 삽입
        kSPrintf( vcTempValue, "0x%X Cluster", pstEntry->dwStartClusterIndex );
        kMemCpy( vcBuffer + 55, vcTempValue, kStrLen( vcTempValue ) + 1 );
        kPrintf( "    %s\n", vcBuffer );

        if( ( iCount != 0 ) && ( ( iCount % 20 ) == 0 ) )
        {
            kPrintf( "Press any key to continue... ('q' is exit) : " );
            if( kGetCh() == 'q' )
            {
                kPrintf( "\n" );
                break;
            }        
        }
        iCount++;
    }
    
    // 총 파일의 개수와 파일의 총 크기를 출력
    kPrintf( "\t\tTotal File Count: %d\n", iTotalCount );
    kPrintf( "\t\tTotal File Size: %d KByte (%d Cluster)\n", dwTotalByte, 
             dwUsedClusterCount );
    
    // 남은 클러스터 수를 이용해서 여유 공간을 출력
    kPrintf( "\t\tFree Space: %d KByte (%d Cluster)\n", 
             ( stManager.dwTotalClusterCount - dwUsedClusterCount ) * 
             FILESYSTEM_CLUSTERSIZE / 1024, stManager.dwTotalClusterCount - 
             dwUsedClusterCount );
    
    // 디렉터리를 닫음
    closedir( pstDirectory );
}

/**
 *  파일을 생성하여 키보드로 입력된 데이터를 씀
 */
static void kWriteDataToFile( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcFileName[ 50 ];
    int iLength;
    FILE* fp;
    int iEnterCount;
    BYTE bKey;
    
    // 파라미터 리스트를 초기화하여 파일 이름을 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    iLength = kGetNextParameter( &stList, vcFileName );
    vcFileName[ iLength ] = '\0';
    if( ( iLength > ( FILESYSTEM_MAXFILENAMELENGTH - 1 ) ) || ( iLength == 0 ) )
    {
        kPrintf( "Too Long or Too Short File Name\n" );
        return ;
    }
    
    // 파일 생성
    fp = fopen( vcFileName, "w" );
    if( fp == NULL )
    {
        kPrintf( "%s File Open Fail\n", vcFileName );
        return ;
    }
    
    // 엔터 키가 연속으로 3번 눌러질 때까지 내용을 파일에 씀
    iEnterCount = 0;
    while( 1 )
    {
        bKey = kGetCh();
        // 엔터 키이면 연속 3번 눌러졌는가 확인하여 루프를 빠져 나감
        if( bKey == KEY_ENTER )
        {
            iEnterCount++;
            if( iEnterCount >= 3 )
            {
                break;
            }
        }
        // 엔터 키가 아니라면 엔터 키 입력 횟수를 초기화
        else
        {
            iEnterCount = 0;
        }
        
        kPrintf( "%c", bKey );
        if( fwrite( &bKey, 1, 1, fp ) != 1 )
        {
            kPrintf( "File Wirte Fail\n" );
            break;
        }
    }
    
    kPrintf( "File Create Success\n" );
    fclose( fp );
}

/**
 *  파일을 열어서 데이터를 읽음
 */
static void kReadDataFromFile( const char* pcParameterBuffer )
{
    PARAMETERLIST stList;
    char vcFileName[ 50 ];
    int iLength;
    FILE* fp;
    int iEnterCount;
    BYTE bKey;
    
    // 파라미터 리스트를 초기화하여 파일 이름을 추출
    kInitializeParameter( &stList, pcParameterBuffer );
    iLength = kGetNextParameter( &stList, vcFileName );
    vcFileName[ iLength ] = '\0';
    if( ( iLength > ( FILESYSTEM_MAXFILENAMELENGTH - 1 ) ) || ( iLength == 0 ) )
    {
        kPrintf( "Too Long or Too Short File Name\n" );
        return ;
    }
    
    // 파일 생성
    fp = fopen( vcFileName, "r" );
    if( fp == NULL )
    {
        kPrintf( "%s File Open Fail\n", vcFileName );
        return ;
    }
    
    // 파일의 끝까지 출력하는 것을 반복
    iEnterCount = 0;
    while( 1 )
    {
        if( fread( &bKey, 1, 1, fp ) != 1 )
        {
            break;
        }
        kPrintf( "%c", bKey );
        
        // 만약 엔터 키이면 엔터 키 횟수를 증가시키고 20라인까지 출력했다면 
        // 더 출력할지 여부를 물어봄
        if( bKey == KEY_ENTER )
        {
            iEnterCount++;
            
            if( ( iEnterCount != 0 ) && ( ( iEnterCount % 20 ) == 0 ) )
            {
                kPrintf( "Press any key to continue... ('q' is exit) : " );
                if( kGetCh() == 'q' )
                {
                    kPrintf( "\n" );
                    break;
                }
                kPrintf( "\n" );
                iEnterCount = 0;
            }
        }
    }
    fclose( fp );
}

/**
 *  파일 I/O에 관련된 기능을 테스트
 */
static void kTestFileIO( const char* pcParameterBuffer )
{
    FILE* pstFile;
    BYTE* pbBuffer;
    int i;
    int j;
    DWORD dwRandomOffset;
    DWORD dwByteCount;
    BYTE vbTempBuffer[ 1024 ];
    DWORD dwMaxFileSize;
    
    kPrintf( "================== File I/O Function Test ==================\n" );
    
    // 4Mbyte의 버퍼 할당
    dwMaxFileSize = 4 * 1024 * 1024;
    pbBuffer = kAllocateMemory( dwMaxFileSize );
    if( pbBuffer == NULL )
    {
        kPrintf( "Memory Allocation Fail\n" );
        return ;
    }
    // 테스트용 파일을 삭제
    remove( "testfileio.bin" );

    //==========================================================================
    // 파일 열기 테스트
    //==========================================================================
    kPrintf( "1. File Open Fail Test..." );
    // r 옵션은 파일을 생성하지 않으므로, 테스트 파일이 없는 경우 NULL이 되어야 함
    pstFile = fopen( "testfileio.bin", "r" );
    if( pstFile == NULL )
    {
        kPrintf( "[Pass]\n" );
    }
    else
    {
        kPrintf( "[Fail]\n" );
        fclose( pstFile );
    }
    
    //==========================================================================
    // 파일 생성 테스트
    //==========================================================================
    kPrintf( "2. File Create Test..." );
    // w 옵션은 파일을 생성하므로, 정상적으로 핸들이 반환되어야함
    pstFile = fopen( "testfileio.bin", "w" );
    if( pstFile != NULL )
    {
        kPrintf( "[Pass]\n" );
        kPrintf( "    File Handle [0x%Q]\n", pstFile );
    }
    else
    {
        kPrintf( "[Fail]\n" );
    }
    
    //==========================================================================
    // 순차적인 영역 쓰기 테스트
    //==========================================================================
    kPrintf( "3. Sequential Write Test(Cluster Size)..." );
    // 열린 핸들을 가지고 쓰기 수행
    for( i = 0 ; i < 100 ; i++ )
    {
        kMemSet( pbBuffer, i, FILESYSTEM_CLUSTERSIZE );
        if( fwrite( pbBuffer, 1, FILESYSTEM_CLUSTERSIZE, pstFile ) !=
            FILESYSTEM_CLUSTERSIZE )
        {
            kPrintf( "[Fail]\n" );
            kPrintf( "    %d Cluster Error\n", i );
            break;
        }
    }
    if( i >= 100 )
    {
        kPrintf( "[Pass]\n" );
    }
    
    //==========================================================================
    // 순차적인 영역 읽기 테스트
    //==========================================================================
    kPrintf( "4. Sequential Read And Verify Test(Cluster Size)..." );
    // 파일의 처음으로 이동
    fseek( pstFile, -100 * FILESYSTEM_CLUSTERSIZE, SEEK_END );
    
    // 열린 핸들을 가지고 읽기 수행 후, 데이터 검증
    for( i = 0 ; i < 100 ; i++ )
    {
        // 파일을 읽음
        if( fread( pbBuffer, 1, FILESYSTEM_CLUSTERSIZE, pstFile ) !=
            FILESYSTEM_CLUSTERSIZE )
        {
            kPrintf( "[Fail]\n" );
            return ;
        }
        
        // 데이터 검사
        for( j = 0 ; j < FILESYSTEM_CLUSTERSIZE ; j++ )
        {
            if( pbBuffer[ j ] != ( BYTE ) i )
            {
                kPrintf( "[Fail]\n" );
                kPrintf( "    %d Cluster Error. [%X] != [%X]\n", i, pbBuffer[ j ], 
                         ( BYTE ) i );
                break;
            }
        }
    }
    if( i >= 100 )
    {
        kPrintf( "[Pass]\n" );
    }

    //==========================================================================
    // 임의의 영역 쓰기 테스트
    //==========================================================================
    kPrintf( "5. Random Write Test...\n" );
    
    // 버퍼를 모두 0으로 채움
    kMemSet( pbBuffer, 0, dwMaxFileSize );
    // 여기 저기에 옮겨다니면서 데이터를 쓰고 검증
    // 파일의 내용을 읽어서 버퍼로 복사
    fseek( pstFile, -100 * FILESYSTEM_CLUSTERSIZE, SEEK_CUR );
    fread( pbBuffer, 1, dwMaxFileSize, pstFile );
    
    // 임의의 위치로 옮기면서 데이터를 파일과 버퍼에 동시에 씀
    for( i = 0 ; i < 100 ; i++ )
    {
        dwByteCount = ( kRandom() % ( sizeof( vbTempBuffer ) - 1 ) ) + 1;
        dwRandomOffset = kRandom() % ( dwMaxFileSize - dwByteCount );
        
        kPrintf( "    [%d] Offset [%d] Byte [%d]...", i, dwRandomOffset, 
                dwByteCount );

        // 파일 포인터를 이동
        fseek( pstFile, dwRandomOffset, SEEK_SET );
        kMemSet( vbTempBuffer, i, dwByteCount );
              
        // 데이터를 씀
        if( fwrite( vbTempBuffer, 1, dwByteCount, pstFile ) != dwByteCount )
        {
            kPrintf( "[Fail]\n" );
            break;
        }
        else
        {
            kPrintf( "[Pass]\n" );
        }
        
        kMemSet( pbBuffer + dwRandomOffset, i, dwByteCount );
    }
    
    // 맨 마지막으로 이동하여 1바이트를 써서 파일의 크기를 4Mbyte로 만듦
    fseek( pstFile, dwMaxFileSize - 1, SEEK_SET );
    fwrite( &i, 1, 1, pstFile );
    pbBuffer[ dwMaxFileSize - 1 ] = ( BYTE ) i;

    //==========================================================================
    // 임의의 영역 읽기 테스트
    //==========================================================================
    kPrintf( "6. Random Read And Verify Test...\n" );
    // 임의의 위치로 옮기면서 파일에서 데이터를 읽어 버퍼의 내용과 비교
    for( i = 0 ; i < 100 ; i++ )
    {
        dwByteCount = ( kRandom() % ( sizeof( vbTempBuffer ) - 1 ) ) + 1;
        dwRandomOffset = kRandom() % ( ( dwMaxFileSize ) - dwByteCount );

        kPrintf( "    [%d] Offset [%d] Byte [%d]...", i, dwRandomOffset, 
                dwByteCount );
        
        // 파일 포인터를 이동
        fseek( pstFile, dwRandomOffset, SEEK_SET );
        
        // 데이터 읽음
        if( fread( vbTempBuffer, 1, dwByteCount, pstFile ) != dwByteCount )
        {
            kPrintf( "[Fail]\n" );
            kPrintf( "    Read Fail\n", dwRandomOffset ); 
            break;
        }
        
        // 버퍼와 비교
        if( kMemCmp( pbBuffer + dwRandomOffset, vbTempBuffer, dwByteCount ) 
                != 0 )
        {
            kPrintf( "[Fail]\n" );
            kPrintf( "    Compare Fail\n", dwRandomOffset ); 
            break;
        }
        
        kPrintf( "[Pass]\n" );
    }
    
    //==========================================================================
    // 다시 순차적인 영역 읽기 테스트
    //==========================================================================
    kPrintf( "7. Sequential Write, Read And Verify Test(1024 Byte)...\n" );
    // 파일의 처음으로 이동
    fseek( pstFile, -dwMaxFileSize, SEEK_CUR );
    
    // 열린 핸들을 가지고 쓰기 수행. 앞부분에서 2Mbyte만 씀
    for( i = 0 ; i < ( 2 * 1024 * 1024 / 1024 ) ; i++ )
    {
        kPrintf( "    [%d] Offset [%d] Byte [%d] Write...", i, i * 1024, 1024 );

        // 1024 바이트씩 파일을 씀
        if( fwrite( pbBuffer + ( i * 1024 ), 1, 1024, pstFile ) != 1024 )
        {
            kPrintf( "[Fail]\n" );
            return ;
        }
        else
        {
            kPrintf( "[Pass]\n" );
        }
    }

    // 파일의 처음으로 이동
    fseek( pstFile, -dwMaxFileSize, SEEK_SET );
    
    // 열린 핸들을 가지고 읽기 수행 후 데이터 검증. Random Write로 데이터가 잘못 
    // 저장될 수 있으므로 검증은 4Mbyte 전체를 대상으로 함
    for( i = 0 ; i < ( dwMaxFileSize / 1024 )  ; i++ )
    {
        // 데이터 검사
        kPrintf( "    [%d] Offset [%d] Byte [%d] Read And Verify...", i, 
                i * 1024, 1024 );
        
        // 1024 바이트씩 파일을 읽음
        if( fread( vbTempBuffer, 1, 1024, pstFile ) != 1024 )
        {
            kPrintf( "[Fail]\n" );
            return ;
        }
        
        if( kMemCmp( pbBuffer + ( i * 1024 ), vbTempBuffer, 1024 ) != 0 )
        {
            kPrintf( "[Fail]\n" );
            break;
        }
        else
        {
            kPrintf( "[Pass]\n" );
        }
    }
        
    //==========================================================================
    // 파일 삭제 실패 테스트
    //==========================================================================
    kPrintf( "8. File Delete Fail Test..." );
    // 파일이 열려있는 상태이므로 파일을 지우려고 하면 실패해야 함
    if( remove( "testfileio.bin" ) != 0 )
    {
        kPrintf( "[Pass]\n" );
    }
    else
    {
        kPrintf( "[Fail]\n" );
    }
    
    //==========================================================================
    // 파일 닫기 테스트
    //==========================================================================
    kPrintf( "9. File Close Test..." );
    // 파일이 정상적으로 닫혀야 함
    if( fclose( pstFile ) == 0 )
    {
        kPrintf( "[Pass]\n" );
    }
    else
    {
        kPrintf( "[Fail]\n" );
    }

    //==========================================================================
    // 파일 삭제 테스트
    //==========================================================================
    kPrintf( "10. File Delete Test..." );
    // 파일이 닫혔으므로 정상적으로 지워져야 함 
    if( remove( "testfileio.bin" ) == 0 )
    {
        kPrintf( "[Pass]\n" );
    }
    else
    {
        kPrintf( "[Fail]\n" );
    }
    
    // 메모리를 해제
    kFreeMemory( pbBuffer );    
}

////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
/**
 *  파일을 읽고 쓰는 속도를 측정
 */
static void kTestPerformance( const char* pcParameterBuffer )
{
    FILE* pstFile;
    DWORD dwClusterTestFileSize;
    DWORD dwOneByteTestFileSize;
    QWORD qwLastTickCount;
    DWORD i;
    BYTE* pbBuffer;
    
    // 클러스터는 1Mbyte까지 파일을 테스트
    dwClusterTestFileSize = 1024 * 1024;
    // 1바이트씩 읽고 쓰는 테스트는 시간이 많이 걸리므로 16Kbyte만 테스트
    dwOneByteTestFileSize = 16 * 1024;
    
    // 테스트용 버퍼 메모리 할당
    pbBuffer = kAllocateMemory( dwClusterTestFileSize );
    if( pbBuffer == NULL )
    {
        kPrintf( "Memory Allocate Fail\n" );
        return ;
    }
    
    // 버퍼를 초기화
    kMemSet( pbBuffer, 0, FILESYSTEM_CLUSTERSIZE );
    
    kPrintf( "================== File I/O Performance Test ==================\n" );

    //==========================================================================
    // 클러스터 단위로 파일을 순차적으로 쓰는 테스트
    //==========================================================================
    kPrintf( "1.Sequential Read/Write Test(Cluster Size)\n" );

    // 기존의 테스트 파일을 제거하고 새로 만듦
    remove( "performance.txt" );
    pstFile = fopen( "performance.txt", "w" );
    if( pstFile == NULL )
    {
        kPrintf( "File Open Fail\n" );
        kFreeMemory( pbBuffer );
        return ;
    }
    
    qwLastTickCount = kGetTickCount();
    // 클러스터 단위로 쓰는 테스트
    for( i = 0 ; i < ( dwClusterTestFileSize / FILESYSTEM_CLUSTERSIZE ) ; i++ )
    {
        if( fwrite( pbBuffer, 1, FILESYSTEM_CLUSTERSIZE, pstFile ) != 
            FILESYSTEM_CLUSTERSIZE )
        {
            kPrintf( "Write Fail\n" );
            // 파일을 닫고 메모리를 해제함
            fclose( pstFile );
            kFreeMemory( pbBuffer );
            return ;
        }
    }
    // 시간 출력
    kPrintf( "   Sequential Write(Cluster Size): %d ms\n", kGetTickCount() - 
             qwLastTickCount );

    //==========================================================================
    // 클러스터 단위로 파일을 순차적으로 읽는 테스트
    //==========================================================================
    // 파일의 처음으로 이동
    fseek( pstFile, 0, SEEK_SET );
    
    qwLastTickCount = kGetTickCount();
    // 클러스터 단위로 읽는 테스트
    for( i = 0 ; i < ( dwClusterTestFileSize / FILESYSTEM_CLUSTERSIZE ) ; i++ )
    {
        if( fread( pbBuffer, 1, FILESYSTEM_CLUSTERSIZE, pstFile ) != 
            FILESYSTEM_CLUSTERSIZE )
        {
            kPrintf( "Read Fail\n" );
            // 파일을 닫고 메모리를 해제함
            fclose( pstFile );
            kFreeMemory( pbBuffer );
            return ;
        }
    }
    // 시간 출력
    kPrintf( "   Sequential Read(Cluster Size): %d ms\n", kGetTickCount() - 
             qwLastTickCount );
    
    //==========================================================================
    // 1 바이트 단위로 파일을 순차적으로 쓰는 테스트
    //==========================================================================
    kPrintf( "2.Sequential Read/Write Test(1 Byte)\n" );
    
    // 기존의 테스트 파일을 제거하고 새로 만듦
    remove( "performance.txt" );
    pstFile = fopen( "performance.txt", "w" );
    if( pstFile == NULL )
    {
        kPrintf( "File Open Fail\n" );
        kFreeMemory( pbBuffer );
        return ;
    }
    
    qwLastTickCount = kGetTickCount();
    // 1 바이트 단위로 쓰는 테스트
    for( i = 0 ; i < dwOneByteTestFileSize ; i++ )
    {
        if( fwrite( pbBuffer, 1, 1, pstFile ) != 1 )
        {
            kPrintf( "Write Fail\n" );
            // 파일을 닫고 메모리를 해제함
            fclose( pstFile );
            kFreeMemory( pbBuffer );
            return ;
        }
    }
    // 시간 출력
    kPrintf( "   Sequential Write(1 Byte): %d ms\n", kGetTickCount() - 
             qwLastTickCount );

    //==========================================================================
    // 1 바이트 단위로 파일을 순차적으로 읽는 테스트
    //==========================================================================
    // 파일의 처음으로 이동
    fseek( pstFile, 0, SEEK_SET );
    
    qwLastTickCount = kGetTickCount();
    // 1 바이트 단위로 읽는 테스트
    for( i = 0 ; i < dwOneByteTestFileSize ; i++ )
    {
        if( fread( pbBuffer, 1, 1, pstFile ) != 1 )
        {
            kPrintf( "Read Fail\n" );
            // 파일을 닫고 메모리를 해제함
            fclose( pstFile );
            kFreeMemory( pbBuffer );
            return ;
        }
    }
    // 시간 출력
    kPrintf( "   Sequential Read(1 Byte): %d ms\n", kGetTickCount() - 
             qwLastTickCount );
    
    // 파일을 닫고 메모리를 해제함
    fclose( pstFile );
    kFreeMemory( pbBuffer );
}

/**
 *  파일 시스템의 캐시 버퍼에 있는 데이터를 모두 하드 디스크에 씀 
 */
static void kFlushCache( const char* pcParameterBuffer )
{
    QWORD qwTickCount;
    
    qwTickCount = kGetTickCount();
    kPrintf( "Cache Flush... ");
    if( kFlushFileSystemCache() == TRUE )
    {
        kPrintf( "Pass\n" );
    }
    else
    {
        kPrintf( "Fail\n" );
    }
    kPrintf( "Total Time = %d ms\n", kGetTickCount() - qwTickCount );
}
///////////////////////////////////////////////////////////////////
```

## C 언어 커널 엔트리 포인트 파일 수정

#### 02.Kernel64/Source/Main.c

```c
#include "Types.h"
#include "Keyboard.h"
#include "Descriptor.h"
#include "PIC.h"
#include "Console.h"
#include "ConsoleShell.h"
////////////////////////////////////////////////////////////////////////////////
//
// 라운드 로빈 스케줄러를 추가하자
//
////////////////////////////////////////////////////////////////////////////////
#include "Task.h"
#include "PIT.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// 동적 메모리 할당
//
////////////////////////////////////////////////////////////////////////////////
#include "DynamicMemory.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// 하드디스크 디바이스 드라이버 추가 
//
////////////////////////////////////////////////////////////////
#include "HardDisk.h"
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// 간단한 파일 시스템 구현
//
////////////////////////////////////////////////////////////////
#include "FileSystem.h"
////////////////////////////////////////////////////////////////

// 아래 함수는 C 언어 커널의 시작 부분이다.
void Main(void)
{
////////////////////////////////////////////////////////////////////////////////
//
// 콘솔 셸 추가
//
////////////////////////////////////////////////////////////////////////////////
	int iCursorX, iCursorY;

    // 콘솔을 먼저 초기화한 후, 다음 작업을 수행
    kInitializeConsole( 0, 10 ); 
    kPrintf( "Switch To IA-32e Mode Success~!!\n" );
    kPrintf( "IA-32e C Language Kernel Start..............[Pass]\n" );
    kPrintf( "Initialize Console..........................[Pass]\n" );
    
    // 부팅 상황을 화면에 출력
    kGetCursor( &iCursorX, &iCursorY );
    kPrintf( "GDT Initialize And Switch For IA-32e Mode...[    ]" );
    kInitializeGDTTableAndTSS();
    kLoadGDTR( GDTR_STARTADDRESS );
    kSetCursor( 45, iCursorY++ );
    kPrintf( "Pass\n" );
    
    kPrintf( "TSS Segment Load............................[    ]" );
    kLoadTR( GDT_TSSSEGMENT );
    kSetCursor( 45, iCursorY++ );
    kPrintf( "Pass\n" );
    
    kPrintf( "IDT Initialize..............................[    ]" );
    kInitializeIDTTables();    
    kLoadIDTR( IDTR_STARTADDRESS );
    kSetCursor( 45, iCursorY++ );
    kPrintf( "Pass\n" );
    
    kPrintf( "Total RAM Size Check........................[    ]" );
    kCheckTotalRAMSize();
    kSetCursor( 45, iCursorY++ );
    kPrintf( "Pass], Size = %d MB\n", kGetTotalRAMSize() );
    
////////////////////////////////////////////////////////////////////////////////
//
// 라운드 로빈 스케줄러를 추가하자
//
////////////////////////////////////////////////////////////////////////////////
    kPrintf( "TCB Pool And Scheduler Initialize...........[Pass]\n");
    iCursorY++;
    kInitializeScheduler();
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 동적 메모리 할당
//
////////////////////////////////////////////////////////////////////////////////
// 동적 메모리 초기화
    kPrintf("Dynamic Memory Initialize...................[Pass]\n");
    iCursorY++;
    kInitializeDynamicMemory();
////////////////////////////////////////////////////////////////////////////////

    // 1ms당 한 번씩 인터럽트가 발생하도록 설정
    kInitializePIT(MSTOCOUNT(1),1);

    kPrintf( "Keyboard Activate And Queue Initialize......[    ]" );
    // 키보드를 활성화
    if( kInitializeKeyboard() == TRUE )
    {
        kSetCursor( 45, iCursorY++ );
        kPrintf( "Pass\n" );
        kChangeKeyboardLED( FALSE, FALSE, FALSE );
    }
    else
    {
        kSetCursor( 45, iCursorY++ );
        kPrintf( "Fail\n" );
        while( 1 ) ;
    }
    
    kPrintf( "PIC Controller And Interrupt Initialize.....[    ]" );
    // PIC 컨트롤러 초기화 및 모든 인터럽트 활성화
    kInitializePIC();
    kMaskPICInterrupt( 0 );
    kEnableInterrupt();
    kSetCursor( 45, iCursorY++ );
    kPrintf( "Pass\n" );

////////////////////////////////////////////////////////////////
//
// 하드디스크 디바이스 드라이버 추가 
//
////////////////////////////////////////////////////////////////
// 하드 디스크를 초기화
    kPrintf( "HDD Initialize..............................[    ]" );
    if( kInitializeHDD() == TRUE )
    {
        kSetCursor( 45, iCursorY++ );
        kPrintf( "Pass\n" );
    }
    else
    {
        kSetCursor( 45, iCursorY++ );
        kPrintf( "Fail\n" );
    }
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
//
// 간단한 파일 시스템 구현
//
////////////////////////////////////////////////////////////////
    // 파일 시스템을 초기화
    kPrintf( "File System Initialize......................[    ]" );
    if( kInitializeFileSystem() == TRUE )
    {
        kSetCursor( 45, iCursorY++ );
        kPrintf( "Pass\n" );
    }
    else
    {
        kSetCursor( 45, iCursorY++ );
        kPrintf( "Fail\n" );
    }
////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
//
// 파일 시스템 캐시와 램 디스크 추가
//
///////////////////////////////////////////////////////////////////
    // 파일 시스템을 초기화
    kPrintf( "File System Initialize......................[    ]" );
    if( kInitializeFileSystem() == TRUE )
    {
        kSetCursor( 45, iCursorY++ );
        kPrintf( "Pass\n" );
    }
    else
    {
        kSetCursor( 45, iCursorY++ );
        kPrintf( "Fail\n" );
    }
///////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// 멀티 스레딩 기능을 추가하자.
//
////////////////////////////////////////////////////////////////////////////////
    // 유휴 태스크를 시스템 스레드로 생성하고 셸을 시작
    kCreateTask( TASK_FLAGS_LOWEST | TASK_FLAGS_THREAD | TASK_FLAGS_SYSTEM | TASK_FLAGS_IDLE, 0, 0, 
            ( QWORD ) kIdleTask );
    kStartConsoleShell();
////////////////////////////////////////////////////////////////////////////////
}
```

