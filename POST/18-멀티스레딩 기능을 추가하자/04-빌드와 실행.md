

# 빌드와 실행

이전 장과 지금 장은 큰 차이는 없다.

멀티스레딩 기능이 추가되어 내부적으로는 더욱 튼실해졌지만,<br>겉으로 보면 이전과 같이 바람개비가 돌아갈 뿐이다.

태스크 리스트를 출력하면 프로세스와 스레드 관련 정보가 함께 출력되며,<br>바람개비를 생성한 프로세스를 종료하면 바람개비가 같이 멈추는 것을 확인할 수 있다.

<hr>

### 멀티스레딩 기능을 테스트하는 커맨드를 실행하기 전후의 태스크 상태

![image](https://user-images.githubusercontent.com/34773827/61799144-8357a580-ae65-11e9-96cb-ef7ad0b5dcdd.png)

위에서 콘솔 셸(태스크 ID: 0x100000000)과 유휴 태스크 (태스크ID: 0x200000001)의 태스크 플래그를 보면 최상위 바이트가 각자 0x60과 0x50으로 시작하는 것을 볼 수 있다.

이것으로 보아 콘솔 셸과 유휴 태스크가 시스템 프로세스와 시스템 스레드로 생성되었음을 알 수 있으며, 유휴 태스크의 Parent PID가 0x100000000이므로 콘솔 셸이 생성한 스레드임을 확인할 수 있다.

콘솔 셸의 Thread 항목을 보면 1로 표시되는데, 이것은 콘솔 셸이 생성한 자식 스레드가 1임을 나타낸다.

이제 프로세스와 스레드를 테스트하는 testthread 커맨드를 입력하여 1개의 프로세스와 3개의 테스트 태스크 2번을 생성해보자.

커맨드가 정상적으로 실행되었다면 그림과 같이 생성된 프로세스와 스레드의 ID가 표시되며,<br>생성된 프로세스와 함께 자식 스레드로 생성된 태스크 세 개의 정보를 볼 수있다.

<hr>

### 스레드를 소유한 프로세스를 종료한 화면

프로세스를 종료했을 때 자식 스레드도 같이 종료되는지 테스트해보자.

알고리즘 대로 동작한다면 태스크를 종료시키는 killtask 커맨드로 세 개의 자식 스레드를 가진 프로세스 0x30000002를 강제로 종료시켰을 때 자식 스레드도 모두 종료되어야 한다.

![image](https://user-images.githubusercontent.com/34773827/61799444-17c20800-ae66-11e9-95d0-0a95cd585a4c.png)

위 테스트의 결과로 보아 스레드를 소유한 프로세스를 종료했을 때 우리가 설계한 알고리즘대로 정상적으로 동작한다.

<hr>

### 스레드 테스트 커맨드를 재실행한 후 스레드 1개를 종료

이제 스레드 하나를 종료시켜서 프로세스의 스레드 개수가 정상적으로 변경되는지 테스트해보자.

이번엔 testthread를 입력하여 프로세스와 스레드를 생성한 뒤에 자식 스레드 1개(0x800000003)를 삭제한다.

태스크가 정상적으로 삭제된 후 태스크 리스트를 다시 확인하면 전체 태스크 수가 6에서 5로 변경되었으며,<br>프로세스인 0x700000002의 자식 스레드 수가 2로 줄어 든 것을 볼 수 있다.

#### 종료 전

![image](https://user-images.githubusercontent.com/34773827/61799745-a0d93f00-ae66-11e9-9f49-33d1e5ab4064.png)

#### 종료 후

![image](https://user-images.githubusercontent.com/34773827/61799778-ab93d400-ae66-11e9-8db6-a67d49cf4e5a.png)

테스트의 결과로 보아 스레드가 종료되었을 때 스레드가 프로세스의 자식 스레드 링크에서 정상적으로 제거되는 것을 볼 수 있다.