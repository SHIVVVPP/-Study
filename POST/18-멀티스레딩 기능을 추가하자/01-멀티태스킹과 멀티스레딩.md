# 멀티태스킹과 멀티스레딩



## 프로세스와 스레드

태스크, 프로세스, 스레드 간의 관계를 알려면 프로그램과 프로세스가 무엇이며,<br>또 프로세스와 스레드는 어떤 차이가 있는지를 알아야 한다.

우선 프로그램부터 살펴보면<br>**프로그램은 메모리에 로드하여 실행할 수 있는 코드와 데이터의 집합이다.**

> 우리가 하드디스크나 USB 디스크에서 볼 수 있는 실행 파일이 바로 프로그램이며,<br>메모리에 로드되기 전의 프로그램은 단순한 데이터이다.

이러한 **프로그램이 메모리에 로드되어 실행 가능한 상태가 되면 프로세스(*Process*) 가 된다.**<br>프로세스는 CPU를 할당 받아 코드를 실행할 수 있으며, 독립된 메모리 공간과 콘텍스트, 스택을 가진다.

따라서 한 프로그램에서 여러 개의 프로세스가 생성될지라도 서로 영향을 주지 않고 개별적으로 동작할 수 있다. 

이처럼 여러 개의 프로세스를 동시에 수행하는 것을<br>**멀티프로그래밍(*Multiprogramming*)** 또는 **멀티태스킹(*Multitasking*)** 이라고 한다.

<hr>

프로세스의 내부에는 실제 프로세서를 할당받아 코드를 실행하는 실행 단위가 존재한다.

**프로세스에 존재하는 개별적인 실행 단위를 스레드(*Thread*)** 라고 하며,<br>프로세스가 메모리에 로드될 때 프로세스의 코드를 실행하는 스레드도 같이 생성된다.

이처럼 프로세스와 함께 생성되어 프로세스의 주인 역할을 하는 스레드를 메인 스레드라고 한다.

그렇다고 프로세스당 스레드가 하나만 있어야 하는 것이 아니라,<br>OS가 멀티태스킹 하는 것 처럼 프로세스 역시 내부에서 여러 개의 스레드를 생성하여 동시에 작업을 진행할 수 있으며, 이를 **멀티 스레딩이** 라고 한다.

![image](https://user-images.githubusercontent.com/34773827/61717428-001e4d00-ad9c-11e9-8456-73d961d3d840.png)

스레드는 앞서 설명한 것처럼 프로세서를 할당받아 코드를 수행할 수 있다.

하지만 스레드는 개별적인 메모리 공간을 할당받은 것이 아니라 콘텍스트와 스택을 제외한 나머지 영역을 프로세스와 공유한다.

<hr>

메모리를 프로세서와 공유하는 것은 스레드의 장점이자 단점이라 할 수 있다.<br>메모리를 공유해서 생기는 장점은 스레드 사이 데이터 전달이 빠르고 쉽다는 점이다.

프로세스의 경우 메모리 영역이 서로 분리되어 있으므로 프로세스 끼리 데이터를 전달하려면 공유할 특정 메모리 영역을 외부에 지정한 뒤에 작업을 해야 한다.

하지만 스레드는 프로세스의 내부 메모리 영역에 특정 부분을 할당하여 데이터를 편리하게 전달할 수 있다.

이러한 장점은 스레드의 단점이기도 하다.

어느 한 스레드에 문제가 생겨 프로세스의 메모리 영역을 파괴하면 프로세스 전체에 영향을 미친다.

프로세서는 메모리 영역이 독립되어 있어서 특정 프로세에 문제가 생기더라도 다른 프로세스에 미치는 영향이 적다.

하지만 스레드는 메모리 영역을 공유하므로<br>잘못된 부분을 참조하는 스레드는 프로세스 내의 모든 스레드에 영향을 마친다.

위 그림으로 프로그램, 프로세스, 스레드의 관계를 알 수 있다.

그림의 메인 스레드는 프로세스가 생성될 때 함께 생성되는 스레드로 프로세스 초기화나 코드 실행,<br>다른 서브스레드를 관리한다.

서브 스레드는 프로세스의 코드 중에서 처리하는데 시간이 오래 걸리거나 특정 작업을 반복해야 할 때 생성하며, 메인 스레드의 부하를 줄이고 작업을 효율적으로 처리할 목적으로 사용한다.

<hr>



## 프로세스 종료 처리화 동기화 문제

메인 스레드는 프로세스와 밀접한 관계가 있으며,<br>프로세스의 종료는 곧 메인 스레드의 종료를 의미한다.

OS는 메인 스레드를 종료한 후 프로세스가 사용했던 메모리 공간을 다른 프로세스에서 사용할 수 있게 해제한다.

이러한 과정은 단일 스레드로 동작하는 프로세스에는 별 문제가 없지만 멀티스레드로 동작하는 프로세스에는 치명적인 문제가 발생한다.

<hr>

스레드는 개별적인 메모리 공간을 할당받지 않고 프로세스와 공유한다.

그런데 서브 스레드가 동작하는 동안 메인 스레드가 종료되면 프로세스의 메모리 공간이 사라지므로 서브스레드에 여러 가지 문제가 생긴다.

만약 서브스레드가 해제된프로세스 메모리 영역에서 동작하던 중 예외가 발생한다면 그나마 다행이지만,<br>이보다 더 심각한 상황은 해제된 메모리가 다른 프로세스에게 할당되어 새로운 코드와 데이터로 덮어 씌워졌는데, 스레드가 종료되지 않고 변경된 코드를 계속 실행하는 것이다.

이는 예측할 수 없는 결과를 초래할 뿐 아니라, 나중에 문제의 원인을 분석하기도 어렵다.

따라서 메인 스레드는 프로세스 내에 존재하는 다른 스레드가 종료될 때 까지 무조건 대기해야 한다.

<hr>

동기화의 관점에서 보면 멀티스레딩의 동기화 처리는 오히려 멀티프로그램이나 멀티태스킹보다 더 중요하다.

왜냐하면 스레드는 프로세스의 전체 영역을 공유하므로 메모리 영역이 구분된 프로세스보다 동기화 문제가 발생할 확률이 더 높기 때문이다.

공유된 메모리에 열 개의 스레드가 접근하면 해당 메모리에 접근하는 코드가 임계 영역이 되며,<br>이를 보호하지 않는 한 동기화 문제가 생긴다.

그러므로 멀티스레드 환경에서도 멀티태스킹에서 적용했던 것처럼 동기화 처리를 해야 한다.

동기화 처리에 쓰이는 동기화 객체는 태스크의 타입(프로세스나 스레드)에 관계 없이 공용으로 사용할 수 있으므로 동기화가 필요한 곳에 삽입하면 된다.

