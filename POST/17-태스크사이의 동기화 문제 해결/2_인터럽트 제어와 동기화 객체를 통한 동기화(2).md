## 인터럽트 제어와 동기화 객체를 통한 동기화



## 태스크 사이 자료 공유를 위한 동기화 객체 설계와 구현

태스크와 태스크 사이의 동기화 처리에 사용하는 대표적인 기법은 **뮤텍스(*Mutex*)** 와 **세마포어(*Semaphore*)** 이다.

**뮤텍스** 는<br>상호 배제의 약자로 임계 영역에 하나의 태스크만 진입할 수 있도록 보장하는 동기화 객체이다.

**세마포어** 는<br>자원 사용 여부를 깃발로 표시하는 것에서 유래된 것으로,<br>정해진 수의 태스크가 동시에 임계 영역에 진입할 수 있다.

<hr>

뮤텍스와 세마포어의 공통점은<br> 둘 다 **임계 영역에 진입하는 태스크의 수나 자원을 사용하는 태스크의 수를 제한하는데 사용** 된다는 것이다.

하지만 뮤텍스와 세마포어는 다음과 같은 차이점이 있기 때문에 구분해서 사용해야 한다.

![image](https://user-images.githubusercontent.com/34773827/61620671-46947e80-acac-11e9-8517-ba73a41b6a23.png)

뮤텍스와 세마포어의 가장 큰 차이점은<br>**동기화 객체가 잠금을 수행한 태스크에 소유되는가 하는 것이다.**

뮤텍스는<br>잠금을 수행하는 순간 **해당 태스크에 종속 되어,** 나머지 태스크는 잠긴 뮤텍스를 해제할 수 없다.

또한 뮤텍스를 같은 태스크가 중복으로 잠금을 수행하면 실제로 잠금 작업을 하는 것이 아니라<br>잠금 횟수만 증가시키며, 해제 시 횟수를 참고하여 횟수가 0이 되었을 때 실제로 해제 작업을 수행한다.

<hr>

함수의 호출관계가 복잡하지 않다면 뮤텍스와 세마포어중 어느 것을 사용해도 괜찮다.

하지만 대부분의 데이터와 자원이 하나의 태스크만 접근할 수 있으며,<br>코드가 복잡해지면 의도하지 않은 중복 잠금 및 해제도 발생하므로<br>이러한 처리가 모두 고려된 뮤텍스를 구현하도록 하자.

> 세마포어 역시 뮤텍스와 구조가 거의 비슷하므로 뮤텍스 코드를 조금만 수정하면 세마포어도 쉽게 구현할 수 있다.

<hr>

태스크와 태스크 사이의 동기화 처리도 앞의 태스크와 인터럽트 핸들러 간의 동기화 처리에 연장이므로,<br>앞서 구현했던 *kLoadForSystem( )* 함수와 *kUnlockForSystem( )* 함수를 사용할 수 있다.

하지만 태스크에서만 사용하는 데이터는 인터럽트 핸들러에서 사용하지 않으므로,<br>굳이 인터럽트를 불가능하게 설정하여 인터럽트 처리를 지연시킬 필요는 없다.

**우리가 뮤텍스를 사용하는 근본적인 목적은 임계 영역에 진입하는 태스크의 수를 제한하는 것이다.**

태스크의 수를 제한하려면 임계 영역 진입 여부를 나타내는 플래그와 잠금 횟수를 나타내는 카운터,<br>그리고 임계 영역에 진입한 태스크의 ID만 있으면 처리할 수 있다.

#### 뮤텍스 자료구조의 코드

```c
typedef struct kMutexStruct
{
    // 태스크 ID와 잠금을 수행한 횟수
    volatile QWORD qwTaskID;
    volatile DWORD dwLockCount;
    
    // 잠금 플래그
    volatile BOOL bLockFlag;
    
    // 자료구조의 크기를 8바이트 단위로 맞추려고 추가한 필드
    BYTE vbPadding[3];
}MUTEX;
```

> **volatile 변수**
>
> volatile 변수와 일반 변수의 차이점은<br>변수 참조가 일어날 때마다 매번 메모리에 접근하는지 여부이다.
>
> 변수는 메모리에 위치하기 때문에 접근할 때마다 메모리에서 값을 참조할 것 같지만 실제로는 그렇지 않다.
>
> 메모리에서 값을 읽고 쓰는 시간은 프로세서가 연산을 수행하는 시간보다 훨씬 오래 걸리므로,<br>메모리에 접근할 때마다 처리가 지연된다.
>
> 따라서 컴파일러의 입장에서는 성능 향상을 위해 메모리 접근을 최소화하고 불필요한 접근을 줄이려고 한다.
>
> 이러한 과정을 코드 최적화 라고한다.
>
> 코드를 최적화하면 자주사용되는 변수는 메모리에 저장되는 것이 아니라 레지스터에 저장되며,<br>작업이 완료되면 그제서야 메모리로 옮겨준다.
>
> 동기화 오브젝트에 쓰이는 자료구조들은 여러 태스크가 공유하므로 변경된 값이 즉시 반영되어야 하기 때문에 레지스터가 아닌 메모리를 매번 참조해야 한다.
>
> volatile 키워드는 최적화 과정에서 해당 변수를 최적화 대상에서 제외하여 메모리를 직접 참조하도록 한다.

뮤텍스 자료구조는 스케줄러 자료구조와 같이 동기화가 필요한 다른 자료구조에서 사용될 수 있다.

특정 자료구조는 내부의 필드가 8바이트 또는 16바이트로 정렬 되어야 하므로,<br>이를 위해 패딩 영역을 추가하여 자료구조의 크기를 강제로 8바이트 배수로 맞춘다.

<hr>

#### 뮤텍스 초기화 함수의 코드

뮤텍스 함수는 시스템 전역 데이터용 동기화 함수와 달리,<br>뮤텍스 자료구조를 사용하므로 초기화 함수부터 작성한다.

뮤텍스의 초기 상태는 잠기지 않은 상태이므로 잠김 플래그는 FALSE로 설정하고 잠김 횟수는 0,<br>태스크 ID는 유효하지 않은 TASK_INVALIDID(0xFFFFFFFFFFFFFFFF)로 설정한다.

```c
void kInitializeMutex(MUTEX* pstMutex)
{
    // 잠김 플래그와 횟수, 그리고 태스크 ID를 초기화
    pstMutex->bLockFlag = FALSE;
    pstMutex->dwLockCount = 0;
    pstMutex->qwTaskID = TASK_INVALIDID;
}
```

<hr>

#### 뮤텍스 잠금 함수와 해제 함수

**잠금 함수** 는 중복 잠금을 허락하는 뮤텍스의 특성 때문에 <br>먼저 이전에 잠금을 수행한 태스크와 현재 태스크를 비교한다.

만일 뮤텍스가 잠겨 있는 상태에서 다시 잠금을 수행했다면,<br>이전에 잠금을 수행한 태스크일 경우 잠금 횟수를 증가시키고<br>잠금을 수행한 태스크가 아닐 경우 잠금이 해제될 때 까지 대기한다.

그렇지 않고 잠금을 수행했을 때 뮤텍스가 해제된 상태라면<br>플래그, 태스크 ID, 카운터를 변경하여 뮤텍스를 잠긴 상태로 만든다.

**해제 함수** 역시 잠금 함수와 흐름이 거의 같다.

해제 함수는 먼저 뮤텍스가 잠긴 상태이고 뮤텍스를 잠근 태스크가 해제를 요청한 것인지 확인한다.<br>만약 잠근 태스크가 해제를 요청하는 것이라면 잠긴 횟수가 2이상이면 중복으로 잠긴 것이므로<br>횟수만 1 감소시키고 실제로 해제하는 작업은 수행하지 않는다.

그렇지 않고 잠금 횟수가 1이면 뮤텍스를 해제된 상태로 변경한다.

```c
// 태스크 사이에서 사용하는 데이터를 위한 잠금 함수
void kLock(MUTEX* pstMutex)
{
    // 이미 잠겨 있다면 내가 잠궜는지 확인하여, 그렇다면 잠긴 횟수를 증가시키고 종료
    if(pstMutex->bLockFlag == TRUE)
    {
        // 자신이 잠갔다면 횟수만 증가시킨다.
        if(pstMutex->qwTaskID == kGetRunningTask()->stLink.qwID)
        {
            pstMutex->dwLockCount++;
            return;
        }
        
        // 자신이 아닌 경우는 잠긴 것이 해제될 때 까지 대기
        while(pstMutex->bLockFlag == TRUE)
        {
            kSchedule();
        }
    }
    
    // 잠김 설정
    pstMutex->dwLockCount = 1;
    pstMutex->bLockFlag = TRUE;
    pstMutex->qwTaskID = kGetRunningTask()->stLink.qwID;
}

// 태스크 사이에서 사용하는 데이터를 위한 잠금 해제 함수
void Unlock(MUTEX* pstMutex)
{
    // 뮤텍스를 잠근 태스크가 아니면 실패
    if((pstMutex->bLockFlag == FALSE) ||
      (pstMutex->qwTaskID != kGetRunningTask()->stLink.qwID))
    {
        return;
    }
    
    // 뮤텍스를 중복으로 잠갔으면 잠긴 횟수만 감소
    if(pstMutex->dwLockCount > 1)
    {
        pstMutex->dwLockCount--;
        return;
    }
    
    // 해제된 것으로 설정, 잠긴 플래그를 가장 나중에 해제해야 한다.
    pstMutex->qwTaskID = TASK_INVALIDID;
    pstMutex->dwLockCount = 0;
    pstMutex->bLockFlag = FALSE;
}
```

위 코드를 살펴보면 이상한 점이 있다.

태스크 사이의 동기화를 위해 *kLock( )* 함수와 *kUnlock( )* 함수를 구현했는데<br>*kLock( )* 함수와 *kUnlock( )* 함수를 구현했는데 *kLock( )* 함수에도 동기화 처리가 필요하다는 것이다.

위의 코드를 보면 잠긴 함수의 *while( )* 루프에서 뮤텍스가 해제되었음을 확인한 후<br>bLockFlag에 TRUE를 설정하여 뮤텍스를 잠금 상태로 만든다.

이때 bLockFlag를 TRUE로 설정하지 못하고 PIT 인터럽트에 의해 다른 태스크로 전환되었다면,<br>다시 본래의 태스크가 실행되었을 때 뮤텍스가 해제된 상태라고 확신할 수 없다.

<hr>

이러한 문제가 발생하는 이유는<br>**잠금 상태를 판단하고 설정하는 과정이 하나의 명령어(*Atomic Operation*)으로 처리되지 않았기 때문이다.**

즉, **여러 개의 명령어로 테스트와 설정을 처리하기 때문에 중간에 인터럽트가 끼어들 수 있는 것이다.**

만일 테스트와 설정 과정을 하나의 명령어로 처리할 수 있다면 문제는 사라질 것이며,<br>이때 사용하는 것이 바로 **LOCK** 명령어와 **CMPXCHG** (Compare And Exchange) 명령어이다.

<hr>
LOCK 명령어는 어셈블리어 코드에서 전치사로 사용되며,<BR>뒤에 따라오는 명령어 수행 동안 시스템 버스를 잠그고 다른 프로세서나 코어가 메모리에 접근할 수 없게한다.

CMPXCHG 명령어는 "CMPXCHG A, B"와 같이 두 개의 오퍼랜드가 필요하며,<BR>AX 레지스터의 값과 오퍼랜드 A를 비교한 결과에 따라 두가지 방식으로 동작한다.

만약 AX 레지스터와 오퍼랜드 A의 값이 일치한다면,<BR>RFLAGS 레지스터의 ZF 비트를 1로 설정하고 오퍼랜드 A에 오퍼랜드 B의 값을 대입한다.

하지만 AX 레지스터의 값과 오퍼랜드 A의 값이 다르다면 RFLAGS 레지스터의 ZF 비트를 0으로 설정하고<BR>오퍼랜드 A의 값을 AX 레지스터로 옮겨준다.

CMPXCHG 명령어는 두 값을 비교하고 그 결과에 따라 값을 대입하는 작업을 한 번에 처리하므로,<BR>이를 이용하면 테스트와 설정 과정을 태스크 전환 없이 처리할 수 있다.

> 싱글코어 프로세서 환경이나 멀티코어 프로세서 환경이라도 다른 코어가 활성화 되지 않은 상태에서는 LOCK 명령어가 필요하지 않다.
>
> 하지만 나중에 프로세서에 존재하는 코어를 모두 활성화하므로 미리 LOCK 명령어를 추가하였다.
>
> CMPXCHG 명령어가 하나의 명령어지만 실제로는 메모리에 접근하여 비교하고 대입하는 여러 단계를 거치므로, 이 과정에서 다른 코어가 메모리에 접근하여 값을 바꿀 수 있다.
>
> LOCK 명령어를 사용하면 CMPXCHG 명령어를 수행하는 동안 다른 코어가 메모리에 접근할 수 없어,<BR> 코어간의 동기화 문제도 해결할 수 있다.

<hr>

뮤텍스를 잠그는 함수에서 필요한 기능은 잠긴 필드가 FALSE(0)일 때 TRUE(1)로 설정하는 것이다.

따라서 AX 레지스터를 0으로 설정하고 오퍼랜드 B에 1을 설정한 후 오퍼랜드 A에 잠김 필드의 어드레스를 지정해주면 된다.

만일 잠김 필드가 0이라면 AX 레지스터의 값이 0이므로 CMPXCHG의 결과는 ZF 비트가 1로 설정되고 잠김 필드에는 오퍼랜드 B의 값인 1이 설정될 것이다.

그 반대로 잠김 필드가 1이라면 CMPCHG의 결과는 ZF 비트가 0으로 설정되고 AX 레지스터에 오퍼랜드 A의 값인 1이 설정될 것이므로, ZF 비트에 따라 성공 유무를 판단할 수 있다.

<hr>

#### 태스트와 설정을 한 번에 처리하는 어셈블리어 함수의 코드

다음은 오퍼랜드 A(AX 레지스터와 값을 비교하여 오퍼랜드 B의 값을 대입할 어드레스)와 AX 레지스터(오퍼랜드 A와 비교할 값), 그리고 오퍼랜드 B(오퍼랜드 A에 설정할 값)를 파라미터로 넘겨받아 CMPCHG를 수행하는 어셈블리어 함수이다.

```assembly
// 정의
BOOL kTestAndSet(volatile BYTE* pbDestinatioin, BYTE bCompare, BYTE bSource);

; 태스트와 설정을 하나의 명령으로 처리
;		Destination과 Compare를 비교하여 같다면 Destination에 Source 값을 삽입
;	PARAM: 값을 저장할 어드레스(Destination, rdi),  비교할 값(Compare, rsi)
;		설정할 값(Source, rdx)
kTestAndSet:
	mov rax, rsi		; 두 번째 파라미터인 비교할 값을 RAX 레지스터에 저장
	
	; RAX 레지스터에 저장된 비교할 값과 첫 번째 파라미터의 메모리 어드레스의 값을 비교하여
	; 두 값이 같다면 세 번째 파라미터의 값을 첫 번째 파라미터가 가리키는 어드레스에 삽입
	lock cmpxchg byte [rdi], dl
	je .SUCCESS		; ZF 비트가 1이면 같다는 뜻이므로 .SUCCESS로 이동
	
.NOTSAME:		; Destination 과 Compare가 다른 경우
	mov rax, 0x00
	ret
	
.SUCCESS:		; Destination과 Compare가 같은 경우
	mov rax, 0x01
	ret	
```

<hr>

#### *kTestAndSet( )* 함수를 사용하도록 수정된 뮤텍스 잠금 함수와 해제 함수의 코드

*kTestAndSet( )* 함수가 구현되었으니 함수를 *kLock( )* 함수와 *kUnlock( )* 함수의 잠금 플래그 설정 부분에 적용하자.

다음은 동기화 문제가 발생하지 않도록 수정된 뮤텍스 잠금 함수와 해제함수 코드이다.

```c
// 태스크 사이에서 사용하는 데이터를 위한 잠금 함수
void kLock(MUTEX* pstMutex)
{
  	// 이미 잠겨 있다면 내가 잠갔는지 확인하고 잠근 횟수를 증가시킨 뒤 종료
    if(kTestAndSet(&(pstMutex->bLockFlag),0,1) == FALSE)
    {
        // 자신이 잠갔다면 횟수만 증가시킨다.
        if(pstMutex->qwTaskID == kGetRunningTask()->stLink.qwID)
        {
            pstMutex->dwLockCount++;
            return;
        }
        
        // 자신이 아닌 경우는 잠긴 것이 해제될 때까지 대기
        while(kTestAndSet(&(pstMutex->bLockFlag),0,1) == FALSE)
        {
            kSchedule();
        }
    }
    
    // 잠금 설정, 잠금 플래그는 위의 kTestAndSet() 함수에서 처리
    pstMutex->dwLockCount = 1;
    pstMutex->qwTaskID = kGetRunningTask()->stLink.qwID;    
}

// 태스크 사이에서 사용하는 데이터를 위한 잠금해제 함수
void kUnlock(MUTEX* pstMutex)
{
    // 뮤텍스를 잠근 태스크가 아니면 실패
    if((pstMutex->bLockFlag == FALSE)||
      (pstMutex->qwTaskID != kGetRunningTask()->stLink.qwID))
    {
        return;
    }
    
    // 뮤텍스를 중복으로 잠갔으면 잠긴 횟수만 감소
    if(pstMutex->dwLockCount > 1)
    {
        pstMutex->dwLockCount--;
        return;
    }
    
    // 해제된 것으로 설정, 잠김 플래그를 가장 나중에 해제해야 한다.
    pstMutex->qwTaskID = TASK_INVALIDID;
    pstMutex->dwLockCount = 0;
    pstMutex->bLockFlag = FALSE;
}
```

<HR>

## 태스크 사이 자료 공유를 위한 동기화 함수 적용

스케줄러에 관련된 루틴을 제외하고 다른 부분은 동기화 문제가 없어 보이지만,<br>사실은 멀티태스킹 ㅗ한경에서 사용될 때 예상치 못한 결과가 나타나는 함수가 있다.

화면에 다양한 포맷으로 결과를 출력해주는 *kPrintf( )* 가 바로 그 함수이다.

*kPrintf( )* 함수는 포맷 스트링에 따라 버퍼를 구성하고,<br>화면 내의 커서 위치에 따라 개행 처리와 스크롤 처리까지 수행하는 아주 덩치 큰 함수이다.

덩치가 크다보니 함수를 처음부터 끝까지 수행하는데 걸리는 시간도 상대적으로 다른 함수보다 오래 걸려서 수행하는 중간에 태스크 전환이 발생할 확률도 높다.

만일 여러 개의 태스크가 화면에 메시지를 출력한다면,<br>화면 내의 커서 위치를 나타내는 필드를 서로 먼저 사용하려고 경쟁할 것이다.

이때 한 태스크가 메시지를 출력한 후 커서 위치 필드를 갱신하기 전에 다른 태스크로 전환되고,<br>다른 태스크도 역시 화면에 메시지를 출력한다면 메시지가 정상적으로 출력되지 않거나 출력된 자리에 다른 메시지가 덮어써질 수도 있다.

#### 공용 변수의 값을 출력하는 테스트용 태스크

변수 하나를 공유하면서 화면에 증가된 숫자를 출력하는 간단한 테스트용 태스크를 만들어보자.

다음은 공용 변수의 값을 1씩 다섯 번 증가시키며 자신의 ID와 그 당시 공용 변수의 값을 출력하는 태스크의 코드이다.

태스크의 시작과 동시에 50ms 정도를 대기하여 콘솔 셸에서 출력하는 메시지와 태스크가 출력하는 메시지가 동시에 출력되지 않도록 하며 태스크를 종료하면 유휴 태스크가 종료한 태스크의 정보를 출력하므로,<br>수행 중인 태스크의 메시지와 겹치지 않도록 1초(1000ms) 정도 대기한 후 태스크를 종료하도록 한다.

이렇게 하면 숫자를 출력하는 메시지는 순수하게 테스트용 태스크끼리 경쟁해서 나온 결과가 된다.

```c
// 공용 변수
static volatile QWORD gs_qwAdder = 1;

// 숫자를 출력하는 태스크
static void kPrintNumberTask(void)
{
    int i;
    int j;
    QWORD qwTickCount;
    
    // 50ms 정도 대기하여 콘솔 셸이 출력하는 메시지와 겹치지 않도록 한다.
    qwTickCount = kGetTickCount();
    while((kGetTickCount() - qwTickCount) < 50)
    {
        kSchedule();
    }
    
    // 루프를 돌면서 숫자를 출력
    for(i = 0 ; i < 5 ; i++)
    {
        kPrintf("Task ID [0x%Q] Value[%d]\n", kGetRunningTask()->stLink.qwID,gs_qwAdder);
        
        gs_qwAdder += 1;
        
        // 프로세서 소모를 늘리려고 추가한 코드
        for(j = 0 ; j < 30000 ; j++);
    }
    
    // 모든 태스크가 종료할 때까지 1초(1000ms) 정도 대기
    qwTickCount = kGetTickCount();
    while((kGetTickCount() - qwTickCount) < 1000)
    {
        kSchedule();
    }
    
    // 태스크 종료
    kExitTask();
}
```

위 태스크는 1씩 다섯 번 숫자를 증가시키면서 화면에 출력하므로 태스크 세 개를 *kCreatetask( )* 함수로 생성하면 1부터 15까지 차례로 화면에 출력되어야 한다.

실제 실행 결과도 숫자가 차례로 1씩 증가하면서 1 ~ 15까지 정상적으로 출력되지 않고<br>숫자가 연속적이지 않을 뿐 아니라 출력된 메시지의 수도 15개보다 적은 경우도 나타난다.

<hr>

#### 동기화를 적용한 테스트용 태스크

kPrintNumberTask 태스크는 사실상 두 가지 변수를 공유하고 있다.

하나는 *kPrintf( )* 함수에서 사용하는 커서 위치 값이고, 다른 하나는 숫자를 연속적으로 출력할 목적으로 사용하는  gs_qwAdder 변수이다. 

숫자를 완벽하게 연속적으로 출력하기를 원한다면 공유된 두 변수 모두 동기화 처리를 해야 한다.

따라서 *kPrintf( )* 함수와 gs_qwAdder 변수를 사용하는 부분을 뮤텍스로 처리하면 우리가 원하는 결과를 얻을 수 있다.

뮤텍스의 초기화는 태스크를 생성하기 이전에 해야 하므로 *kPrintNumberTask( )* 함수를 생성하는 곳에 있다.

```c
// 뮤텍스 정의
static MUTEX gs_stMutex;

// 숫자를 출력하는 태스크
static void kPrintNumberTask(void)
{
    ... 생략 ...
    // 루프를 돌면서 숫자를 출력
    for(i = 0 ; i < 5 ; i++)
    {
        // 임계 영역 시작
        kLock(&(gs_stMutex));
        kPrintf("Task ID[0x%Q] Value[%d]\n",kGetRunningTask()->stLink.qwID,gs_qwAdder);
        
        gs_qwAdder += 1;
        // 임계 영역 끝
        kUnlock(&(gs_stMutex));
        
        // 프로세서 소모를 늘리려고 추가한 코드
        for(j = 0 ; j < 30000 ; j++);
    }
    ... 생략 ...
}
```

<hr>



## 교착 상태

동기화 객체하면 빠지지 않고 나오는 것이 **교착상태 (*DeadLock*)** 문제이다.

교착 상태란 서로 다른 태스크가 두 개 이상의 동기화 객체를 획득할 때 발생하는 문제로,<br>어느 태스크도 더 이상 작업을 진행할 수 없는 상태를 말한다.

<hr>

그림처럼 태스크 1과 2가 동기화 객체 A와 B를 동시에 획득하려 할 때 그림과 같다면 교착상태가 발생할 수 있다.

![image](https://user-images.githubusercontent.com/34773827/61649155-dd346000-aceb-11e9-9cd6-1c53ae5528cb.png)

그림을 보면 태스크 1과 태스크 2 모두 동기화 객체 A와 B를 획득해야 작업을 마무리할 수 있다.

대부분 동기화 객체가 한 번에 획득되기 때문에 문제가 없지만,<br>위 그림과 같이 하나만 획득한 상태에서 다른 태스크로 전환되면 문제가 생긴다.

태스크 1에서 동기화 객체 A를 획득한 후 태스크 2가 수행되면, <br>태스크 2는 동기화 객체 B를 획득하고 다시 동기화 객체 A를 획득하려 할 것이다.

그런데 이미 동기화 객체 A는 태스크 1에서 잠근 상태이므로 태스크 2는 동기화  객체 A가 해제되길 기다리면서 태스크 1을 실행할 것이다.

다시 태스크 1이 실행되면 태스크 1은 나머지 동기화 객체 B를 확인하는데,<br>동기화 객체 B는 이전에 수행되었던 태스크 2가 잠근 상태이므로 역시 해제 되길 기다리면서 태스크 2를 실행한다.

이 상태에서는 아무리 태스크 전환이 발생해도 더 이상 작업을 진행할 수 없으며, 이것을 교착 상태라 부른다.

<hr>

이러한 교착상태를 피하려면 동기화 객체를 꼭 필요한 영역에서만 사용하는 것이 좋다.

그리고 부득히 하게 여러 동기화 객체를 획득해야 한다면 교착상태가 발생하지 않도록 동기화 객체의 획득 순서를 정하여 차례로 사용하는 것이 좋다.

