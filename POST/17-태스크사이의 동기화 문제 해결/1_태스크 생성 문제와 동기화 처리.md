# 태스크 생성 문제와 동기화 처리



## 사라진 태스크

태스크를 생성하는 과정에서 간혹 태스크가 사라지는 이유는<br>스케줄러의 준비 리스트에 태스크를 추가하는 *kCreateTask( )* 함수와 PIT 인터럽트에 맞춰 태스크를 스케줄링하는 *kScheduleInInterrupt( )* 에서 찾을 수 있다.

태스크를 추가하는 함수와 스케줄링하는 함수의 공통점은 **준비 큐(Ready Queue)** 를 사용한다는 것이며,<br>더욱 중요한 부분은 **준비 리스트의 마지막에 태스크를 연결한다는 것** 이다.

호출하는 함수의 관점에서 보면 두 함수는 공통적으로 *kAddTaskToReadyList( )* 함수를 사용하며,<br>이 함수는 최종적으로 *kAddListToTail( )* 함수를 호출하여 리스트의 마지막에 데이터를 추가한다.

리스트의 마지막에 데이터를 추가하는 작업은 한 번에 이루어지지 않는다.

<hr>

#### 리스트의 마지막에 데이터를 추가하는 코드

다음코드에서 볼 수 있듯이 리스트의 상태에 따라 두 부분으로 나누어 처리하며,<br>리스트의 첫 번째 데이터와 마지막 데이터, 리스트에 있는 아이템의 수를 순차적으로 수정한다.

```c
void kAddListToTail(LIST* pstList, void* pvItem)
{
    LISTLINK* pstLink;
    
    // 다음 데이터의 어드레스를 없음(NULL)로 설정
    pstLink = (LISTLINK*)pvItem;
    pstLink->pvNext = NULL;
    
    // 리스트가 빈 상태면 Header와 Tail을 추가한 데이터로 설정
    if(pstList->pvHeader == NULL)
    {
        pstList->pvHeader = pvItem;
        pstList->pvTail = pvItem;
        pstList->iItemCount = 1;
        return;
    }
    
    // 마지막 데이터의  LISTLINK의 위치를 구하여 다음 데이터를 추가한 데이터로 설정
    pstLink = (LISTLINK*)pstList->pvTail;
    pstLink->pvNext = pvItem;
    
    // 리스트의 마지막 데이터를 추가한 데이터로 변경
    pstList->pvTail = pvItem;
    pstList->iItemCount++;
}
```

<hr>

비어있는 리스트에 데이터를 삽입하는 경우와 데이터가 존재하는 리스트의 마지막에 데이터를 삽입하는 경우가 거의 같은 방식으로 수행되므로 모두 문제가 있다.

#### 준비 리스트에 두 개 이상의 태스크가 존재하는 상황

우선 순위가 같은 태스크 B와 태스크 C가 준비 리스트에서 대기하는 상태에서, <br>태스크 A가 태스크 D를 생성하는 경우를 가정해보자.

만약 태스크 A가 태스크 D를 생성하는 도중 인터럽트가 발생하여 다른 태스크로 전환되었다가 수행된다면<br>코드의 흐름은 다음 그림과 같을 것이다.

![image](https://user-images.githubusercontent.com/34773827/61595500-f200ed00-ac32-11e9-9bc5-cc3efe57c001.png)



그림에서 처럼 태스크 A가 1번 코드 블록을 실행 완료했을 때,<br>인터럽트가 발생하여 인터럽트 핸들러코드(2번)가 수행된다면?

태스크가 리스트에 마지막에 완전히 연결되려면 리스트의 Tail 정보에 태스크 D를 업데이트(3번 코드)해야 한다.

하지만 태스크 A는 1번코드 까지만 수행하고 Tail 정보를 갱신하는 3번 코드 블록을 수행하지 못했으므로<br>PIT 인터럽트의 핸들러가 실행되면 태스크 D의 연결 고리가 리스트에서 끊어진다.

그리고 시간이 지나고 다시 태스크 A로 전환되었을 때 태스크 A는 태스크 D를 Tail에 연결하는 나머지 작업(3번)을 수행하므로 Tail 정보가 태스크 D로 설정된다.

![image](https://user-images.githubusercontent.com/34773827/61595690-4f963900-ac35-11e9-8e4f-fcc8363ec80d.png)

이처럼 인터럽트 핸들러 때문에 태스크 D의 연결 고리가 끊어진 상태에서 Tail 정보가 태스크 D로 연결되어 이후에 생성되는 태스크가 사라지게 된다.

스케줄러는 다음 데이터의 어드레스를 따라가며 태스크를 선택하므로,<br>이러한 상황은 해당 리스트의 태스크 전체가 사라지는 문제가 발생할 수 있다.

<hr>

위의 내용들로 미루어 보아 삽입한 태스크가 사라지지 않게 하려면<br>**태스크가 리스트에 작업 완료까지 인터럽트가 발생하여 리스트에 접근하는 것을 막아야 함을 알수있다.**

만약 두 태스크가 서로 데이터를 주고받는 용도로 리스트를 공유한다면 태스크 사이에도 같은 문제가 발생할 수 있다. 따라서 여러 경우를 고려해 동기화 문제를 해결할 수 있는 가장 효율적인 방법을 찾아야 한다.

<hr>



## 경쟁 상태와 임계 영역, 상호 배제

태스크와 태스크 사이 또는 태스크와 인터럽트 간의 동기화는 멀티태스킹 기법을 사용한다면 피할 수 없는 문제이다.

멀티태스킹 기법이 복잡해질수록 태스크나 인터럽트 간의 동기화 기법 역시 복잡해지며,<br>태스크를 효율적으로 스케줄링하는 것과 마찬가지로 동기화를 효율적으로 처리하는 것 역시 중요하다.

OS이론에서 **여러 태스크가 서로 자원을 획득하려는 상황을** **경쟁 상태(*Race Condition*)** 라는 용어를 사용하며,

**코드 중에서 반드시 한 개의 태스크만 수행되어야 하는 영역을 임계역역(*Critical Section*)** 이라고 한다.

그리고 **한 개의 태스크만이 코드를 수행하는 것을 보장한다는 의미로 상호 배제(*Mutual Exclusion*)** 라는 용어를 사용한다.

<hr>

위 용어에 따라 앞에 발생했던 문제를 다시 살펴보자.

태스크와 인터럽트가 서로 경쟁상태에 있으며, 임계역역을 포함하는 *kAddListToTail( )* 함수를 호출하여 작업한다.

임계역역은 상호 배제의 원칙에 따라 하나의 태스크만 수행되도록 보장해야 하지만,<br>현재 우리 OS 에서는 이러한 코드가 없기 때문에 동기화 문제가 발생한 것이다.

> 위 용어들은 뒤에서도 계속 나오니 정확히 정리해 두자.

<hr>



## 동기화 처리 방법

동기화를 수행한다는 말의 의미는,<br>**경쟁 상태에 있는 여러 태스크나 인터럽트로 부터 임계 영역을 보호 한다** 는 것과 같다.

임계영역을 보호하는 방법은 경쟁 상태에 있는 것이 무엇인지에 따라 차이가 난다.

만약 앞의 경우처럼 태스크와 인터럽트 간의 동기화를 수행해야 한다면,<br>태스크 전환을 수행하는 인터럽트를 비활성화 해야한다.

그렇지 않고 태스크 사이의 동기화 문제라면 임계 영역의 진입여부를 결정하는 자료구조가 있으면 처리가능하다.

<hr>

#### 태스크와 인터럽트 간의 동기화 문제

태스크와 인터럽트간의 동기화 문제를 처리하려면 문제의 원인인 인터럽트를 제어하면 된다.

싱글 코어 프로세서 환경에서 인터럽트를 비활성화하여 동기화를 수행하는 방법은 해결방법이 된다.<br>하지만 인터럽트가 비활성화된 구간이 길면 길수록 인터럽트 처리가 그만큼 지연되게 된다.

인터럽트는 외부 디바이스에서 전달하는 긴급한 신호이니 만큼 인터럽트 발생 불가능한 구간은 최대한 짧은 것이 좋다.

> 싱글코어 프로세서 환경에서는 코어가 하나밖에 없으므로 프로세서의 인터럽트만 비활성화하면<br>동기화를 수행하는데 별 문제가 없다.
>
> 하지만, 멀티코어 프로세서 환경에서는 코어의 개수와 같은 수의 태스크가 동시에 실행되며,<br>이는 인터럽트만으로 처리할 수 없다.
>
> 따라서 인터럽트가 발생할 수 없게 막는 것과 동시에 태스크 사이의 동기화도 함께 수행해야한다.

<hr>

#### 태스크 사이의 동기화 문제

태스크 사이의 동기화 문제를 해결하는 방법은 뮤텍스와 세마포어가 대표적이다.

뮤텍스는 앞에서 설명했던 상호 배제의 약자로<br>이름 그대로 임계영역에 단 하나의 태스크만 접근할 수 있도록 제어하는 동기화 객체이다.

세마포어 역시 뮤텍스와 비슷한 역할을 하지만<br>다른 점은 다수의 태스크가 동시에 자원을 사용할 수 있다는 것이다.

<hr>

지금까지 동기화를 처리하는 두 가지 방법,<br>즉 인터럽트를 제어하는 방법과 동기화 객체를 사용하는 방법에 대해서 알아보았다.



