# 어셈블리어

주로 사용되는 어셈블리어 명령어

| 그룹         |                  명령어                  | 설명                                                         |
| ------------ | :--------------------------------------: | ------------------------------------------------------------ |
| 사칙연산     |                 add A, B                 | A에 B의 값을 더한 후 A에 저장                                |
|              |                 sub A, B                 | A에서 B의 값을 뺀 후 A에 저장                                |
|              |                  mul A                   | AX의 레지스터 값과 A를 곱한 후,<br />AX 또는 DX:AX에 저장    |
|              |                  inc A                   | A의 값을 1 증가                                              |
|              |                  dec A                   | A의 값을 1 감소                                              |
|              |                  div A                   | AX나 DX:AX의 값을 A로 나누어 <br />목과 나머지를 각각 AL와 AH 또는 AX와 DX에 저장 |
| 논리연산     |                 and A, B                 | A에 B 값을 AND하여 A에 저장                                  |
|              |                 or A, B                  | A에 B 값을 OR하여 A에 저장                                   |
|              |                 xor A, B                 | A에 B 값을 XOR하여 A에 저장                                  |
|              |                  not A                   | A의 값을 반전 하여 A에 저장                                  |
| 대입 및 분기 |                 mov A, B                 | B에서 A로 값을 이동                                          |
|              |                 cmp A, B                 | 두 값을 비교하여 FLAGS 레지스터에 적용                       |
|              |                  jmp A                   | 무조건 해당 어드레스로 이동하여 A 위치의 코드를 실행         |
|              | je, ja, jb, jz<br />jne, jna, jnb, jnz A | - 조건 분기 명령으로 FLAGS 레지스터의 값에 따라 jmp 수행<br />- 일반적으로 값을 비교하는 cmp 명령어와 함께 사용<br />- Equal(e), Above(a), Bellow(b), Zero(z), Not(n) 등 다양한 조건 포함 |
| 함수 호출    |                  call A                  | - 스택에 call명령 다음 어드레스 삽입후 A 위치의 코드 실행<br />- 함수를 호출하는 용도로 사용 |
|              |                  ret A                   | - 스택을 A 만큼 줄인 후 되돌아갈 어드레스를 꺼내<br />해당 어드레스의 코드 실행<br />- 일반적으로 call 명령과 짝을 이루어 사용 |
| 스택         |                  push A                  | A의 값을 스택에 저장                                         |
|              |                  pop A                   | 스택에서 값을 꺼내 A에 저장                                  |
| 인터럽트     |                  int A                   | A번째 소프트웨어 인터럽트를 발생                             |
|              |                   cli                    | 인터럽트를 발생 불가능하도록 설정                            |
|              |                   sti                    | 인터럽트를 발생 가능하도록 설정                              |
| I/O 포트제어 |                 in A, B                  | - I/O 포트 B 에서 값을 입력 받아 A에 저장<br />- 주변 장치에서 값을 읽을 용도로 사용 |
|              |                 out B, A                 | - A의 값을 I/O 포트 B에 출력 <br />- 주변 장치에 값을 쓰는 용도로 사용 |

<hr>

### Assembly를 이용한 부트로더 소스 코드

```assembly
[ORG 0x00]
[BITS 16]

SECTION .text

jmp $

times 510 - ( $ - $$ )	db	0x00

db 0x55
db 0xAA
```

위의 각 부분은 다음과 같은 의미가 있다.

- **ORG 0x00** : 코드의 시작 어드레스를 0x00으로 설정
- **BITS 16** : 이하의 코드는 16비트 코드로 설정
- **SECTION .text** : text 섹션(세그먼트)을 정의
- **jmp $** : 현재 위치에서 무한 루프 수행, C 언어의 ``A: goto A ;`` 또는 ``while(1)``같은 역할
- **jmp** : jmp 명령 다음에 오는 어드레스로 무조건 이동, C언어의 goto 같은 역할
- **$** :  현재 라인의 어드레스를 의미
- **times 510 - ( $ - $$ )** : 현재 어드레스부터 어드레스가 510이 되는 시점까지 작업을 반복 수행
- **times** : times 명령 다음에 오는 횟수만큼 작업을 반복하라느 ㄴ의미
- **$$** : 현재 어드레스가 포함된 섹션의 시작 어드레스
- **db 0x00** : 현재 어드레스에 1바이트 크기의 0x00을 삽입하라는 의미 (Define Byte의 약자)
- **db** : 현재 어드레스에 값을 할당하고 저장
  - db(1byte), dw(2byte), dd(4byte), dq(8byte) 등이 있다.
- **db 0x55, db 0xAA** : 부트 로더임을 알리는 값

<hr>

### 어셈블리어에서 해당하는 메모리 값 참조 [ ]

어셈블리어에서 어드레스에 해당하는 메모리 값을 참조할 때 **[ ]** 기호를 사용한다.

기호 앞에 **byte, word (2Byte), dword (4Byte), qword (8Byte)** 를 사용하여 메모리 크기를 지정한다.

<  [ ] 기호와 mov 명령을 이용해서 0xB8000 와 0xB8001 어드레스에 값을 설정하는 코드 >

DS  세그먼트의 값은 0xB800이며,
0x00, 0x01 을 지정하면 세그먼트: 오프셋이 0xB800:0x0000, 0xB800:0x0001이 된다.
( 실제 물리 어드레스는 0xB8000, 0xB8001이 된다.)

```assembly
mov byte [ 0x00 ], 'M'		; DS 세그먼트 : 오프셋 0xB800:0x0000에 'M' 복사
mov byte [ 0x01 ], 0x4A		; DS 세그먼트 : 오프셋 0xB800:0x0001에 0x4A 복사
```

