# OS 이미지 로딩 기능 구현

## 스택 초기화 함수 구현

x86  프로세서에서 함수를 사용하려면 스택(Stack)이 꼭 필요하다.

> 스택은 데이터를 삽입하는 포인트와 제거하는 포인트가 같아서,
> 마지막에 들어간 데이터가 가장 먼저 나오는 형태의 자료구조이다.(LAST-IN,FIRST-OUT)

x86 프로세서에서는 함수를 호출한 코드의 다음 어드레스. 
즉, 되돌아갈 어드레스(Return Address)를 저장하는 용도로 스택을 사용한다.

**함수를 호출(Call) 하면 프로세서가 자동으로 되돌아올 어드레스를 스택에 저장**하며,
**호출된 함수에서 되돌아감(RET)을 요청하면 자동으로 스택에서 어드레스를 꺼내 호출한 다음 어드레스로 간다.**

또한, 스택은 **함수의 파라미터를 저장하는 역할도 겸한다.**

> 호출하는 쪽(Caller)와 호출되는 쪽(Callee)은 
> 정해진 규칙에 따라 파라미터를 스택에 저장함으로써 협업할 수 있다.



## 스택 생성

### 스택 관련 레지스터

x86 프로세서는 스택 관련 레지스터가 세 가지 있다.

- **스택 세그먼트 레지스터(SS)**

  스택 영역으로 사용할 세그먼트의 기준 주소를 지정

- **스택 포인터 레지스터(SP)**

  데이터를 삽입하고 제거하는 상위(TOP)를 지정

- **베이스 포인터 레지스터(BP)**

  스택의 기준 주소를 임시로 지정



16비트 모드는 세그먼테이션 방식으로 어드레스를 변환하므로,
 스택 세그먼트 레지스터를 사용해 최대 64KB(0x10000)를 스택 영역으로 지정할 수 있다.

> 스택 세그먼트 레지스터(SS)에 0x0000을 설정한다면,
> 사용 가능한 영역은 0x00000 ~ 0x0FFFF 범위가 되며,
> 0x1000을 설정한다면, 0x10000 ~ 0x1FFFF 범위가 된다.

스택 세그먼트 레지스터(SS)로 스택 세그먼트의 범위는 지정할 수 있지만,
실제 스택의 크기는 지정할 수 없다.

**스택의 실제 크기는 스택 포인터 레지스터(SP)와 베이스 포인터 레지스터(BP)의 초기값으로 지정한다.**

< 스택 세그먼트 레지스터(SS), 스택 포인터 레지스터(SP), 베이스 포인터 레지스터(BP)의 관계 >

![image](https://user-images.githubusercontent.com/34773827/60759184-dd7dfb80-a05b-11e9-8ea1-bf7a6bc18554.png)

> x86 프로세서에서의 스택은 그림과  같이
> 데이터가 삽입될 때마다 스택의 상위(Top)를 나타내는 스택 포인터 레지스터(SP)가 낮은 어드레스(0x00에 가까운 어드레스)로 이동한다.
>
> 따라서 두 레지스터의 초기값을 어떻게 설정하는 지에 따라 스택의 크기가 결정된다.

<hr>

### 부트로더에 스택을 생성

먼저 스택으로 사용할 영역을 결정해야 한다.

0x010000(64KB) 어드레스부터는 OS 이미지가 로딩(책에서)되므로, 0x010000이하,
즉 0x0000:0000 ~ 0x0000:FFFF 영역을 사용한다.

따라서 **스택 세그먼트 레지스터(SS)의 값을 0x0000**으로 설정하고,
스택은 넉넉한 것이 좋으므로 **스택 포인터 레지스터(SP)와 베이스 포인터 레지스터(BP)를 0xFFFE**로 설정하여,
스택 영역의 크기를 세그먼트의 최대 크기로 지정한다.

```assembly
; 스택을 0x0000:0000 ~ 0x0000:FFFF 영역에 64KB 크기로 생성한다.
mov ax, 0x0000	; 스택 세그먼트의 시작 어드레스(0x0000)를 세그먼트 레지스터 값으로 변환
mov ss, ax		; SS 세그먼트 레지스터에 설정
mov sp, 0xFFFE	; SP 레지스터의 어드레스를 0xFFFE로 설정
mov bp, 0xFFFE	; BP 레지스터의 어드레스를 0xFFFE로 설정
```

이렇게 스택 설정이 끝난다

x86 프로세서는 스택 작업을 처리하는 두 가지 명령  push, pop을 지원하며, 
각 명령은 스택에 데이터를 넣고 꺼낸다.

**Push** 명령은 
SP 레지스터가 가리키는 어드레스에 데이터를 저장하고 SP 레지스터를 감소시키며,

**Pop** 명령은
반대로 SP 레지스터를 증가시킨다.

> Push 와 Pop명령 대신,
> 데이터를 스택에 직접 복사하고 나서 SP 레지스터의 값을 변경하는 방법으로 같은 결과를 얻을 수 있다.

<hr>

### 화면 출력 함수

화면에서 원하는 위치에 문자열을 출력하려면 X 좌표, Y 좌표, 출력할 문자열 어드레스가 필요하다.
이 세 가지 함수를 파라미터로 정의하고 스택에 삽입하는 순서를 정해보자.

> 호출하는 쪽과 호출 되는 쪽에서 같은 순서로 스택에서 데이터를 꺼내기만 하면 정상적으로 처리할 수 있다.
>
> 하지만 C언어와의 연계를 고려한다면 중복 작업을 피할 수 있도록 C언어의 호출 규약(cdecl 방식)을 따르는 것이 좋다.
>
> C언어는 파라미터의 역순(오른쪽에서 왼쪽)으로 삽입하여 스택에서 꺼낸 순서가 파라미터 순서와 같게 한다.

#### 호출하는 쪽 (Caller)

< C언어와 어셈블리어의 함수 호출 비교 >

```c
PrintMessage(iX, iY, pcString);
```

```Assembly
push word [ pcString ]	; 문자열의 어드레스를 스택에 삽입
push word [ iY ]		; 화면의 Y조표를 스택에 삽입
push word [ iX ]		; 화면의 X좌표를 스택에 삽입
call PRINTMESSAGE		; PRINTMESSAGE 함수 호출
add sp, 6				; 스택에 삽입된 함수 파라미터 3개(2Byte * 3)를 제거
```

> 위의 코드에서 함수를 호출하고 난 뒤,
> 스택 포인터(SP) 레지스터에 6을 더하는 이유는 함수 파라미터로 스택에 삽입된 값을 제거하기 위함이다.
> 함수 수행이 끝난 후, 스택을 다시 원래대로 복원하려면 감소한 만큼 더해주면 되므로 6을 더한다.

#### 호출 되는 쪽 (Callee)

호출 되는 함수는 파라미터가 순서대로 삽입되어 있다는 것을 규칙에 따라 이미 알고있다.
따라서 **스택의 특정 위치를 기준으로 오프셋을 이용해 접근함으로써 파라미터를 찾을 수 있다.**

그런데 여기서 문제가 생길 수 있는데,
바로 스택의 상위(Top)을 의미하는 스택 포인터 레지스터(SP)는 스택 관련 명령인 Push, Pop 에 따라 계속 변한다.

스택에 삽입된 파라미터에 접근하려면 시시각각 변하는 스택 포인터 레지스터(SP)대신,
**스택에 고정된 값을 가리키는 레지스터**를 사용하는 것이 편리하다.
이러한 역할을 하는 것이 **베이스 포인터 레지스터(BP)**이며, 

**호출된 함수는 베이스 포인터 레지스터(BP) + 오프셋으로 파라미터에 접근하게 된다.**

> 호출되는 함수에 추가하는 부분은 파라미터에 접근하는 코드 뿐 만이 아니다. 
> 호출된 함수가 작업을 마치고 호출한 코드로 복귀했을 때 코드가 정상적으로 수행되려면
> **호출되기 전후의 레지스터 상태가 같아야 한다.**
>
> 이를 위해서 호출되는 함수에서는 자신이 사용하는 레지스터의 값을 미리 스택에 저장해두고,
> 수행이 끝나면 이를 복원하여 호출한 이후의 코드 수행에 영향을 미치지 않아야 한다.

< 어셈블리어 함수의 일반적인 형식 >

```assembly
push bp		; 베이스 포인터 레지스터(BP)를 스택에 삽입
mov bp, sp	; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
			; 베이스 포인터 레지스터(BP)를 이용해서 파라미터에 접근할 목적
			
push es		; ES세그먼트 레지스터부터 DX 레지스터까지 스택에 삽입
push si		; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서
push di		; 스택에 삽입된 값을 꺼내 원래 값으로 복원한다.
push ax
push cx
push dx

.. 생략 ..

mov ax, word [ bp + 4 ]		; 파라미터 1(iX, 화면 X좌표)
mov bx, word [ bp + 6 ]		; 파라미터 2(iY, 화면 Y좌표)
mov cx, word [ bp + 8 ]		; 파라미터 3(pcString, 출력할 문자열의 어드레스)

.. 생략 ..

pop dx		; 함수에서 사용이 끝난 DX 레지스터부터 ES 레지스터까지를 스택에
pop cx		; 삽입된 값을 이용해서 복원한다.
pop ax		; 역순으로 제거해야한다.
pop di
pop si
pop es
pop bp		; 베이스 포인터 레지스터(BP) 복원
ret			; 함수를 호출한 다음 코드의 위치로 복귀
```

<hr>

## 보호모드에서 사용되는 세 가지 함수 호출 규약

> 호출 규약(Calling Convention)은 
> **함수를 호출할 때 파라미터와 복귀 어드레스 등을 지정하는 규칙**이다.

보호모드에서 사용하는 대표적인 호출 규약에는 

- **stdcall**
- **cdecl**
- **fastcall**

이 있으며 약간씩 차이가 있다.

- **stdcall**

  파라미터를 스택에 저장하며, 호출된 쪽에서 스택을 정리한다.

- **cdecl**

  파라미터를 스택에 저장하지만, 함수를 호출한 쪽에서 스택을 정리한다.

- **fastcall**

  일부 파라미터를 레지스터에 저장하는 것을 제외하면 stdcall 방식과 같다.

  

### 각 규약의 호출 예

< 함수 호출 예(C언어) >

```c
int Add( int iA, int iB, int iC)
{
    return iA + iB + iC;
}

void main( void )
{
    int iReturn;
    iReturn = Add(1,2,3);
}
```

#### stdcall (Standard Call)

stdcall 방식은 파라미터를 스택에 넣을 때, 오른쪽에서 왼쪽 순서로 집어 넣는다.
그리고 함수의 **반환값은 EAX 레지스터(32bit 레지스터)를 사용**하며 
**스택에서 파라미터를 제거하는 작업을 호출된 함수가 처리**하게 한다.

```assembly
Add:
	push ebp						; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
	mov ebp, esp					; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP) 설정
									
	mov eax, dword [ ebp + 8 ]		; 32비트 파라미터 1(iA)을 32비트 AX 레지스터에 설정
									; 보호 모드는 스택의 크기가 4Byte로 리얼 모드의 2배이므로
									; 파라미터 오프셋 또한 4 * 2 가 되어 8로 변경된다.
	
	add eax, dword [ ebp + 12 ]		; 파라미터 2(iB)를 AX 레지스터와 더한다.
	add eax, dword [ ebp + 16 ]		; 파라미터 3(iC)를 AX 레지스터와 더한다.
	pop ebp							; 베이스 포인터 레지스터(BP)를 스택에서 복원
	ret 12							; 스택에 삽입된 파라미터 3개를 제거(3 * 4)한 후,
									; 호출한 함수로 복귀 "add esp, 12" "ret"과 같은 역할
		/*
		ret 12 는 스택 포인터(SP)를 12만큼 더한 후, ret수행
		보호모드 코드 이므로 레지스터의 기본 크기 및 스택의 기본 크기가 32bit(4바이트)
		이기 때문에 4 * 3 = 12만큼 더한다.
		  */
	
main:
	push ebp						; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
	mov ebp, esp					; 베이스 포인터 레지스터(BP)에 스택포인터 레지스터(SP)
									; 값을 설정
	sub esp, 8						; SP 레지스터에서 8만큼 빼서 지역변수 iReturn을 위한
									; 공간을 할당한다.
									
	push 3							; 파라미터 3 삽입
	push 2							; 파라미터 2 삽입
	push 1							; 파라미터 1 삽입
	call ADD						; Add 함수 호출
	mov dword [ ebp - 4 ], eax		; iReturn 변수에 Add 함수의 반환값 저장
	ret								; 호출한 함수로 복귀
	
	/*
	mov dword [ ebp - 4 ], eax
	iReturn 변수에 반환값을 저장, iReturn은 지역변수이므로 스택영역에 할당된다.
	*/
```

위의 코드를 보면 호출되는 함수인 Add() 함수의 마지막에서 **ret 12** 를 호출하여 스택의 파라미터를 제거한다.

**ret 12** 는 스택 포인터 레지스터(SP)에 12를 더한 후, 복귀 어드레스로 되돌아 가는 명령으로,
**add esp, 12** 후 **ret** 를 수행하는 것과 같다.

12를 더하는 이유는 보호모드에서 스택 크기가 4바이트 단위이므로 
파라미터 3개는 4바이트 * 3개 = 12바이트를 스택에서 차지하기 때문이다.



#### cdecl(C-Declare Call)

cdecl은 stdcall과 동일하게 파라미터의 오른쪽에서 왼쪽 순서로 스택에 집어넣는다.
함수의 반환값 역시 AX 레지스터를 사용한다.

단 한 가지 차이점은 스택에서 파라미터를 제거하는 작업을 호출한 함수가 대신 처리한다는 점이다.

```assembly
Add:
	push ebp						; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
	mov ebp, esp					; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP) 설정
									
	mov eax, dword [ ebp + 8 ]		; 32비트 파라미터 1(iA)을 32비트 AX 레지스터에 설정
									; 보호 모드는 스택의 크기가 4Byte로 리얼 모드의 2배이므로
									; 파라미터 오프셋 또한 4 * 2 가 되어 8로 변경된다.
	
	add eax, dword [ ebp + 12 ]		; 파라미터 2(iB)를 AX 레지스터와 더한다.
	add eax, dword [ ebp + 16 ]		; 파라미터 3(iC)를 AX 레지스터와 더한다.
	pop ebp							; 베이스 포인터 레지스터(BP)를 스택에서 복원
;***** 함수안에서 스택을 정리하지 않는다.!!
	ret								; 호출한 함수로 복귀

	
main:
	push ebp						; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
	mov ebp, esp					; 베이스 포인터 레지스터(BP)에 스택포인터 레지스터(SP)
									; 값을 설정
	sub esp, 8						; SP 레지스터에서 8만큼 빼서 지역변수 iReturn을 위한
									; 공간을 할당한다.
									
	push 3							; 파라미터 3 삽입
	push 2							; 파라미터 2 삽입
	push 1							; 파라미터 1 삽입
	call ADD						; Add 함수 호출
	mov dword [ ebp - 4 ], eax		; iReturn 변수에 Add 함수의 반환값 저장
;***** 호출한 쪽에서 스택을 정리한다.
	add esp, 12						; 스택 포인터 레지스터(SP)에 12를 더하여
									; 삽입한 파라미터 3개(3 * 4 Byte)를 제거한다.
	
	
	ret								; 호출한 함수로 복귀
	
```

위의 코드를 보면 stdcall 방식과 달리 호출한 main() 함수의 마지막에서 add esp, 12를 호출하여
스택의 파라미터를 제거하는 것을 볼 수 있다.



#### fastcall

fastcall은 컴파일러마다 구현하는 방식이 조금씩 다르다.
마이크로소프트의 컴파일러를 기준으로 설명하면, 처음 2개의 파라미터를 ECX와 EDX레지스터에 삽입하는 점을 제외하면 stdcall과 같다.

```assembly
Add:
	push ebp						; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
	mov ebp, esp					; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP) 설정
									
	mov eax, dword [ ebp + 8 ]		; 32비트 파라미터 1(iA)을 32비트 AX 레지스터에 설정
									; 보호 모드는 스택의 크기가 4Byte로 리얼 모드의 2배이므로
									; 파라미터 오프셋 또한 4 * 2 가 되어 8로 변경된다.
	
	add eax, dword [ ebp + 12 ]		; 파라미터 2(iB)를 AX 레지스터와 더한다.
	add eax, dword [ ebp + 16 ]		; 파라미터 3(iC)를 AX 레지스터와 더한다.
	pop ebp							; 베이스 포인터 레지스터(BP)를 스택에서 복원

	ret	4							; 호출한 함수로 복귀 "add esp, 4" "ret"과 같은 역할

	
main:
	push ebp						; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
	mov ebp, esp					; 베이스 포인터 레지스터(BP)에 스택포인터 레지스터(SP)
									; 값을 설정
	sub esp, 8						; SP 레지스터에서 8만큼 빼서 지역변수 iReturn을 위한
									; 공간을 할당한다.
									
	push 3							; 파라미터 3 삽입
    
    ;***** 첫 번째 파라미터를 ecx에 두 번째 파라미터를 edx에 저장한다.
	mov edx, 2						; 파라미터 2 삽입, 32비트 DX 레지스터를 통해 전달
	mov ecx, 1						; 파라미터 1 삽입, 32비트 CX 레지스터를 통해 전달
	call ADD						; Add 함수 호출
	mov dword [ ebp - 4 ], eax		; iReturn 변수에 Add 함수의 반환값 저장
	
	ret								; 호출한 함수로 복귀
```

IA-32e 모드의 호출 규약은 fastcall을 확장한 방식이며, 보다 많은 레지스터를 파라미터 전달용으로 사용한다.

IA-32e 모드로 전환되면 기존 레지스터에 8개의 범용 레지스터(R8 ~ R15 레지스터)가 추가된다.
IA-32e 모드의 호출 규약은 기존 레지스터와 추가된 레지스터를 포함하여 파라미터를 최대 6개 까지 전달할 수 있도록 설계되었기 때문에, 파라미터 개수만 제한하여 사용한다면 스택 관련 작업을 줄일 수 있다.