# 세그먼트 디스크립터 생성

세그먼트 디스크립터(Segment Descriptor)는 세그멘테이션 기법(메모리 관리 기법)에서
세그먼트의 정보를 나타내는 자료구조이다.

> 세그먼트는 메모리 공간을 임의의 크기로 나눈 영역을 의미하며,
> 세그먼트를 복잡하게 구성할 수록 세그먼트 디스크립터의 수도 증가한다.
>
> 우리가 만드는 OS에서는 보호 모드의 기본 기능만 사용하므로 4GB 전체 메모리 공간을 지정하는 커널코드와
> 데이터 세그먼트만 사용한다.



세그먼트에 대한 정보를 나타내는 세그먼트 디스크립터는 크게 다음으로 나누어 진다.

- **코드 세그먼트 디스크립터**

  실행 가능한 코드가 포함된 세그먼트에 대한 정보를 나타내며,
  CS 세그먼트 셀렉터에 사용된다.

- **데이터 세그먼트 디스크립터**
  데이터가 포함된 세그먼트에 대한 정보를 나타내며,
  CS 세그먼트 셀렉터를 제외한 나머지 셀렉터에 사용할 수 있다.

  > 스택 영역 또한 데이터를 읽고 쓰는 데이터 영역의 한 종류이므로 데이터 세그먼트 디스크립터를 사용한다.

> 리얼모드에서 사용하던 세그먼트 레지스터라는 명칭은
> **보호모드에서 세그먼트 셀렉터라는 이름으로 바뀌었다.**
>
> 이름만 바뀌었을 뿐 실제로는 같은 레지스터이다.

<hr>



## 보호모드의 세그먼트 디스크립터

[![보호 모드 세그먼트 디스크립터 구조에 대한 이미지 검색결과](https://dongyeollee.github.io/images/OS/4/2.png)](https://www.google.com/url?sa=i&rct=j&q=&esrc=s&source=images&cd=&ved=2ahUKEwji9ZCi_qLjAhUyGaYKHQZbAhkQjRx6BAgBEAU&url=http%3A%2F%2Fdongyeollee.github.io%2F2018%2F01%2F13%2FOS%2FProject%2FConvertTo32bitProtectMode%2F&psig=AOvVaw10u3wkfoTkZ539eijSOcaF&ust=1562595026367429)

보호 모드의 세그먼트 디스크립터는 8Byte로 위 그림과 같이 다양한 필드가 있다.

< 세그먼트 디스크립터의 필드와 의미 >

| 필드          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 기준 주소     | - 세그먼트의 시작 어드레스<br />- 32Bit 크기이며, 0바이트 ~ 4GB 까지 설정이 가능하다. |
| 세그먼트 크기 | - 세그먼트 크기<br />- 20Bit크기<br />- G 비트가 0으로 설정되면 0바이트 ~ 1MB 까지 설정 가능<br />- G 비트가 1로 설정되면 4KB를 곱하여 0바이트 ~ 4GB까지 설정가능 |
| 타입          | - 세그먼트 타입<br />- 코드 또는 데이터 세그먼트로 설정 가능 |
| S             | - 디스크립터의 타입<br />- 1로 설정할 경우 세그먼트 디스크립터를 나타내며,<br />  0으로 설정할 경우 시스템 디스크립터를 나타낸다. |
| DPL           | - Descriptor Privilege Level의 약자로 해당 디스크립터를 사용하는데 필요한 권한을 의미<br />- 0(Highest) ~ 3(Lowest)의 범위를 가진다.<br />- CPL(Current Privilege Level)나 RPL(Requested Privilege Level)과 조합되어<br />  접근 권한을 제한하는 데 사용된다. |
| P             | - Present의 의미로 현재 디스크립터가 유효한 디스크립터인지 표시<br />- 1로 설정하면 유효한 디스크립터, 0은 유효하지 않은 디스크립터를 나타낸다. |
| AVL           | - Available의 약자로 OS가 임의의 용도로 사용할 수 있는 영역  |
| L             | - IA-32e 모드에서 사용하느 필드로 64비트 코드 세그먼트나 32비트 코드 세그먼트를 의미<br />- 1로 설정하면 IA-32e모드의 64비트용 코드 세그먼트임을 나타내며,<br />  0으로 설정하면 IA-32e 모드의 32비트 호환 모드용 코드 세그먼트임을 나타낸다. |
| D / B         | - Default Operation Size 를 의미<br />- 1로 설정하면 32비트용 세그먼트임을 나타내며, 0은 16비트용 세그먼트임을 나타낸다. |
| G             | - Granularity의 약자로 디스크립터의 세그먼트 크기 필드에 곱해질 가중치를 의미한다.<br />- 1로 설정하면 세그먼트 크기에 4KB를 곱하며, 0으로 설정하면 곱하지 않는다. |



우리의 OS에 필요한 세그먼트는 다음과 같다.

- 커널 코드와 데이터용 세그먼트 디스크립터 각 1개
- 커널 코드와 데이터용 세그먼트는 0 ~ 4KB까지 모든 영역에 접근할 수 있어야 한다.
- 보호 모드용 코드와 데이터에 사용할 기본 오퍼랜드 크기는 32비트여야 한다.
- 보호 기능은 사용하지 않으며, 프로세서의 명령을 사용하는 데 제약이 없어야 하므로,
  최상위 권한(0)이어야 한다.

<hr>



## 코드와 데이터 세그먼트 디스크립터 타입 설정

코드 세그먼트와 데이터 세그먼트를 설정하려면 **S 필드** 와 **타입 필드** 를 조합해야 한다.

**S 필드를 살펴보면**
코드 세그먼트와 데이터 세그먼트는 세그먼트 디스크립터이므로 간단하게 S필드 값을 1로 설정한다.

**세그먼트 타입은**
4비트 크기의 타입 필드를 이용해서 설정하며, 각 비트 값은 다음 표와 같은 의미를 나타낸다.

[![img](https://dongyeollee.github.io/images/OS/4/4.png)](https://dongyeollee.github.io/images/OS/4/4.png)

> 우리 OS 에서는 기본적인 세그먼트 타입만 사용하고,
> 코드 세그먼트는 실행 / 읽기 타입으로 설정하고 데이터 세그먼트는 읽기 / 쓰기 타입으로 설정한다.
>
> 표에서 찾아보면 코드 세그먼트 타입은 **0x0A(Execute/Read)**, 
> 데이터 세그먼트 타입은 **0x02(Read/Write)** 가 된다.

<hr>



## 세그먼트의 영역 설정

우리가 만드는 OS의 커널 세그먼트 디스크립터는 **4GB 전체 영역에 접근할 수 있어야 한다.**
그러므로, 커널용 세그먼트 디스크립터의 기준 주소는 0으로 설정한다.

세그먼트의 기준 주소를 정했으니 이제 세그먼트의 크기를 설정해야 하는데,
크기 필드는 총 20비트이며 **20비트로 표현할 수 있는 최대 값은 1MB( 2의 20승)** 이다.
크기 필드만으로 4GB까지의 영역을 표현할 수 없으므로 20비트의 크기를 4GB로 확장할 방법이 필요한데,

이 때 사용하는 것이 **G 필드** 로,
G필드의 값을 1로 설정하면 **크기 필드에 4KB(4 * 2의 10승)를 곱한 것이 실제 세그먼트의 크기가 된다.**

> **1MB(2의 20승)에 4KB(4* 2의 10승)를 곱하면 4GB(4 * 2의 30승)** 가 되므로,
> 크기 필드와 G필드를 사용하면 메모리 전체 영역을 세그먼트의 영역으로 설정할 수 있다.

<hr>



## 기본 오퍼랜드 크기와 권한 설정

#### 기본 오퍼랜드 크기 설정 필드

보호 모드는 32비트로 동작하므로 기본 오퍼랜드의 크기 역시 32비트로 설정한다.

여러 필드 중에 **기본 오퍼랜드의 크기는 D / B 필드가 담당** 하며,
1로 설정하면 기본 오퍼랜드의 크기를 32비트로 설정할 수 잇다.

> 기본 오퍼랜드의 크기와 관계된 필드는 D / B뿐 아니라
> IA-32e 모드의 64비트 서브 모드 또는 32비트 호환 모드를 설정하는 L 필드도 있다.

<hr>

#### 권한 필드

권한 필드는 보호 모드의 주요 특징 중 하나인 보호 기능에 핵심 역할을 한다.

프로세서는 디스크립터의 권한 필드에 설정된 값과
세그먼트 셀렉터의 권한을 비교하여 접근이 가능한지를 판단하며,
x86 프로세서에서 동작하는 운영체제의 대부분도 이 기능을 사용하여 OS의 핵심 부분을 보호한다.

<hr> 



## 기타 필드 설정

생성한 세그먼트 디스크립터는 보호 모드로 전환하는 과정에서 사용하므로 
유효한 디스크립터라는 것을 알려야 한다.

디스크립터가 유효함을 나타내는 필드는 P 필드이며 1로 설정하면 해당 디스크립터를 사용할 수 있다.

AVL 필드는 임의로 사용할 수 있는 필드로 우리는 별도의 값을 쓰지 않으므로 0으로 설정한다.

<hr>





# 세그먼트 디스크립터 생성 코드

앞의 내용을 바탕으로 어셈블리어를 사용하여 코드 세그먼트 디스크립터와 데이터 세그먼트 디스크립터 생성

< 세그먼트 디스크립터의 구조와 메모리 공간, 그리고 어셈블리어 코드의 관계 >

[![img](https://dongyeollee.github.io/images/OS/4/5.png)](https://dongyeollee.github.io/images/OS/4/5.png)



다음은 코드 세그먼트 디스크립터와 데이터 세그먼트 디스크립터를 생성하는 실제코드이다.

```assembly
CODEDESCRIPTOR:
	dw 0xFFFF		; Limit	[15:0]
	dw 0x0000		; Base 	[15:0]
	db 0x00			; Base	[23:16]
	db 0x9A			; P = 1, DPL = 0, Code Segment, Execute / Read
	db 0xCF			; G = 1, D = 1, L = 0, Limit [19:16]
	db 0x00			; Base	[31:24]
	
DATADESCRIPTOR:
	dw 0xFFFF		; Limit	[15:0]
	dw 0x0000		; Base	[15:0]
	db 0x00			; Base	[23:16]
	db 0x92			; P = 1, DPL = 0, Data Segment, Read / Write
	db 0xCF			; G = 1, D = 1, L = 0, Limit [19:16]
	db 0x00   		; Base	[31:24]
```



## 정리

세그먼트 디스크립터의 생성과정을 정리해 보았다.

64Bit IA-32e 모드로 전환하려면 반드시 32Bit 보호 모드를 거쳐야 한다.

보호모드는 
현대 OS가 제공하는 **4GB의 주소공간, 멀티태스킹, 페이징, 메모리 보호 등의 기능을 하드웨어적으로 지원한다.**

