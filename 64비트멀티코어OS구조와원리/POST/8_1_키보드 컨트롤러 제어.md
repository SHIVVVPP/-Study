# 키보드 컨트롤러 제어

이번 장에서는 레지스터를 사용하여 키보드와 키보드 컨트롤러를 제어하는 방법에 대해서 알아본다.



## 키보드와 키보드 컨트롤러 활성화

일반적으로 부트 로더가 실행되기 전에 키보드는 이미 BIOS에 의해 활성화된 상태이다.
따라서, 키보드를 활성화하는 단계를 굳이 수행하지 않아도 키보드에서 키 값을 읽는데 아무 문제가 없다.

하지만, 키보드를 직접 활성화하겠다.



키보드 컨트롤러에서 키보드 디바이스를 사용 가능하게 하려면,
커맨드 포트로 키보드 디바이스 활성화 커맨드인 0xAE를 보내면 된다.

하지만 이것은 '키보드 컨트롤러'에서 활성화된 것이지 실제 키보드가 활성화 된 것은 아니다.

키보드 컨트롤러와 키보드 PS/2 방식의 케이블로 연결되어 있으며 PC의 외부에 존재한다.
따라서 키보드 활성화 커맨드를 보내줄 필요가 있다.



키보드에 직접 데이터를 보내는 방법은 커맨드를 전송하지 않고,
입력 버퍼에 키보드로 보낼 커맨드를 직접 쓰면 된다.

키보드는 키보드 컨트롤러와 달리 커맨드나 데이터에 대한 응답이 전송되며,
정상적으로 처리한 경우 ACK(0xFA)를 전송한다.

만일 ACK가 수신되지 않으면 수행 도중 에러가 발생한 것이므로,
재시도하거나 작업을 포기해야 한다.

다음은 키보드 커맨드 중에서 키보드 활성화와 LED 제어에 대한 커맨드를 정리한 것이다.

| 키보드 커맨드 | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 0xED          | - 키보드의 LED 상태를 변경<br />   - 비트 2:1로 설정하면 Caps Lock이 켜진다.<br />   - 비트 1:1로 설정하면 Num Lock이 켜진다.<br />   - 비트 0:1로 설정하면 Scroll Lock이 켜진다. |
| 0xF4          | - 키보드 활성화                                              |

<hr>

### 키보드 컨트롤러와 키보드를 활성화 하는 코드

이제 실제 코드를 작성해보자.

키보드 컨트롤러의 키보드 활성화는 커맨드 포트에 0xAE를 보내면 된다.
키보드 컨트롤러로 커맨드를 보냈다면 남은 것은 키보드에 직접 커맨드를 보내는 일이다.

> 키보드로 커맨드를 보내려면 입력 버퍼의 상태 처리와 키보드의 응답 처리를 해야 하므로 약간 까다롭다.



키보드와 키보드 컨트롤러는 프로세서와 비교하면 아주 느리게 동작하므로 
프로세서가 커맨드를 전송하고 한참을 기다려야 수행이 완료된다.

여기서 문제는 커맨드가 완료될 때까지 얼마나 기다려야 하는가 이다.

커맨드를 처리하는 시간은 키보드와 키보드 컨트롤러의 상태에 따라 가변적인 부분이다.

그러므로 키보드 컨트롤러의 상태를 확인할 수 있는 것이 필요하다.

이때 사용하는 것이 키보드 컨트롤러의 상태 레지스터(0x64)이다.



상태 레지스터는 입력 버퍼 상태를 표시하는 비트(비트 1)와 출력 버퍼의 상태를 표시하는 비트(비트 0)가 있다.

입력 버퍼 상태 비트(비트 1)를 통해 입력 버퍼가 비었는지 확인한 후 키보드 커맨드를 송신하고,
출력 버퍼 상태 비트(비트 0)을 통해 출력 버퍼에 데이터가 있는지 확인한 후 실행 결과를 읽음으로써 보다 효율적으로 처리할 수 있다.

다음은 입력 버퍼 상태 비트와 출력 버퍼 상태 비트를 이용하여 키보드를 활성화 하는 코드이다.

```c
// 출력 버퍼 (포트 0x60)에 수신된 데이터가 있는지 여부를 반환
BOOL kIsOutputBufferFull(void)
{
    // 상태 레지스터(포트 0x64)에서 읽은 값에 출력 버퍼 상태 비트(비트 0)가
    // 1로 설정되어 있으면 출력 버퍼에 키보드가 전송한 데이터가 존재한다.
    if(kInPortByte(0x64) & 0x01)
    {
        return TRUE;
    }
    return FALSE;
}

// 입력 버퍼(포트 0x64)에 프로세서가 쓴 데이터가 남아있는지 여부를 반환한다.
BOOL kIsInputBufferFull(void)
{
    // 상태 레지스터(포트 0x64)에서 읽은 값에 입력 버퍼 상태 비트(비트 1)가
    // 1로 설정되어 있으면 아직 키보드가 데이터를 가져가지 않은것이다.
    if(kInPortByte(0x64)&0x02)
    {
        return TRUE;
    }
    return FALSE;
}

// 키보드를 활성화
BOOL kActivateKeyboard(void)
{
    int i;
    int j;
    
    // 키보드 레지스터(포트 0x64)에 키보드 활성화 커맨드(0xAE)를 전달하여 키보드 디바이스를 활성화
    kOutPortByte(0x64,0xAE);
    
    // 입력 버퍼(포트 0x60)가 빌 때 까지 기다렸다가 키보드에 활성화 커맨드를 전송한다.
    // 0xFFFF만큼 루프를 수행할 시간이면 충분히 커맨드가 전송될 수 있다.
    // 0xFFFF 루프를 수행한 이후에도 입력 버퍼(포트 0x60)가 비지 않으면 무시하고 전송한다.
    for(i = 0; i< 0xFFFF; i++)
    {
        // 입력 버퍼(포트 0x60)가 비어있으면 키보드 커맨드 전송 가능하다.
        if(kIsInputBufferFull() == FALSE)
        {
            break;
        }
    }
    
    // 입력 버퍼(포트 0x60)로 키보드 활성화(0xF4) 커맨드를 전달하여 키보드로 전송한다.
    kOutPortByte(0x60, 0xF4);
    
    // ACK가 올 때 까지 대기한다.
    // ACK가 오기 전에 키보드 출력 버퍼(포트 0x60)에 키 데이터가 저장될 수 있으므로
    // 키보드에서 전달된 데이터를 최대 100개까지 수신하여 ACK를 확인한다.
    for(j =  0; j < 100; j++)
    {
        // 0xFFFF만큼 루프를 수행할 시간이면 충분히 커맨드의 응답이 올 수 있다.
        // 0xFFFF 루프를 수행한 이후에도 출력 버퍼(포트 0x60)가 차 있지 않으면 무시하고 읽는다.
        for(i = 0; i< 0xFFFF; i++)
        {
            // 출력 버퍼(포트 0x60)가 차있으면 데이터를 읽을 수 있다.
            if(kIsOutputBufferFull() == TRUE)
            {
                break;
            }
        }
        
        // 출력 버퍼(포트 0x60)에서 읽은 데이터가 ACK(0xFA)이면 성공이다.
        if(kInPortByte(0x60) == 0xFA)
        {
            return TRUE;
        }
    }
    return FALSE;
}
```

위 코드에서 입력 버퍼의 상태나 출력 버퍼의 상태를 확인할 때 루프를 0xFFFF만큼 수행하고 있다.

> 사실 루프 횟수는 꼭 0xFFFF이 아니어도 된다.
> 입력 버퍼에 데이터가 비거나 출력 버퍼에 데이터가 찰 만큼의 시간이면 충분하다.

키보드는 커맨드 또는 데이터를 수신할 때마다 키보드 컨트롤러로 응답 코드를 전송하므로 키보드로 커맨드나 데이터를 전송하고 나서 처리 상태를 확인해야 한다.

키보드는 커맨드를 성공적으로 처리했을 때 ACK(0xFA)를 전송하는데,
이때 ACK가 전달되기 전에 몇몇 키 값이 이미 출력 버퍼에 들어 있을 수 있다.

따라서 출력 버퍼를 계속 읽어 뒤쪽에 삽입된 ACK(0xFA)를 찾아야 한다.

> 루프 100회는 바로 출력 버퍼에서 삽입된 데이터를 계속 읽어 내는 횟수인 것이다.
> 100회 정도면 출력 버퍼에 들어있는 데이터를 전부 읽고도 남는 횟수이므로 ACK를 찾기에 충분하다.

<hr>

위 코드에서 사용한 *kOutPortByte( )*, *kInPortByte( )* 함수는 
어셈블리어의 OUT 명령어와  IN 명령어를 수행하는 어셈블리어 함수이다.

IN 명령어는 포트 I/O 어드레스에서 데이터를 읽어오는 역할을 한다.
IN 명령어는 포트 I/O어드레스를 지정하는데 DX레지스터를 사용하며 포트에서 값을 읽어 AX레지스터에 저장한다

OUT 명령어는 IN 명령어와 반대로 
포트 I/O 어드레스에는 DX 레지스터를 사용하며 값을 보내는 레지스터로는 AX 레지스터를 사용한다.

포트에서 읽고 쓸 데이터의 크기는 어떤 AX 레지스터를 사용하느냐에 따라서 달라지고,
EAX 레지스터를 사용할 경우 32비트(4바이트), AX 레지스터는 16비트(2바이트), AL 레지스터는 8비트(1바이트) 
데이터를 처리할 수 있다.

키보드 컨트롤러는 포트로 한 바이트만 처리할 수 있으므로, 여기서는 AL 레지스터를 사용한다.

다음은 *kInPortByte( )*, *kOutPortByte( )* 함수의 코드이다.

```assembly
; 포트로부터 1바이트를 읽는다.
;	PARAM: 포트 번호
kInPortByte:
	push rdx		; 함수에서 임시로 사용하는 레지스터를 스택에 저장한다.
					; 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 복원
					
	mov rdx, rdi	; RDX 레지스터에 파라미터 1(포트 번호)를 저장한다.
	mov rax, 0		; RAX 레지스터를 초기화
	in al, dx		; DX 레지스터에 저장된 포트 어드레스에서 한 바이트를 읽어
					; AL 레지스터에 저장, AL 레지스터는 함수의 반환 값으로 사용된다
					; in 포트 I/O 어드레스에서 데이터를 읽어오는 명령어
	
	pop rdx			; 함수에서 사용이 끝난 레지스터를 복원
	ret				; 함수를 호출한 다음 코드의 위치로 복귀한다.
	
; 포트에 1바이트를 쓴다.
;	PARAM: 포트 번호, 데이터
kOutPortByte:
	push rdx		; 함수에서 임시로 사용하는 레지스터를 스택에 저장한다.
	push rax		; 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 복원한다.
	
	mov rdx, rdi	; RDX 레지스터에 파라미터 1(포트 번호)를 저장한다.
	mov rax, rsi	; RAX 레지스터에 파라미터 2(데이터)를 저장한다.
	out dx, al		; DX 레지스터에 저장된 포트 어드레스에 AL 레지스터에 저장된
					; 한 바이트를 쓴다.
					; out 포트 I/O 어드레스에 데이터를 쓰는 명령어
	
	pop rax			; 함수에서 사용이 끝난 레지스터를 복원
	pop rdx
	ret				; 함수를 호출한 다음 코드의 위치로 복귀
```

위의 코드를 보면 보호 모드와 달리 파라미터를 스택에서 넘겨받지 않고 RDI나 RSI 레지스터로 넘겨받는다는 것을 알 수 있다.

<hr>

### IA-32e 모드의 호출 규약

C 코드에서 어셈블리어 함수를 호출하려면 호출 규약을 지켜야 한다.
보호모드 호출 규약과 IA-32e 모드 호출 규약의 차이점을 위주로 알아보자.

**IA-32e 모드의 C 호출 규약과 보호 모드의  C 호출 규약을 비교하면 크게 3가지 부분에서 차이가난다.**

1. **파라미터를 전달할 때 레지스터를 우선으로 사용한다.**

   파라미터로 사용하는 레지스터는 파라미터의 타입에 따라 다르다.
   정수 타입의 경우 RDI, RSI, RDX, RCX, R8, R9 레지스터의 순서로 모두 6개를 사용하며,
   실수 타입의 경우 XMM0 ~ XMM7 레지스터의 순서로 모두 8개를 사용한다.

   파라미터의 수가 정해진 레지스터의 수를 넘으면 보호 모드와 마찬가지로 스택 영역을 사용한다.

2. **레지스터 또는 스택에 파라미터를 삽입하는 순서**

   보호 모드의 경우 파라미터 리스트의 오른쪽에서 왼쪽으로 이동하면서 파라미터를 스택에 삽입한다.

   하지만, 64비트 모드에서는 파라미터 리스트의 왼쪽에서 오른쪽으로 이동하면서 
   레지스터나 스택을 사용하여 삽입한다.

3. **함수의 반환 값으로 사용하는 레지스터**

   보호 모드는 EAX 레지스터를 사용하여 반환 값을 처리하지만,
   64비트 모드는 정수 타입이면 RAX 또는 RAX와 RDX 레지스터를 사용하고
   실수 타입은  XMM0 또는 XMM0과 XMM1 레지스터를 사용한다.

이러한 차이 때문에 어셈블리어 코드가 비교적 스택을 덜 사용하는 구조를 하게 된다.

파리미터 전달과 반환 값 전달 방식이 기존의 보호 모드와 달라 낯설게 느껴지지만,
이러한 것 외에 나머지는 보호 모드와 거의 동일하므로 코드 흐름을 이해하는데 어려움을 없을 것이다.

<hr>

다음은 IA-32e 모드의 호출 규약을 그림으로 나타낸 것이다.

![image](https://user-images.githubusercontent.com/34773827/61147815-4829ae00-a518-11e9-9842-6a78e2a67ebe.png)

<hr>



## 키보드 컨트롤러에서 키 값 읽기

키보드는 키가 눌리거나 떨어질 때마다 키 별로 할당된 특수한 값을 키보드 컨트롤러로 전달하며,
이 값을 스캔 코드(Scan Code)라고 한다.

여기서는 키보드 컨트롤러에서 키 값을 읽어오는 방법에 대해서 알아보자.



별다른 커맨드를 키보드 컨트롤러로 보내지 않으면,
키보드 컨트롤러의 출력 버퍼에는 키보드 또는 마우스에서 수신된 데이터가 저장된다.

따라서 상태 레지스터를 읽어서 출력 버퍼에 데이터가 있는지 확인한 후,
데이터가 있다면 출력 버퍼를 읽어서 저장한다.

다음은 키 값을 읽어 들이는 코드이다.

```c
BYTE kGetKeyboardScanCode(void)
{
    // 출력 버퍼(포트 0x60)에 데이터가 있을 때 까지 대기
    while( kIsOutputBufferFull() == FALSE)
    {
        ;
    }
    return kInPortByte(0x60); // 출력 버퍼(포트 0x60)에서 키 값(스캔코드)를 읽어서 반환
}
```

<hr>



## A20 게이트 활성화와 프로세스 리셋

키보드 컨트롤러의 출력 포트는 키보드와 마우스 외에 A20 게이트와 프로세서 리셋에 관련된 라인과도 연결되어 있다.

이것은 출력 포트의 해당 비트를 1로 설정해서  A20 게이트를 활성화하거나 프로세서를 리셋할 수 있다는 것을 의미한다.

A20 게이트 비트와 프로세서 리셋 비트는 출력 포트의 비트 1과 비트 0에 있다.
그리고 키보드 컨트롤러의 출력 포트는 0xD0, 0xD1 커맨드로 접근할 수 있다.

A20 게이트를 활성화하는 방법과 프로세서를 리셋하는 방법은 출력 포트의 데이터를 0으로 설정하는 것만 다르고
나머지 코드는 같다.



다음은 A20 게이트를 활성화하는 코드를 나타낸 것이다.

출력 포트에서 데이터를 읽어오는  0xD0 커맨드로 현재 출력 포트의 값을 읽고 나서 비트 1을 1로 설정하여 A20 게이트 비트만 변경했다. 그리고 그 값을 다시 0xD1 커맨드로 키보드 컨트롤러의 출력 포트에 보내어 A20 게이트를 활성화 하였다.

```c
void kEnableA20Gate(void)
{
    BYTE bOutputPortData;
    int i;
    
    // 컨트롤 레지스터(포트 0x64)에 키보드 컨트롤러의 출력 포트 값을 읽는 커맨드(0xD0) 전송
    kOutPortByte(0x64,0xD0);
    
    // 출력 포트의 데이터를 기다렸다가 읽는다.
    for(i = 0; i < 0xFFFF; i++)
    {
        // 출력 버퍼(포트 0x60)가 차있으면 데이터를 읽을 수 있다.
        if(kIsOutputBufferFull() == TRUE)
        {
            break;
        }
    }
    
    // 출력 포트(포트 0x60)에 수신된 키보드 컨트롤러의 출력 포트 값을 읽는다.
    bOutputPortData = kInPortByte(0x60);
    
    // A20 게이트 비트 설정
    bOutputPortData != 0x01;
    
    // 입력 버퍼(포트 0x60)에 데이터가 비어있으면 출력 포트에 값을 쓰는 커맨드와 출력 포트 데이터 전송
    for(i = 0; i < 0xFFFF ; i++)
    {
        // 입력 버퍼(포트 0x60)가 비었으면 커맨드 전송 가능
        if(kIsInputBufferFull() == FALSE)
        {
            break;
        }
    }
    
    // 커맨드 레지스터(0x64)에 출력 포트 설정 커맨드(0xD1)을 전달
    kOutPortByte(0x64,0xD1);
    // 입력 버퍼(0x60)에 A20 게이트 비트가 1로 설정된 값을 전달
    kOutPortByte(0x60, bOutputPortData);
}
```

<hr>



## 키보드 LED 상태 제어

키보드의 LED 상태를 변경하는 방법은 키보드를 활성화 하는 방법과 아주 비슷하다.
차이점이라면 커맨드 포트를 사용하지 않고 입력 버퍼만을 사용한다는 것이다.

키보드의 LED 상태를 변경하려면 입력 버퍼(포트 0x60)로 0xED 커맨드를 전송해서 키보드에 LED 상태 데이터가 전송될 것임을 미리 알려야 한다.
그리고 키보드가 커맨드를 잘 처리했는지 ACK를 확인하고 나서 LED 상태를 나타내는 데이터를 전송한다.

키보드로 데이터를 전송하고 나서 잘 처리 되었는지 확인해야 하므로 이를 확인한 후 성공 여부를 판단하면 된다.



LED 상태 데이터는 1바이트 중 하위 3비트만을 사용하며, Caps Lock은 비트 2, Num Lock은 비트 1, Scroll Lock은 비트 0에 할당되어 있다.

키보드 LED를 키려면 해당 비트를 1로 설정하면 되고, 반대로 끄려면 0으로 설정하면 된다.



다음은 키보드의 상태 LED를 제어하는 코드를 나타낸 것이다.
LED의 상태를 On/Off 상태를 파라미터로 받아 처리한다.

```c
BOOL kChangeKeyboardLED(BOOL bCapsLockOn, BOOL bNumLockOn, BOOL bScrollLockOn)
{
    int i, ;
    
    // 키보드에 LED 변경 커맨드를 전송하고 커맨드가 처리 될 때 까지 대기
    for( i = 0; i < 0xFFFF ; i++)
    {
        // 출력 버퍼(포트 0x60)가 비어있으면 커맨드 전송 가능
        if(kIsInputBufferFull() == FALSE)
        {
            break;
        }
    }
    
    // 출력 버퍼(포트 0x60)로 LED 상태 변경 커맨드(0xED) 전송
    kOutPortByte(0x60, 0xED);
    for(i = 0; i < 0xFFFF ; i++)
    {
        // 입력 버퍼(포트 0x60)가 비어 있으면 키보드가 커맨드를 가져간 것이다.
        if(kIsInputBufferFull() == FALSE)
        {
            break;
        }
    }
    
    // 키보드가 LED 상태 변경 커맨드를 가져갔으므로 ACK가 올 때 까지 대기
    for( j = 0; j< 100; j++)
    {
        for(i = 0; i < 0xFFFF ; i++)
        {
            // 출력 버퍼(포트 0x60)가 차 있으면 데이터를 읽을 수 있다.
            if(kIsOutputBufferFull() == TRUE)
            {
                break;
            }
        }
        
        // 출력 버퍼(포트 0x60)에서 읽은 데이터가 ACK(0xFA)이면 성공
        if(kInPortByte(0x60) == 0xFA)
        {
            break;
        }
    }
    if( j>=100)
    {
        return FALSE;
    }
    
    // LED 변경 값을 키보드로 전송하고 데이터 처리가 완료될 때 까지 대기
    kOutPortByte(0x60, (bCapsLockOn << 2) | (bNumLockOn << 1)|bScrollLockOn);
    for( i = 0; i< 0xFFFF ; i++)
    {
        // 입력 버퍼(포트 0x60)가 비어 있으면 키보드가 LED 데이터를 가져간 것이다.
        if(kIsInputBufferFull() == FALSE)
        {
            break;
        }
    }
    
    // 키보드가 LED 데이터를 가져갔으므로 ACK가 올 때 까지 대기
    for(j = 0; j< 100; j++)
    {
        for(i = 0; i < 0xFFFF; i++)
        {
            // 출력 버퍼(포트 0x60)가 차 있으면 데이터를 읽을 수 있다.
            if(kIsOutputBufferFull() == TRUE)
            {
                break;
            }
        }
        
        // 출력 버퍼(포트 0x60)에서 읽은 데이터가 ACK(0xFA)이면 성공
        if(kInPortByte(0x60) == 0xFA)
        {
            break;
        }
    }
    if( j >= 100)
    {
        return FALSE;
    }
    return TRUE;
}
```

