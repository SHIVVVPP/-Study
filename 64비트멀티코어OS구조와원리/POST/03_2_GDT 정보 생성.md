# GDT 정보 생성

GDT( Global Descriptor Table ) 자체는 **연속된 디스크립터의 집합** 이다.

> 우리 OS가 사용하는 코드 세그먼트 디스크립터와 데이터 세그먼트 디스크립터를 연속된 어셈블리어 코드로 나타내면 그 전체 영역이 GDT가 된다.

한 가지 제약 조건이 있다면 **널 디스크립터(NULL Descriptor)** 를 가장 앞부분에 추가해야 한다는 것이다.

> 널 디스크립터는 프로세서에 의해 예약된 디스크립터로,
> 모든 필드가 0으로 초기화된 디스크립터이며, 일반적으로 참조되지 않는다.



GDT는 디스크립터의 집합이므로, **프로세서에 GDT의 시작 어드레스와 크기 정보를 로딩해야 한다.**

따라서 이것을 저장하는 자료구조가 필요하며, 이 자료구조는 다음과 같은 구조를 한다.

[![img](https://dongyeollee.github.io/images/OS/4/6.png)](https://dongyeollee.github.io/images/OS/4/6.png)

GDT 정보를 저장하는 자료구조의 **기준 주소는 32비트의 크기** 이며, 
데이터 세그먼트의 기준 주소와 관계 없이 **어드레스 0을 기준으로하는 선형주소이다.**

> 따라서 GDT의 시작 어드레스를 실제 메모리 공간상의 어드레스로 변환할 필요가 있다.
> GDT의 선형 주소는 현재 코드가 실행되고 있는 세그먼트의 기준 주소를 알고 있으므로,
>
> **현재 세그먼트의 시작을 기준으로 GDT의 오프셋을 구하고, 세그먼트 기준 주소를 더해주면 구할 수 있다**.

<hr>

## GDT 및 GDT 정보 생성 코드

앞에서 세그먼트 디스크립터를 생성하였으므로,
널 디스크립터와 GDT 정보를 저장하는 자료구조만 앞 뒤로 추가해주면 된다.

```assembly
; GDTR 자료 구조 정의
GDTR:
	dw GDTEND - GDT - 1			; 아래에 위치하는 GDT 테이블의 전체 크기
	dd ( GDT - $$ +0x10000 )	; 아래에 위치하는 GDT 테이블의 시작 어드레스
	
; GDT 테이블 정의
GDT:
	; 널 디스크립터. 반드시 0으로 초기화해야 한다.
	NULLDescriptor:
		dw 0x0000
		dw 0x0000
		db 0x00
		db 0x00
		db 0x00
		db 0x00
		
	.. 생략 ..
	
	; 보호 모드 커널용 데이터 세그먼트 디스크립터
	DATADESCRIPTOR:
		dw 0xFFFF		; Limit	[15:0]
		dw 0x0000		; Base	[15:0]
		db 0x00			; Base	[23:16]
		db 0x92			; P = 1, DPL = 0, Data Segment, Read/Write
		db 0xCF			; G = 1, D = 1, L = 0, Limit [19:16]
		db 0x00			; Base [32:24]
GDTEND:
```

이로써 보호 모드로 전환하는 데 필요한 데이터가 모두 준비가 된다.



## GDT 추가

GDT 정보를 담는 자료구조에서 GDT의 크기를 나타내는 필드는 2바이트(16Bit)이므로
GDT에 포함 가능한 디스크립터(8Byte 크기) 수는 65536/8이 되어 최대 8192개가 된다.

충분한 크기 같지만 멀티 태스킹을 위해 태스크 디스크립터와 태스크별 세그먼트 디스크립터, 기타 디스크립터를 생성하다 보면 공간이 부족할 수 있다.

그래서 x86 프로세서는 이런 문제를 해결하고자 GDT와 비슷한 역할을 하는 LDT(Local Descriptor Table)를 제공한다. LDT 역시 GDT와 같이 디스크립터를 포함하는 테이블이며, 크기도 GDT와 같다.

LDT를 사용하면 태스크에 관련된  세그먼트 디스크립터나 기타 시스템 디스크립터를 GDT에서 LDT로 옮길 수 있으므로 더 많은 태스크를 생성할 수 있다는 장점이 있다.