# 화면 버퍼와 화면 제어

화면에 문자를 출력하려면 현재 동작 중인 화면 모드와 관련된 **비디오 메모리의 어드레스를 알아야 한다.**

> 비디오 메모리는 화면 출력과 관계된 메모리로 모드별로 정해진 형식에 따라 데이터를 채우면 화면에 원하는 문자나 그림을 출력하는 구조로 되어있다.

<hr>

PC 부팅 후 기본으로 설정되는 화면 모드는 **텍스트 모드** 이다.

화면 크기는 가로 80문자, 세로 25문자이며, **0xB8000** 에서 시작한다.

또한 화면에 표시하는 한 문자는 **문자값 1 Byte** 와 **속성값 1Byte** 로 구성되며,
총 메모리 크기는 화면 크기를 곱한 크기인 80 * 25 * 2 = **4000Byte** 이다.

> 속성값은 하위 4비트의 **전경색** 상위 4비트의 **배경색** 으로 구분된다.
> 각 전경색과 배경색은 다시 최상위 **특수 기능 비트** 와 하위 3비트의 **색상** 으로 구분된다.
>
> 전경색은 강조 효과만 지원하지만, 배경색은 강조와 깜빡임 두 기능을 제공한다.
>
> <텍스트 모드 속성값의 구성>
>
> ![image](https://user-images.githubusercontent.com/34773827/60755730-e2788600-a02e-11e9-954d-eae7c9569825.png)

<hr>

### 화면에 문자 표시

화면에 문자를 표시하려면 **0xB8000** 어드레스에 문자와 속성을 순서대로 지정하면 된다.

리얼모드의 어드레스 계산 방식은 **세그먼트 레지스터에 정의된 기준 주소에 값을 더해 계산한다.**

> 따라서, **0xB8000** 어드레스에 접근하려면
> 세그먼트 레지스터에 세그먼트의 기준 주소부터 설정해야 한다.

<세그먼트 레지스터에 비디오 메모리 어드레스 설정>

```assembly
mov ax, 0xB800 	; AX 레지스터에 0xB800 복사
mov ds, ax		; DS 세그먼트 레지스터에 AX 레지스터의 값(0xB800)복사
```

DS 세그먼트 레지스터에 0xB800 값을 설정하였으니, 
이후 데이터에 접근하는 명령어는 물리주소 0xB8000이 기준 어드레스로 사용된다.

화면 맨 위의 어드레스는 0xB8000과 같으므로 0xB8000과 0xB8001에 각각 'M'과 0x4A를 쓰면,
빨간 배경에 밝은 녹색으로 'M'을 출력할 수 있다.

```assembly
mov byte [ 0x00 ], 'M'		; DS 세그먼트 : 오프셋 0xB800:0x0000에 'M' 복사
mov byte [ 0x01 ], 0x4A		; DS 세그먼트 : 오프셋 0xB800:0x0001에 0x4A 복사
```

<hr>

### 화면을 정리하는 방법

화면을 정리하는 가장 간단한 방법은 0xB8000 어드레스 부터 80 * 25 * 2 Byte를 모두 0으로 채우는 것이다.

```assembly
mov si, 0							; SI 레지스터(문자열 원본 인덱스 레지스터)를 초기화 한다.

.SCREENCLEARLOOP:					; 화면을 지우는 루프
	mov byte [ es: si], 0			; 비디오 메모리의 문자가 위치하는 어드레스에
									; 0을 복사하여 문자를 삭제한다.
	mov byte [ es: si + 1], 0x0A	; 비디오 메모리의 속성이 위치하는 어드레스에
									; 0x0A(검은 바탕에 밝은 녹색)을 복사한다.
								
	add si, 2						; 문자와 속성을 설정했으므로 다음 위치로 이동한다.
	
	cmp si, 80 * 25 * 2				; 화면 전체의 크기는 80문자 * 25라인 이므로
									; 출력한 문자의 수를 의미하는 SI 레지스터와 비교한다.
	jl. SCREENCLEARLOOP				; SI 레지스터가 80 * 25 * 2보다 작으면 아직 지우지 못한
									; 영역이 있으므로 .SCREENCLEARLOOP 레이블로 이동한다.
```

<hr>

### 메시지를 출력하는 방법

```assembly
	mov si, 0							; SI 레지스터(문자열의 원본 인덱스 레지스터)를 초기화
	mov di, 0							; DI 레지스터(문자열 대상 인덱스 레지스터)를 초기화
	
.MESSAGELOOP:							; 메시지를 출력하는 루프
	mov cl, byte [ si + MESSAGE1 ]		; MESSAGE1의 어드레스에서 SI 레지스터 값만큼
										; 더한 위치의 문자를 CL 레지스터에 복사한다.
										; CL 레지스터는 CX 레지스터의 하위 1바이트를 의미한다.
										; 문자열은 1바이트면 충분하므로, 
										; CX 레지스터의 하위 1바이트만 사용한다.
	cmp cl, 0							; 복사된 문자와 0을 비교
	je .MESSAGELOOP						; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미
										; .MESSAGEEND로 이동하여 문자 출력을 종료한다.
	
	mov byte [ es: di ], cl				; 0이 아니면 비디오 메모리 어드레스 0xB800:di에
										; 문자를 출력한다.
	
	add si, 1					; SI 레지스터에 1을 더하여 다음 문자열로 이동
	add di, 2					; DI 레지스터에 2를 더하여 비디오 메모리의 다음 문자로 이동
								; 비디오 메모리는 (문자, 속성)의 쌍으로 구성되므로
								; 문자만 출력하려면 2를 더해야 한다.
	
	jmp .MESSAGELOOP			; 메시지 출력 루프로 이동하여 다음 문자를 출력
.MESSAGEEND:					

MESSAGE1:	db 'OS BootLoader Start!', 0	; 출력할 메시지 정의
											; 마지막은 0으로 설정해서
											; .MESSAGELOOP에서 처리할 수 있게 한다.
```

<hr>

### 문자열 출력을 포함한 BootLoader 소스

```assembly
[ORG 0x00]          ; 코드의 시작 어드레스를 0x00으로 설정
[BITS 16]           ; 이하의 코드는 16비트 코드로 설정

SECTION .text       ; text 섹션(세그먼트)을 정의

; BIOS는
; 부트로더가 존재한다면 코드를 0x7C00 어드레스에 복사한 후,
; 프로세서가 0x7C00 어드레스부터 코드를 수행하도록 한다.
jmp 0x07C0:START    ; CS 세그먼트 레지스터에 0x07C0을 복사하면서, START 레이블로 이동

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	START 세그먼트 레지스터 초기화
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START:
    mov ax, 0x07C0  ; 부트 로더의 시작 어드레스(0x7C00)를 세그먼트 레지스터 값으로 변환
    mov ds, ax      ; DS 세그먼트 레지스터에 설정
    mov ax, 0xB800  ; 비디오 메모리의 시작 어드레스(0xB800)를 세그먼트 레지스터 값으로 변환
    mov es, ax      ; ES 세그먼트 레지스터에 설정

    mov si,    0                    ; SI 레지스터(문자열 원본 인덱스 레지스터)를 초기화


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	화면을 정리한다.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.SCREENCLEARLOOP:                   ; 화면을 지우는 루프
    mov byte [ es: si ], 0          ; 비디오 메모리의 문자가 위치하는 어드레스에
                                    ; 0을 복사하여 문자를 삭제
    mov byte [ es: si + 1 ], 0x0A   ; 비디오 메모리의 속성이 위치하는 어드레스에
                                    ; 0x0A(검은 바탕에 밝은 녹색)을 복사

    add si, 2                       ; 문자와 속성을 설정했으므로 다음 위치로 이동

    cmp si, 80 * 25 * 2     ; 화면의 전체 크기는 80 문자 * 25 라인임
                            ; 출력한 문자의 수를 의미하는 SI 레지스터와 비교
    jl .SCREENCLEARLOOP     ; SI 레지스터가 80 * 25 * 2보다 작다면 아직 지우지 
                            ; 못한 영역이 있으므로 .SCREENCLEARLOOP 레이블로 이동
    
    mov si, 0               ; SI 레지스터(문자열 원본 인덱스 레지스터)를 초기화
    mov di, 0               ; DI 레지스터(문자열 대상 인덱스 레지스터)를 초기화
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	화면에 문자를 출력한다.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.MESSAGELOOP:                       ; 메시지를 출력하는 루프
    mov cl, byte [ si + MESSAGE1 ]  ; MESSAGE1의 어드레스에서 SI 레지스터 값만큼
                                    ; 더한 위치의 문자를 CL 레지스터에 복사
                                    ; CL 레지스터는 CX 레지스터의 하위 1바이트를 의미
                                 ; 문자열은 1바이트면 충분하므로 CX 레지스터의 하위 1바이트만 사용
    
    cmp cl, 0               ; 복사된 문자와 0을 비교
    je .MESSAGEEND          ; 복사한 문자의 값이 0이면 문자열이 종료되었음을
                            ; 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료

    mov byte [ es: di ], cl ; 0이 아니라면 비디오 메모리 어드레스 0xB800:di에 문자를 출력
    
    add si, 1               ; SI 레지스터에 1을 더하여 다음 문자열로 이동
    add di, 2               ; DI 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동
                            ; 비디오 메모리는 (문자, 속성)의 쌍으로 구성되므로 문자만 출력하려면
                            ; 2를 더해야 함

    jmp .MESSAGELOOP        ; 메시지 출력 루프로 이동하여 다음 문자를 출력
.MESSAGEEND:
    
    jmp $                   ; 현재 위치에서 무한 루프 수행

MESSAGE1:    db 'MINT64 OS Boot Loader Start~!!', 0; 출력할 메시지 정의
                                                   ; 마지막은 0으로 설정하여 .MESSAGELOOP에서 
                                                   ; 문자열이 종료되었음을 알 수 있도록 함
    
times 510 - ( $ - $$ )    db    0x00    ; $ : 현재 라인의 어드레스
                                        ; $$ : 현재 섹션(.text)의 시작 어드레스
                                        ; $ - $$ : 현재 섹션을 기준으로 하는 오프셋
                                        ; 510 - ( $ - $$ ) : 현재부터 어드레스 510까지
                                        ; db 0x00 : 1바이트를 선언하고 값은 0x00
                                        ; time : 반복 수행
                                        ; 현재 위치에서 어드레스 510까지 0x00으로 채움

db 0x55             ; 1바이트를 선언하고 값은 0x55
db 0xAA             ; 1바이트를 선언하고 값은 0xAA
                    ; 어드레스 511, 512에 0x55, 0xAA를 써서 부트 섹터로 표기함
```

#### 코드 정리

- **jmp 0x07C0:START** :

  BIOS는  POST(Power On Self Test)를 수행한 후 여러 장치의 앞부분을 검사하여 부트로더가 있는지 찾는다.
  
  (511, 512번째 바이트가 0x55, 0xAA인지 확인한다.)
  부트 로더가 존재한다면 코드를 0x07C0 어드레스에 복사한 후,(CS 에 0x07C0이 복사된다.)
  프로세서가 0x7C00 어드레스부터 코드를 수행하도록 한다.
  jmp 0x07C0:START    ; CS 세그먼트 레지스터에 0x07C0을 복사하면서, START 레이블로 이동



